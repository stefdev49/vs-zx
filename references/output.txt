SPECTRUM 128 ROM 0 DISASSEMBLY

The Spectrum ROMs are copyright Amstrad, who have kindly given permission to reverse engineer and publish Spectrum ROM disassemblies.

Image © Bill Bertram 2006

1

SPECTRUM 128 ROM 0 DISASSEMBLY

CONTENTS

NOTES  .............................................................................................................................................................................................................................  10
Release  Date  ............................................................................................................................................................................................................  10
Disassembly  Contributors  .........................................................................................................................................................................................  10
Markers  .....................................................................................................................................................................................................................  10
REFERENCE INFORMATION — PART 1 .....................................................................................................................................................................  10
128  BASIC  Mode  Limitations  ..........................................................................................................................................................................................   10
Timing  Information  ...........................................................................................................................................................................................................   10
I/O  Details  ........................................................................................................................................................................................................................  11
Memory  Paging  ........................................................................................................................................................................................................   11
Memory  Map  ............................................................................................................................................................................................................   11
Shadow  Display  File  .................................................................................................................................................................................................  11
Contended  Memory  ..................................................................................................................................................................................................   11
Logical  RAM  Banks  ..................................................................................................................................................................................................  11
AY-3-8912  Sound  Generator  ...................................................................................................................................................................................   11
I/O Port A (AY-3-8912 Register 14) ......................................................................................................................................................................... 12
Standard  I/O  Ports  ...................................................................................................................................................................................................   12
Error  Report  Codes  .........................................................................................................................................................................................................   12
Standard  Error  Report  Codes  ..................................................................................................................................................................................   12
New  Error  Report  Codes  .........................................................................................................................................................................................   12
System  Variables  .............................................................................................................................................................................................................  12
New  System  Variables  .............................................................................................................................................................................................   12
Standard  System  Variables  ......................................................................................................................................................................................  14
RAM  Disk  Catalogue  ................................................................................................................................................................................................  14
Editor  Workspace  Variables  .....................................................................................................................................................................................  14
Called  ROM  1  Subroutines  .............................................................................................................................................................................................   18
RESTART ROUTINES — PART 1 .................................................................................................................................................................................  20
RST  $00  —  Reset  Machine  .....................................................................................................................................................................................  20
RST  $10  —  Print  A  Character  .................................................................................................................................................................................  20
RST  $18  —  Collect  A  Character  .............................................................................................................................................................................   20
RST $20 — Collect Next Character ........................................................................................................................................................................  20
RST $28 — Call Routine in ROM 1 ........................................................................................................................................................................  21
MASKABLE INTERRUPT ROUTINE ..............................................................................................................................................................................  21
ERROR HANDLER ROUTINES — PART 1 ................................................................................................................................................................... 21
128K  Error  Routine  ..................................................................................................................................................................................................   21
RESTART ROUTINES — PART 2 .................................................................................................................................................................................  21
Call ROM 1 Routine (RST $28 Continuation) .........................................................................................................................................................  21
RAM  ROUTINES  .............................................................................................................................................................................................................   22
Swap to Other ROM (copied to $5B00) ..................................................................................................................................................................  22
Return to Other ROM Routine (copied to $5B14) ...................................................................................................................................................  22
Error Handler Routine (copied to $5B1D) ...............................................................................................................................................................  23
'P' Channel Input Routine (copied to $5B2F) ..........................................................................................................................................................  23
'P' Channel Output Routine (copied to $5B34) .......................................................................................................................................................  23
'P' Channel Exit Routine (copied to $5B4A) ............................................................................................................................................................ 23
ERROR HANDLER ROUTINES — PART 2 ................................................................................................................................................................... 24
Call  Subroutine  .........................................................................................................................................................................................................   24
INITIALISATION ROUTINES — PART 1 ........................................................................................................................................................................ 24
Reset Routine (RST $00 Continuation, Part 1) .......................................................................................................................................................  24
ROUTINE  VECTOR  TABLE  ............................................................................................................................................................................................  24
INITIALISATION ROUTINES — PART 2 ........................................................................................................................................................................ 25
Fatal  RAM  Error  .......................................................................................................................................................................................................   25
Reset Routine (RST $00 Continuation, Part 2) .......................................................................................................................................................  25
COMMAND EXECUTION ROUTINES — PART 1 .........................................................................................................................................................  27
Execute  Command  Line  ...........................................................................................................................................................................................  27
Return from BASIC Line Syntax Check ................................................................................................................................................................... 28
Parse a BASIC Line with No Line Number .............................................................................................................................................................  28
ERROR HANDLER ROUTINES — PART 3 ................................................................................................................................................................... 29
Error  Handler  Routine  ..............................................................................................................................................................................................   29
Error Handler Routine When Parsing BASIC Line ..................................................................................................................................................  31
COMMAND EXECUTION ROUTINES — PART 2 .........................................................................................................................................................  31
Parse a BASIC Line with a Line Number ................................................................................................................................................................ 31
ERROR HANDLER ROUTINES — PART 4 ................................................................................................................................................................... 32
New Error Message Vector Table ...........................................................................................................................................................................  32
New  Error  Message  Table  .......................................................................................................................................................................................   33

2

SPECTRUM 128 ROM 0 DISASSEMBLY

Print  Message  ..........................................................................................................................................................................................................   33
INITIALISATION ROUTINES — PART 3 ........................................................................................................................................................................ 34
The  'Initial  Channel  Information'  ...............................................................................................................................................................................  34
The  'Initial  Stream  Data'  ...........................................................................................................................................................................................  34
ERROR HANDLER ROUTINES — PART 5 ................................................................................................................................................................... 34
Produce  Error  Report  ...............................................................................................................................................................................................   34
Check  for  BREAK  into  Program  ..............................................................................................................................................................................   35
RS232  PRINTER  ROUTINES  .........................................................................................................................................................................................   35
RS232 Channel Handler Routines ........................................................................................................................................................................... 35
FORMAT  Routine  .....................................................................................................................................................................................................   36
Baud  Rate  Table  ......................................................................................................................................................................................................   38
RS232  Input  Routine  ................................................................................................................................................................................................  38
Read  Byte  from  RS232  Port  ....................................................................................................................................................................................   38
RS232  Output  Routine  .............................................................................................................................................................................................   41
Write  Byte  to  RS232  Port  ........................................................................................................................................................................................   44
COPY  Command  Routine  ........................................................................................................................................................................................   45
Output  Half  Row  .......................................................................................................................................................................................................  45
Output  Nibble  of  Pixels  ............................................................................................................................................................................................   46
Output  Characters  from  Table  .................................................................................................................................................................................   46
Test  Whether  Pixel  (B,C)  is  Set  ..............................................................................................................................................................................   47
EPSON Printer Control Code Tables ......................................................................................................................................................................  47
PLAY  COMMAND  ROUTINES  ........................................................................................................................................................................................  47
Command  Data  Block  Format  ..................................................................................................................................................................................  47
Channel  Data  Block  Format  .....................................................................................................................................................................................  48
Calculate Timing Loop Counter « RAM Routine » ..................................................................................................................................................  50
Test  BREAK  Key  ......................................................................................................................................................................................................  50
Select Channel Data Block Duration Pointers .........................................................................................................................................................  50
Select Channel Data Block Pointers ........................................................................................................................................................................ 51
Get Channel Data Block Address for Current String ............................................................................................................................................... 51
Next  Channel  Data  Pointer  ......................................................................................................................................................................................   51
PLAY  Command  (Continuation)  ...............................................................................................................................................................................   51
PLAY Command Character Table ...........................................................................................................................................................................  52
Get  Play  Character  ...................................................................................................................................................................................................  52
Get  Next  Note  in  Semitones  ....................................................................................................................................................................................   52
Get Numeric Value from Play String .......................................................................................................................................................................  53
Multiply  DE  by  10  .....................................................................................................................................................................................................  54
Find Next Note from Channel String .......................................................................................................................................................................  54
Play  Command  '!'  (Comment)  ..................................................................................................................................................................................   54
Play  Command  'O'  (Octave)  .....................................................................................................................................................................................  54
Play  Command  'N'  (Separator)  .................................................................................................................................................................................  55
Play Command '(' (Start of Repeat) .........................................................................................................................................................................  55
Play Command ')' (End of Repeat) ..........................................................................................................................................................................  55
Get Address of Bracket Pointer Store .....................................................................................................................................................................  56
Play  Command  'T'  (Tempo)  .....................................................................................................................................................................................   57
Tempo  Command  Return  .........................................................................................................................................................................................  57
Play  Command  'M'  (Mixer)  .......................................................................................................................................................................................   58
Play  Command  'V'  (Volume)  ....................................................................................................................................................................................   58
Play Command 'U' (Use Volume Effect) ..................................................................................................................................................................  58
Play command 'W' (Volume Effect Specifier) ..........................................................................................................................................................  59
Play Command 'X' (Volume Effect Duration) ...........................................................................................................................................................  59
Play Command 'Y' (MIDI Channel) ..........................................................................................................................................................................  59
Play Command 'Z' (MIDI Programming Code) ......................................................................................................................................................... 60
Play  Command  'H'  (Stop)  .........................................................................................................................................................................................  60
Play Commands 'a'..'g', 'A'..'G', '1'.."12", '&' and '_' .................................................................................................................................................  60
End  of  String  Found  .................................................................................................................................................................................................  62
Point to Duration Length within Channel Data Block ..............................................................................................................................................  62
Store Entry in Command Data Block's Channel Duration Length Pointer Table ..................................................................................................... 62
PLAY  Command  Jump  Table  ..................................................................................................................................................................................   63
Envelope Waveform Lookup Table .......................................................................................................................................................................... 63
Identify  Command  Character  ...................................................................................................................................................................................   63
Semitones  Table  ......................................................................................................................................................................................................   63
Find  Note  Duration  Length  .......................................................................................................................................................................................  64
Note  Duration  Table  .................................................................................................................................................................................................   64
Is  Numeric  Digit?  ......................................................................................................................................................................................................  64
Play a Note On a Sound Chip Channel ..................................................................................................................................................................  64
Set  Sound  Generator  Register  .................................................................................................................................................................................  65
Read  Sound  Generator  Register  .............................................................................................................................................................................   66
Turn  Off  All  Sound  ...................................................................................................................................................................................................   66
Get Previous Character from Play String ................................................................................................................................................................  66
Get Current Character from Play String ..................................................................................................................................................................  67

3

SPECTRUM 128 ROM 0 DISASSEMBLY

Produce  Play  Error  Reports  .....................................................................................................................................................................................   67
Play  Note  on  Each  Channel  ....................................................................................................................................................................................   68
Wait  Note  Duration  ...................................................................................................................................................................................................  68
Find  Smallest  Duration  Length  .................................................................................................................................................................................  69
Play a Note on Each Channel and Update Channel Duration Lengths ..................................................................................................................  69
Note  Lookup  Table  ...................................................................................................................................................................................................  71
Play  Note  on  MIDI  Channel  .....................................................................................................................................................................................   73
Turn  MIDI  Channel  Off  .............................................................................................................................................................................................  74
Send  Byte  to  MIDI  Device  .......................................................................................................................................................................................   74
CASSETTE / RAM DISK COMMAND ROUTINES — PART 1 ......................................................................................................................................  75
SAVE  Routine  ..........................................................................................................................................................................................................   75
LOAD  Routine  ..........................................................................................................................................................................................................   75
VERIFY  Routine  .......................................................................................................................................................................................................   75
MERGE  Routine  .......................................................................................................................................................................................................   75
RAM  Disk  Command  Handling  ................................................................................................................................................................................   76
RAM  Disk  VERIFY!  Routine  ....................................................................................................................................................................................   77
RAM  Disk  MERGE!  Routine  ....................................................................................................................................................................................   77
RAM  Disk  LOAD!  Routine  ........................................................................................................................................................................................  78
RAM  Disk  Load  Bytes  ..............................................................................................................................................................................................  80
Get Expression from BASIC Line ............................................................................................................................................................................  80
Check  Filename  and  Copy  ......................................................................................................................................................................................   80
Cassette / RAM Disk Command Handling ............................................................................................................................................................... 81
EDITOR  ROUTINES  —  PART  1  ....................................................................................................................................................................................   85
Relist the BASIC Program from the Current Line ...................................................................................................................................................  85
Print All Screen Line Edit Buffer Rows to the Display File ...................................................................................................................................... 88
Clear  Editing  Display  ................................................................................................................................................................................................  89
Shift All Edit Buffer Rows Up and Update Display File if Required ........................................................................................................................  89
Shift All Edit Buffer Rows Down and Update Display File if Required ....................................................................................................................  90
Insert Character into Edit Buffer Row, Shifting Row Right ......................................................................................................................................  91
Insert Character into Edit Buffer Row, Shifting Row Left ........................................................................................................................................  91
BASIC LINE AND COMMAND INTERPRETATION ROUTINES — PART 1 .................................................................................................................  92
The  Syntax  Offset  Table  ..........................................................................................................................................................................................   92
The  Syntax  Parameter  Table  ...................................................................................................................................................................................   93
The 'Main Parser' Of the BASIC Interpreter ............................................................................................................................................................  95
The  Statement  Loop  .................................................................................................................................................................................................  95
The  'Separator'  Subroutine  ......................................................................................................................................................................................   96
The 'Statement Return' Subroutine .......................................................................................................................................................................... 96
The  'Line  Run'  Entry  Point  .......................................................................................................................................................................................   97
The  'Line  New'  Subroutine  .......................................................................................................................................................................................  97
REM  Routine  ............................................................................................................................................................................................................   97
The  'Line  End'  Routine  .............................................................................................................................................................................................  97
The  'Line  Use'  Routine  .............................................................................................................................................................................................  98
The  'Next  Line'  Routine  ............................................................................................................................................................................................  98
The  'CHECK-END'  Subroutine  .................................................................................................................................................................................   98
The  'STMT-NEXT'  Routine  .......................................................................................................................................................................................  99
The  'Command  Class'  Table  ....................................................................................................................................................................................  99
The 'Command Classes — 0C, 0D & 0E' ...............................................................................................................................................................  99
The 'Command Classes — 00, 03 & 05' ............................................................................................................................................................... 100
The  'Command  Class  —  01'  ..................................................................................................................................................................................  100
The  'Command  Class  —  02'  ..................................................................................................................................................................................  100
The  'Command  Class  —  04'  ..................................................................................................................................................................................  100
The  'Command  Class  —  08'  ..................................................................................................................................................................................  101
The  'Command  Class  —  06'  ..................................................................................................................................................................................  101
Report C — Nonsense in BASIC ..........................................................................................................................................................................  101
The  'Command  Class  —  0A'  .................................................................................................................................................................................   101
The  'Command  Class  —  07'  ..................................................................................................................................................................................  101
The  'Command  Class  —  09'  ..................................................................................................................................................................................  102
The  'Command  Class  —  0B'  .................................................................................................................................................................................   102
IF  Routine  ...............................................................................................................................................................................................................  102
FOR  Routine  ..........................................................................................................................................................................................................   102
READ  Routine  ........................................................................................................................................................................................................   103
DATA  Routine  ........................................................................................................................................................................................................   104
RUN  Routine  ..........................................................................................................................................................................................................   104
CLEAR  Routine  ......................................................................................................................................................................................................   104
GO  SUB  Routine  ....................................................................................................................................................................................................  105
RETURN  Routine  ...................................................................................................................................................................................................   105
DEF  FN  Routine  .....................................................................................................................................................................................................  106
MOVE  Routine  .......................................................................................................................................................................................................   107
MENU  ROUTINES  —  PART  1  .....................................................................................................................................................................................   107
Run  Tape  Loader  ...................................................................................................................................................................................................   107

4

SPECTRUM 128 ROM 0 DISASSEMBLY

List  Program  to  Printer  ...........................................................................................................................................................................................  107
BASIC LINE AND COMMAND INTERPRETATION ROUTINES — PART 2 ...............................................................................................................  108
SPECTRUM  Routine  ..............................................................................................................................................................................................   108
MENU  ROUTINES  —  PART  2  .....................................................................................................................................................................................   108
Main Menu — 48 BASIC Option ...........................................................................................................................................................................  108
Set  'P'  Channel  Data  ..............................................................................................................................................................................................  108
LOAD  ""  Command  Bytes  ......................................................................................................................................................................................   109
BASIC LINE AND COMMAND INTERPRETATION ROUTINES — PART 3 ...............................................................................................................  109
LLIST  Routine  ........................................................................................................................................................................................................   109
LIST  Routine  ..........................................................................................................................................................................................................   109
RAM  Disk  SAVE!  Routine  ......................................................................................................................................................................................  109
CAT!  Routine  ..........................................................................................................................................................................................................   110
ERASE!  Routine  .....................................................................................................................................................................................................   110
RAM DISK COMMAND ROUTINES — PART 2 ..........................................................................................................................................................  110
Load  Header  from  RAM  Disk  .................................................................................................................................................................................  110
Load  from  RAM  Disk  ..............................................................................................................................................................................................  111
PAGING  ROUTINES  —  PART  1  ..................................................................................................................................................................................   111
Page  Logical  RAM  Bank  ........................................................................................................................................................................................  111
Physical RAM Bank Mapping Table ......................................................................................................................................................................  111
RAM DISK COMMAND ROUTINES — PART 3 ..........................................................................................................................................................  112
Compare  Filenames  ...............................................................................................................................................................................................   112
Create  New  Catalogue  Entry  .................................................................................................................................................................................   112
Adjust  RAM  Disk  Free  Space  ................................................................................................................................................................................   113
Find Catalogue Entry for Filename ........................................................................................................................................................................  113
Find  RAM  Disk  File  ................................................................................................................................................................................................   114
Update  Catalogue  Entry  .........................................................................................................................................................................................  114
Save  Bytes  to  RAM  Disk  .......................................................................................................................................................................................   115
Load  Bytes  from  RAM  Disk  ...................................................................................................................................................................................   116
Transfer Bytes to RAM Bank 4 — Vector Table Entry .......................................................................................................................................... 118
Transfer Bytes from RAM Bank 4 — Vector Table Entry ...................................................................................................................................... 119
PAGING  ROUTINES  —  PART  2  ..................................................................................................................................................................................   119
Use Normal RAM Configuration  ............................................................................................................................................................................. 119
Select  RAM  Bank  ...................................................................................................................................................................................................   119
Use Workspace RAM Configuration ......................................................................................................................................................................  120
RAM DISK COMMAND ROUTINES — PART 4 ..........................................................................................................................................................  120
Erase  a  RAM  Disk  File  ..........................................................................................................................................................................................   120
Print  RAM  Disk  Catalogue  .....................................................................................................................................................................................   123
Print  Catalogue  Filename  Data  ..............................................................................................................................................................................  124
Print  Single  Catalogue  Entry  ..................................................................................................................................................................................  124
BASIC LINE AND COMMAND INTERPRETATION ROUTINES — PART 4 ...............................................................................................................  125
LPRINT  Routine  .....................................................................................................................................................................................................   125
PRINT  Routine  .......................................................................................................................................................................................................   125
INPUT  Routine  .......................................................................................................................................................................................................   125
COPY  Routine  ........................................................................................................................................................................................................   125
NEW  Routine  ..........................................................................................................................................................................................................  126
CIRCLE  Routine  .....................................................................................................................................................................................................   126
DRAW  Routine  .......................................................................................................................................................................................................   126
DIM  Routine  ...........................................................................................................................................................................................................   126
Error Report C — Nonsense in BASIC .................................................................................................................................................................  127
Clear  Screen  Routine  .............................................................................................................................................................................................  127
Evaluate  Numeric  Expression  ................................................................................................................................................................................   127
Process  Key  Press  .................................................................................................................................................................................................  128
Find  Start  of  BASIC  Command  ..............................................................................................................................................................................  128
Is  LET  Command?  .................................................................................................................................................................................................   129
Is  Operator  Character?  ..........................................................................................................................................................................................   129
Operator  Tokens  Table  ..........................................................................................................................................................................................   129
Is  Function  Character?  ...........................................................................................................................................................................................  129
Is Numeric or Function Expression? ...................................................................................................................................................................... 130
Is  Numeric  Character?  ...........................................................................................................................................................................................   130
PLAY  Routine  .........................................................................................................................................................................................................   130
UNUSED ROUTINES — PART 1 ................................................................................................................................................................................. 131
Return  to  Editor  ......................................................................................................................................................................................................   131
BC=HL-DE,  Swap  HL  and  DE  ...............................................................................................................................................................................   131
Create  Room  for  1  Byte  .........................................................................................................................................................................................  131
Room  for  BC  Bytes?  ..............................................................................................................................................................................................   132
HL  =  A*32  ..............................................................................................................................................................................................................   132
HL  =  A*8  ................................................................................................................................................................................................................   132
Find  Amount  of  Free  Space  ...................................................................................................................................................................................  132
Print  Screen  Buffer  Row  ........................................................................................................................................................................................   132
Blank  Screen  Buffer  Content  .................................................................................................................................................................................   133

5

SPECTRUM 128 ROM 0 DISASSEMBLY

Print Screen Buffer to Display File ........................................................................................................................................................................  133
Print Screen Buffer Characters to Display File ...................................................................................................................................................... 134
Copy A Character « RAM Routine » .....................................................................................................................................................................  135
Toggle ROMs 1 « RAM Routine » ........................................................................................................................................................................  136
Toggle ROMs 2 « RAM Routine » ........................................................................................................................................................................  136
Construct 'Copy Character' Routine in RAM .........................................................................................................................................................  136
Set Attributes File from Screen Buffer ................................................................................................................................................................... 136
Set Attributes for a Screen Buffer Row .................................................................................................................................................................  137
Swap Ink and Paper Attribute Bits ........................................................................................................................................................................  138
Character  Data  .......................................................................................................................................................................................................   139
KEY  ACTION  TABLES  ..................................................................................................................................................................................................  139
Editing  Keys  Action  Table  ......................................................................................................................................................................................  139
Menu  Keys  Action  Table  ........................................................................................................................................................................................  140
MENU  ROUTINES  —  PART  3  .....................................................................................................................................................................................   140
Initialise  Mode  Settings  ..........................................................................................................................................................................................   140
Show  Main  Menu  ...................................................................................................................................................................................................   140
EDITOR  ROUTINES  —  PART  2  ..................................................................................................................................................................................   141
Return to Editor / Calculator / Menu from Error ..................................................................................................................................................... 141
Return  to  the  Editor  ................................................................................................................................................................................................  141
Main  Waiting  Loop  .................................................................................................................................................................................................   142
Process  Key  Press  .................................................................................................................................................................................................  142
TOGGLE  Key  Handler  Routine  ..............................................................................................................................................................................  143
Select  Lower  Screen  ..............................................................................................................................................................................................   143
Select  Upper  Screen  ..............................................................................................................................................................................................   144
Produce  Error  Beep  ...............................................................................................................................................................................................   144
Produce  Success  Beep  ..........................................................................................................................................................................................  144
MENU  ROUTINES  —  PART  4  .....................................................................................................................................................................................   145
Menu Key Press Handler Routines ............................................................................................................................................................................... 145
Menu Key Press Handler — MENU ......................................................................................................................................................................  145
Menu Key Press Handler — SELECT ................................................................................................................................................................... 145
Menu Key Press Handler — CURSOR UP ...........................................................................................................................................................  145
Menu Key Press Handler — CURSOR DOWN ..................................................................................................................................................... 145
Menu  Tables  ..................................................................................................................................................................................................................  146
Main  Menu  ..............................................................................................................................................................................................................  146
Edit  Menu  ...............................................................................................................................................................................................................   146
Calculator  Menu  .....................................................................................................................................................................................................   147
Tape  Loader  Text  ...................................................................................................................................................................................................  147
Menu  Handler  Routines  .................................................................................................................................................................................................  147
Edit  Menu  —  Screen  Option  ..................................................................................................................................................................................  147
Main Menu — Tape Tester Option ........................................................................................................................................................................  147
Edit Menu / Calculator Menu — Exit Option .......................................................................................................................................................... 147
Main Menu — Tape Loader Option .......................................................................................................................................................................  148
Edit  Menu — Renumber Option  ............................................................................................................................................................................  148
Edit  Menu  —  Print  Option  ......................................................................................................................................................................................  148
Main Menu — Calculator Option ...........................................................................................................................................................................  149
EDITOR  ROUTINES  —  PART  3  ..................................................................................................................................................................................   149
Reset  Cursor  Position  ............................................................................................................................................................................................   149
Return  to  Main  Menu  .............................................................................................................................................................................................   149
Main Screen Error Cursor Settings ........................................................................................................................................................................ 149
Lower Screen Good Cursor Settings .....................................................................................................................................................................  150
Initialise Lower Screen Editing Settings ................................................................................................................................................................. 150
Initialise Main Screen Editing Settings ................................................................................................................................................................... 150
Handle Key Press Character Code .......................................................................................................................................................................  150
DELETE-RIGHT Key Handler Routine ..................................................................................................................................................................  151
DELETE  Key  Handler  Routine  ...............................................................................................................................................................................  151
ENTER  Key  Handler  Routine  .................................................................................................................................................................................  151
TOP-OF-PROGRAM Key Handler Routine ............................................................................................................................................................ 152
END-OF-PROGRAM Key Handler Routine ...........................................................................................................................................................  153
WORD-LEFT Key Handler Routine .......................................................................................................................................................................  153
WORD-RIGHT Key Handler Routine .....................................................................................................................................................................  153
Remove  Cursor  ......................................................................................................................................................................................................   154
Show  Cursor  ...........................................................................................................................................................................................................  154
Display  Cursor  ........................................................................................................................................................................................................   154
Fetch  Cursor  Position  .............................................................................................................................................................................................  154
Store  Cursor  Position  .............................................................................................................................................................................................   154
Get Current Character from Screen Line Edit Buffer ............................................................................................................................................  155
TEN-ROWS-DOWN Key Handler Routine ............................................................................................................................................................. 155
TEN-ROWS-UP Key Handler Routine ...................................................................................................................................................................  156
END-OF-LINE Key Handler Routine ...................................................................................................................................................................... 156
START-OF-LINE Key Handler Routine .................................................................................................................................................................. 156

6

SPECTRUM 128 ROM 0 DISASSEMBLY

CURSOR-UP Key Handler Routine .......................................................................................................................................................................  157
CURSOR-DOWN Key Handler Routine ................................................................................................................................................................. 157
CURSOR-LEFT Key Handler Routine ...................................................................................................................................................................  158
CURSOR-RIGHT Key Handler Routine .................................................................................................................................................................  158
Edit  Buffer  Routines  —  Part  1  ......................................................................................................................................................................................   158
Find Closest Screen Line Edit Buffer Editable Position to the Right else Left ......................................................................................................  158
Find Closest Screen Line Edit Buffer Editable Position to the Left else Right ......................................................................................................  159
Insert BASIC Line, Shift Edit Buffer Rows Down If Required and Update Display File If Required ....................................................................... 159
Insert BASIC Line, Shift Edit Buffer Rows Up If Required and Update Display File If Required ...........................................................................  160
Find Next Screen Line Edit Buffer Editable Position to Left, Wrapping Above if Required ...................................................................................  160
Find Next Screen Line Edit Buffer Editable Position to Right, Wrapping Below if Required .................................................................................  161
Find Screen Line Edit Buffer Editable Position from Previous Column to the Right .............................................................................................. 163
Find Screen Line Edit Buffer Editable Position to the Left ....................................................................................................................................  163
Find Start of Word to Left in Screen Line Edit Buffer ...........................................................................................................................................  163
Find Start of Word to Right in Screen Line Edit Buffer .........................................................................................................................................  164
Find Start of Current BASIC Line in Screen Line Edit Buffer ................................................................................................................................ 165
Find End of Current BASIC Line in Screen Line Edit Buffer .................................................................................................................................  165
Insert BASIC Line into Program if Altered ............................................................................................................................................................. 166
Insert Line into BASIC Program If Altered and the First Row of the Line .............................................................................................................  166
Insert Line into BASIC Program  ............................................................................................................................................................................  166
Fetch Next Character from BASIC Line to Insert ..................................................................................................................................................  169
Fetch Next Character Jump Table ......................................................................................................................................................................... 170
Fetch Character from the Current Row of the BASIC Line in the Screen Line Edit Buffer .................................................................................... 170
Fetch Character from Edit Buffer Row ..................................................................................................................................................................  172
Upper  Screen  Rows  Table  .....................................................................................................................................................................................  172
Lower  Screen  Rows  Table  .....................................................................................................................................................................................  172
Reset  to  Main  Screen  ............................................................................................................................................................................................   173
Reset  to  Lower  Screen  ..........................................................................................................................................................................................   173
Find Edit Buffer Editable Position from Previous Column to the Right .................................................................................................................. 173
Find Edit Buffer Editable Position to the Left ........................................................................................................................................................  174
Fetch Edit Buffer Row Character ........................................................................................................................................................................... 174
Insert Character into Screen Line Edit Buffer ........................................................................................................................................................ 174
Insert Blank Row into Screen Edit Buffer, Shifting Rows Down ............................................................................................................................ 176
Empty  Edit  Buffer  Row  Data  ..................................................................................................................................................................................  176
Delete a Character from a BASIC Line in the Screen Line Edit Buffer .................................................................................................................  177
Shift Rows Up to Close Blank Row in Screen Line Edit Buffer ............................................................................................................................. 179
DELETE-WORD-LEFT Key Handler Routine ........................................................................................................................................................  180
DELETE-WORD-RIGHT Key Handler Routine ......................................................................................................................................................  181
DELETE-TO-START-OF-LINE Key Handler Routine ............................................................................................................................................. 182
DELETE-TO-END-OF-LINE Key Handler Routine ................................................................................................................................................. 182
Remove Cursor Attribute and Disable Updating Display File ................................................................................................................................  183
Previous Character Exists in Screen Line Edit Buffer? .........................................................................................................................................  183
Find Row Address in Screen Line Edit Buffer ....................................................................................................................................................... 184
Find Position within Screen Line Edit Buffer .........................................................................................................................................................  184
Below-Screen Line Edit Buffer Settings ................................................................................................................................................................. 184
Set Below-Screen Line Edit Buffer Settings ..........................................................................................................................................................  184
Shift Up Rows in Below-Screen Line Edit Buffer ..................................................................................................................................................  185
Shift Down Rows in Below-Screen Line Edit Buffer ..............................................................................................................................................  185
Insert Character into Below-Screen Line Edit Buffer .............................................................................................................................................  187
Find Row Address in Below-Screen Line Edit Buffer ............................................................................................................................................  188
Delete a Character from a BASIC Line in the Below-Screen Line Edit Buffer ......................................................................................................  188
Above-Screen Line Edit Buffer Settings ................................................................................................................................................................  189
Set Above-Screen Line Edit Buffer Settings .......................................................................................................................................................... 190
Shift Rows Down in the Above-Screen Line Edit Buffer .......................................................................................................................................  190
Shift Row Up into the Above-Screen Line Edit Buffer if Required ........................................................................................................................  191
Find Row Address in Above-Screen Line Edit Buffer ............................................................................................................................................ 192
BASIC Line Character Action Handler Jump Table ............................................................................................................................................... 192
Copy a BASIC Line into the Above-Screen or Below-Screen Line Edit Buffer .....................................................................................................  193
Set 'Continuation' Row in Line Edit Buffer ............................................................................................................................................................. 194
BASIC  Line  Handling  Routines  .....................................................................................................................................................................................   195
Find Address of BASIC Line with Specified Line Number ..................................................................................................................................... 195
Create Next Line Number Representation in Keyword Construction Buffer ..........................................................................................................  195
Fetch Next De-tokenized Character from Selected BASIC Line in Program Area ................................................................................................  195
Copy 'Insert Keyword Representation into Keyword Construction Buffer' Routine into RAM ................................................................................  196
Insert Keyword Representation into Keyword Construction Buffer « RAM Routine » ...........................................................................................  196
Copy Keyword Characters « RAM Routine » ........................................................................................................................................................  197
Identify  Token  from  Table  ......................................................................................................................................................................................   198
Create Next Line Number Representation in Keyword Construction Buffer ..........................................................................................................  199
Insert  ASCII  Line  Number  Digit  .............................................................................................................................................................................   200
Find Address of BASIC Line with Specified Line Number ..................................................................................................................................... 200

7

SPECTRUM 128 ROM 0 DISASSEMBLY

Move  to  Next  BASIC  Line  ......................................................................................................................................................................................  201
Check if at End of BASIC Program .......................................................................................................................................................................  201
Compare  Line  Numbers  .........................................................................................................................................................................................   201
Clear BASIC Line Construction Pointers ...............................................................................................................................................................  202
Find  Address  of  BASIC  Line  ..................................................................................................................................................................................  202
Fetch Next De-tokenized Character from BASIC Line in Program Area ...............................................................................................................  202
Edit  Buffer  Routines  —  Part  2  ......................................................................................................................................................................................   204
Keywords  String  Table  ...........................................................................................................................................................................................   204
Indentation  Settings  ................................................................................................................................................................................................  205
Set  Indentation  Settings  .........................................................................................................................................................................................   205
Store Character in Column of Edit Buffer Row .....................................................................................................................................................  205
'Enter'  Action  Handler  Routine  ...............................................................................................................................................................................   205
'Null Columns' Action Handler Routine ..................................................................................................................................................................  205
Null  Column  Positions  ............................................................................................................................................................................................   206
Indent  Edit  Buffer  Row  ...........................................................................................................................................................................................  206
Print Edit Buffer Row to Display File if Required ..................................................................................................................................................  206
Shift Up Edit Rows in Display File if Required ......................................................................................................................................................  207
Shift Down Edit Rows in Display File if Required .................................................................................................................................................  207
Set  Cursor  Attribute  Colour  ....................................................................................................................................................................................  207
Restore Cursor Position Previous Attribute ...........................................................................................................................................................  208
Reset  'L'  Mode  .......................................................................................................................................................................................................   208
Wait  for  a  Key  Press  ..............................................................................................................................................................................................  208
MENU  ROUTINES  —  PART  5  .....................................................................................................................................................................................   209
Display  Menu  ..........................................................................................................................................................................................................  209
Plot  a  Line  ..............................................................................................................................................................................................................   210
Print  "AT  B,C"  Characters  ......................................................................................................................................................................................  210
Print  String  ..............................................................................................................................................................................................................  210
Store  Menu  Screen  Area  .......................................................................................................................................................................................   210
Restore  Menu  Screen  Area  ...................................................................................................................................................................................   210
Store / Restore Menu Screen Row ........................................................................................................................................................................  211
Move  Up  Menu  .......................................................................................................................................................................................................  212
Move  Down  Menu  ..................................................................................................................................................................................................   212
Toggle Menu Option Selection Highlight ...............................................................................................................................................................  212
Menu  Title  Colours  Table  .......................................................................................................................................................................................  213
Menu  Title  Space  Table  .........................................................................................................................................................................................  213
Menu  Sinclair  Stripes  Bitmaps  ...............................................................................................................................................................................   213
Sinclair  Strip  'Text'  ..................................................................................................................................................................................................  213
Print the Sinclair stripes on the menu ...................................................................................................................................................................  214
Print  '128  BASIC'  Banner  .......................................................................................................................................................................................  214
Print  'Calculator'  Banner  .........................................................................................................................................................................................  214
Print  'Tape  Loader'  Banner  ....................................................................................................................................................................................   214
Print  'Tape  Tester'  Banner  .....................................................................................................................................................................................   214
Print  Banner  ...........................................................................................................................................................................................................   214
Clear  Lower  Editing  Display  ...................................................................................................................................................................................  215
RENUMBER  ROUTINE  .................................................................................................................................................................................................   215
Tokens  Using  Line  Numbers  ..................................................................................................................................................................................  216
Parse a Line Renumbering Line Number References ........................................................................................................................................... 216
Count the Number of BASIC Lines ........................................................................................................................................................................ 220
Skip  Spaces  ...........................................................................................................................................................................................................   220
Create ASCII Line Number Representation ........................................................................................................................................................... 220
Insert  Line  Number  Digit  ........................................................................................................................................................................................   221
EDITOR  ROUTINES  —  PART  4  ..................................................................................................................................................................................   221
Initial Lower Screen Cursor Settings .....................................................................................................................................................................  221
Initial Main Screen Cursor Settings .......................................................................................................................................................................  222
Set Main Screen Editing Cursor Details ................................................................................................................................................................  222
Set Lower Screen Editing Cursor Details ..............................................................................................................................................................  222
UNUSED ROUTINES — PART 2 ................................................................................................................................................................................. 222
Print  'AD'  .................................................................................................................................................................................................................  222
EDITOR  ROUTINES  —  PART  5  ..................................................................................................................................................................................   222
Store  Cursor  Colour  ...............................................................................................................................................................................................   222
Set  Cursor  Position  Attribute  .................................................................................................................................................................................   223
Restore Cursor Position Attribute ..........................................................................................................................................................................  223
Shift Up Edit Rows in Display File ......................................................................................................................................................................... 223
Shift Down Edit Rows in Display File ....................................................................................................................................................................  223
Print a Row of the Edit Buffer to the Screen ......................................................................................................................................................... 225
Clear  Display  Rows  ................................................................................................................................................................................................  225
Find Rows and Columns to End of Screen ...........................................................................................................................................................  226
Find  Rows  to  End  of  Screen  .................................................................................................................................................................................   226
Get  Attribute  Address  .............................................................................................................................................................................................  227
Exchange  Colour  Items  ..........................................................................................................................................................................................  227

8

SPECTRUM 128 ROM 0 DISASSEMBLY

TAPE  TESTER  ROUTINE  .............................................................................................................................................................................................  227
EDITOR  ROUTINES  —  PART  5  ..................................................................................................................................................................................   230
Tokenize  BASIC  Line  .............................................................................................................................................................................................   230
Fetch Next Character and Character Status from BASIC Line to Insert ...............................................................................................................  235
Is  Lowercase  Letter?  ..............................................................................................................................................................................................  235
Copy Keyword Conversion Buffer Contents into BASIC Line Workspace ............................................................................................................. 235
Insert Character into Keyword Conversion Buffer .................................................................................................................................................  236
Insert Character into BASIC Line Workspace, Handling '>' and '<' ....................................................................................................................... 237
Insert Character into BASIC Line Workspace, Handling 'REM' and Quotes .........................................................................................................  238
Insert Character into BASIC Line Workspace With Space Suppression ...............................................................................................................  239
Insert a Character into BASIC Line Workspace ....................................................................................................................................................  241
Room  for  BC  Bytes?  ..............................................................................................................................................................................................   243
Identify  Keyword  .....................................................................................................................................................................................................   243
Copy  Data  Block  ....................................................................................................................................................................................................   244
Get Numeric Value for ASCII Character ................................................................................................................................................................ 244
Call  Action  Handler  Routine  ...................................................................................................................................................................................  244
PROGRAMMERS'  INITIALS  ..........................................................................................................................................................................................  245
END  OF  ROM  MARKER  ...............................................................................................................................................................................................  245
REFERENCE INFORMATION — PART 2 ...................................................................................................................................................................  246
Routines Copied/Constructed in RAM ..........................................................................................................................................................................  246
Construct Keyword Representation ........................................................................................................................................................................ 246
Copy  Keyword  Characters  .....................................................................................................................................................................................   247
Identify  Token  .........................................................................................................................................................................................................   247
Insert Character into Display File ..........................................................................................................................................................................  248
Standard  Error  Report  Codes  .......................................................................................................................................................................................   249
Standard  System  Variables  ...........................................................................................................................................................................................  250
Memory  Map  ..................................................................................................................................................................................................................  252
I  Register  .......................................................................................................................................................................................................................   252
Screen  File  Formats  ......................................................................................................................................................................................................   252
Display  File  .............................................................................................................................................................................................................  252
Attributes  File  .........................................................................................................................................................................................................   253
Address Conversion Between Display File and Attributes File .............................................................................................................................. 253
Standard  I/O  Ports  ........................................................................................................................................................................................................   253
Port  $FE  .................................................................................................................................................................................................................   253
Cassette  Header  Format  ...............................................................................................................................................................................................   253
AY-3-8912 Programmable Sound Generator Registers ................................................................................................................................................ 254
Registers 0 and 1 (Channel A Tone Generator) ...................................................................................................................................................  254
Registers 2 and 3 (Channel B Tone Generator) ...................................................................................................................................................  254
Registers 4 and 5 (Channel C Tone Generator) ...................................................................................................................................................  254
Register  6  (Noise  Generator)  .................................................................................................................................................................................  254
Register 7 (Mixer — I/O Enable) ...........................................................................................................................................................................  254
Register  8  (Channel  A  Volume)  .............................................................................................................................................................................  254
Register  9  (Channel  B  Volume)  .............................................................................................................................................................................  255
Register 10 (Channel C Volume) ........................................................................................................................................................................... 255
Register 11 and 12 (Envelope Period) ..................................................................................................................................................................  255
Register  13  (Envelope  Shape)  ...............................................................................................................................................................................  255
Register  14  (I/O  Port)  .............................................................................................................................................................................................  256
Socket  Pin  Outs  ............................................................................................................................................................................................................   256
RS232/MIDI  Socket  ................................................................................................................................................................................................   256
Keypad  Socket  .......................................................................................................................................................................................................   257
Monitor  Socket  .......................................................................................................................................................................................................   257
Edge  Connector  .....................................................................................................................................................................................................   258

9

SPECTRUM 128 ROM 0 DISASSEMBLY

NOTES

Release Date
4th August 2017

Disassembly Contributors
Matthew Wilson (www.matthew-wilson.net/spectrum/rom/)
Andrew Owen (cheveron-AT-gmail.com)
Geoff Wearmouth (gwearmouth-AT-hotmail.com)
Rui Tunes
Paul Farrow (www.fruitcake.plus.com)

Markers
The following markers appear throughout the disassembly:
[...] = Indicates a comment about the code.
???? = Information to be determined.
For bugs, the following marker format is used:
[BUG - xxxx. Credit: yyyy] = Indicates a confirmed bug, with a description 'xxxx' of it and the discoverer 'yyyy'.
[BUG? - xxxx. Credit: yyyy] = Indicates a suspected bug, with a description 'xxxx' of it and the discoverer 'yyyy'.
Since many of the Spectrum 128 ROM routines were re-used in the Spectrum +2 and +3, where a bug was originally identified in the Spectrum +2 or +3
the discoverer is acknowledged along with who located the corresponding bug in the Spectrum 128.
For every bug identified, an example fix is provided and the author acknowledged. Some of these fixes can be made directly within the routines affected
since they do not increase the length of those routines. Others require the insertion of extra instructions and hence these cannot be completely fitted
within the routines affected. Instead a jump must be made to a patch routine located within a spare area of the ROM.
Fortunately there is 0.5K of unused routines located at $2336-$2536 (ROM 0) which are remnants of the original Spanish 128, and another unused routine
located at $3FC3-$3FCE (ROM 0). This is sufficient space to implement all of the bug fixes suggested.

REFERENCE INFORMATION — PART 1

128 BASIC Mode Limitations
There are a number of limitations when using 128 BASIC mode, some of which are not present when using the equivalent 48 BASIC mode operations.
These are more design decisions than bugs.

•
•
•
•
•
•

•

•

•

•

The RAM disk VERIFY command does not verify but simply performs a LOAD.
The renumber facility will not renumber line numbers that are defined as an expression, e.g. GO TO VAL "10".
The printer output routine cannot handle binary data and hence EPSON printer ESC codes cannot be sent.
The Editor has the following limitations:
Variables cannot have the same name as a keyword. This only applies when entering a program and not when one is loaded in.
Line number 0 is not supported and will not list properly. It is not possible to directly insert such a line, not even in 48 BASIC mode, and so
line number 0 is not officially supported.
There is a practical limitation on the size of lines that can be entered. It is limited to 20 indented rows, which is the size of the editing
buffers. Typed lines greater than 20 rows get inserted into the BASIC program, but only the first 20 rows are shown on screen. Editing such
a line causes it to be truncated to 20 rows. There is no warning when the 20 row limit is exceeded.
It is not possible to directly enter embedded control codes, or to correctly edit loaded in programs that contain them. Loaded programs that
contain them will run correctly so long as the lines are not edited.
It is not possible to embed the string of characters ">=", "<=" or "<>" into a string or REM statement without them being tokenized (this is
perhaps more an oversight than a design decision).
In 48 BASIC mode if the line '10 REM abc: PRINT xyz' is typed then the word PRINT is stored as a new keyword since the colon (arguably
incorrectly) reverts to 'K' mode. In 128 BASIC mode, typing the same line stores each letter as a separate character.

Timing Information
Clock Speed = 3.54690 MHz (48K Spectrum clock speed was 3.50000 MHz) Scan line = 228 T-states (48K Spectrum was 224 T-states).
TV scan lines = 311 total, 63 above picture (48K Spectrum had 312 total, 64 above picture).

10

SPECTRUM 128 ROM 0 DISASSEMBLY

I/O Details

Memory Paging
Memory paging is controlled by I/O port:
$7FFD (Out) - Bits 0-2: RAM bank (0-7) to page into memory map at $C000.
Bit 3 : 0=SCREEN 0 (normal display file in bank 5), 1=SCREEN 1 (shadow display file in bank 7).
Bit 4 : 0=ROM 0 (128K Editor), 1=ROM 1 (48K BASIC).
Bit 5 : 1=Disable further output to this port until a hard reset occurs.
Bit 6-7 : Not used (always write 0).
The Editor ROM (ROM 0) always places a copy of the last value written to port $7FFD into new system variable BANK_M ($5B5C).

Memory Map
ROM 0 or 1 resides at $0000-$3FFF.
RAM bank 5 resides at $4000-$7FFF always.
RAM bank 2 resides at $8000-$BFFF always.
Any RAM bank may reside at $C000-$FFFF.

Shadow Display File
The shadow screen may be active even when not paged into the memory map.

Contended Memory
Physical RAM banks 1, 3, 5 and 7 are contended with the ULA.

Logical RAM Banks
Throughout ROM 0, memory banks are accessed using a logical numbering scheme, which maps to physical RAM banks as follows:
Logical Bank

Physical Bank

$00
$01
$02
$03
$04
$05
This scheme makes the RAM disk code simpler than having to deal directly with physical RAM bank numbers.

$01
$03
$04
$06
$07
$00

AY-3-8912 Sound Generator
The AY-3-8912 sound generator is controlled by two I/O ports: $FFFD (Out) - Select a register 0-14.
$FFFD (In) - Read from the selected register.
$BFFD (In/Out) - Write to the selected register. The status of the register can also be read back.
The AY-3-8912 I/O port A is used to drive the RS232 and Keypad sockets.
Register

Function

Range

0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
See the end of this document for description on the sound generator registers.

Channel A fine pitch
Channel A course pitch
Channel B fine pitch
Channel B course pitch
Channel C fine pitch
Channel C course pitch
Noise pitch
Mixer
Channel A volume
Channel B volume
Channel C volume
Envelope fine duration
Envelope course duration
Envelope shape
I/O port A

8-bit (0-255)
4-bit (0-15)
8-bit (0-255)
4-bit (0-15)
8-bit (0-255)
4-bit (0-15)
5-bit (0-31)
8-bit (see end of file for description)
4-bit (0-15, see end of file for description)
4-bit (0-15, see end of file for description)
4-bit (0-15, see end of file for description)
8-bit (0-255)
8-bit (0-255)
4-bit (0-15)
8-bit (0-255)

11

SPECTRUM 128 ROM 0 DISASSEMBLY

I/O Port A (AY-3-8912 Register 14)
This controls the RS232 and Keypad sockets.
Select the port via a write to port $FFFD with 14, then read via port $FFFD and write via port $BFFD. The state of port $BFFD can also be read back.
Bit 0: KEYPAD CTS (out) - 0=Spectrum ready to receive, 1=Busy
Bit 1: KEYPAD RXD (out) - 0=Transmit high bit, 1=Transmit low bit
Bit 2: RS232 CTS (out) - 0=Spectrum ready to receive, 1=Busy
Bit 3: RS232 RXD (out) - 0=Transmit high bit, 1=Transmit low bit
Bit 4: KEYPAD DTR (in) - 0=Keypad ready for data, 1=Busy
Bit 5: KEYPAD TXD (in) - 0=Receive high bit, 1=Receive low bit
Bit 6: RS232 DTR (in) - 0=Device ready for data, 1=Busy
Bit 7: RS232 TXD (in) - 0=Receive high bit, 1=Receive low bit
See the end of this document for the pinouts for the RS232 and KEYPAD sockets.

Standard I/O Ports
See the end of this document for descriptions of the standard Spectrum I/O ports.

Error Report Codes

Standard Error Report Codes
See the end of this document for descriptions of the standard error report codes.

New Error Report Codes
a — MERGE error
b — Wrong file type

c — CODE error
d — Too many brackets
e — File already exists
f — Invalid name
g — File does not exist
h — File does not exist
i — Invalid device
j — Invalid baud rate
k — Invalid note name
l — Number too big
m — Note out of range
n — Out of range
o — Too many tied notes
p — © 1986 Sinclair Research Ltd

System Variables

MERGE! would not execute for some reason - either size or file type wrong.
A file of an inappropriate type was specified during RAM disk operation, for instance a CODE file in
LOAD!"name".
The size of the file would lead to an overrun of the top of memory.
Too many brackets around a repeated phrase in one of the arguments.
The file name specified has already been used.
The file name specified is empty or above 10 characters in length.
[Never used by the ROM].
The specified file could not be found.
The device name following the FORMAT command does not exist or correspond to a physical device.
The baud rate for the RS232 was set to 0.
PLAY came across a note or command it didn't recognise, or a command which was in lower case.
A parameter for a command is an order of magnitude too big.
A series of sharps or flats has taken a note beyond the range of the sound chip.
A parameter for a command is too big or too small. If the error is very large, error L results.
An attempt was made to tie too many notes together.
This error is given when too many PLAY channel strings are specified. Up to 8 PLAY channel strings
are supported by MIDI devices such as synthesisers, drum machines or sequencers. Note that a PLAY
command with more than 8 strings cannot be entered directly from the Editor. The Spanish 128 produces
"p Bad parameter" for this error. It could be that the intention was to save memory by using the existing
error message of "Q Parameter error" but the change of report code byte was overlooked.

New System Variables
These are held in the old ZX Printer buffer at $5B00-$5BFF.
Note that some of these names conflict with the system variables used by the ZX Interface 1.
20
SWAP
9
YOUNGER
18
ONERR
5
PIN
22
POUT

EQU $5B00
EQU $5B14
EQU $5B1D
EQU $5B2F
EQU $5B34

POUT2
TARGET
RETADDR

EQU $5B4A
EQU $5B58
EQU $5B5A

14
2
2

Swap paging subroutine.
Return paging subroutine.
Error handler paging subroutine.
RS232 input pre-routine.
RS232 token output pre-routine. This can be patched to bypass the control code
filter.
RS232 character output pre-routine.
Address of subroutine to call in ROM 1.
Return address in ROM 0.

12

BANK_M
RAMRST
RAMERR
BAUD

EQU $5B5C
EQU $5B5D
EQU $5B5E
EQU $5B5F

SERFL

EQU $5B61

COL
WIDTH

TVPARS
FLAGS3

$5B62
EQU $5B63
EQU $5B64

EQU $5B65
EQU $5B66

1
1
1
2

2

1
1

1
1

N_STR1

EQU $5B67

10

HD_00

EQU $5B71

HD_0B

EQU $5B72

HD_0D

HD_0F

EQU $5B74

EQU $5B76

HD_11

EQU $5B78

SC_00

SC_0B

SC_0D

SC_0F

OLDSP
SFNEXT
SFSPACE
ROW01

EQU $5B7A

EQU $5B7B

EQU $5B7D

EQU $5B7F

EQU $5B81
EQU $5B83
EQU $5B85
EQU $5B88

1

2

2

2

2

1

2

2

2

2
2
3
1

SPECTRUM 128 ROM 0 DISASSEMBLY

Copy of last byte output to I/O port $7FFD.
Stores instruction RST $08 and used to produce a standard ROM error.
Error number for use by RST $08 held in RAMRST.
Baud rate timing constant for RS232 socket. Default value of 11. [Name clash with
ZX Interface 1 system variable at $5CC3]
Second character received flag:
Bit 0 : 1=Character in buffer.
Bits 1-7: Not used (always hold 0).
Received Character.
Current column from 1 to WIDTH.
Paper column width. Default value of 80. [Name clash with ZX Interface 1 Edition 2
system variable at $5CB1]
Number of inline parameters expected by RS232 (e.g. 2 for AT).
Flags: [Name clashes with the ZX Interface 1 system variable at $5CB6]
Bit 0: 1=BASIC/Calculator mode, 0=Editor/Menu mode.
Bit 1: 1=Auto-run loaded BASIC program. [Set but never tested by the ROM]
Bit 2: 1=Editing RAM disk catalogue.
Bit 3: 1=Using RAM disk commands, 0=Using cassette commands.
Bit 4: 1=Indicate LOAD.
Bit 5: 1=Indicate SAVE.
Bit 6; 1=Indicate MERGE.
Bit 7: 1=Indicate VERIFY.
Used by RAM disk to store a filename. [Name clash with ZX Interface 1 system
variable at $5CDA]
Used by the renumber routine to store the address of the BASIC line being
examined.
Used by RAM disk to store file header information (see RAM disk Catalogue section
below for details). [Name clash with ZX Interface 1 system variable at $5CE6]
Used as column pixel counter in COPY routine.
Used by FORMAT command to store specified baud rate.
Used by renumber routine to store the number of digits in a pre-renumbered line
number reference. [Name clash with ZX Interface 1 system variable at $5CE7]
Used by RAM disk to store header info - length of block.
Used as half row counter in COPY routine.
Used by renumber routine to generate ASCII representation of a new line number.
Used by RAM disk to store file header information (see RAM disk Catalogue section
below for details). [Name clash with ZX Interface 1 system variable at $5CE9]
Used by RAM disk to store file header information (see RAM disk Catalogue section
below for details). [Name clash with ZX Interface 1 system variable at $5CEB]
Used by renumber routine to store the address of a referenced BASIC line.
Used by RAM disk to store file header information (see RAM disk Catalogue section
below for details). [Name clash with ZX Interface 1 system variable at $5CED]
Used by renumber routine to store existing VARS address/current address within a
line.
Used by RAM disk to store alternate file header information (see RAM disk
Catalogue section below for details).
Used by RAM disk to store alternate file header information (see RAM disk
Catalogue section below for details).
Used by RAM disk to store alternate file header information (see RAM disk
Catalogue section below for details).
Used by RAM disk to store alternate file header information (see RAM disk
Catalogue section below for details).
Stores old stack pointer when TSTACK in use.
End of RAM disk catalogue marker. Pointer to first empty catalogue entry.
Number of bytes free in RAM disk (3 bytes, 17 bit, LSB first).
Stores keypad data for row 3, and flags:
Bit 0 : 1=Key '+' pressed.
Bit 1 : 1=Key '6' pressed.
Bit 2 : 1=Key '5' pressed.
Bit 3 : 1=Key '4' pressed.
Bits 4-5: Always 0.
Bit 6 : 1=Indicates successful communications to the keypad.
Bit 7 : 1=If communications to the keypad established.

13

SPECTRUM 128 ROM 0 DISASSEMBLY

ROW23

EQU $5B89

1

ROW45

EQU $5B8A

1

SYNRET
LASTV
RNLINE
RNFIRST
RNSTEP
STRIP1

EQU $5B8B
EQU $5B8D
EQU $5B92
EQU $5B94
EQU $5B96
EQU $5B98

TSTACK

EQU $5BFF

2
5
2
2
2
32

n

Stores keypad key press data for rows 1 and 2:
Bit 0: 1=Key ')' pressed.
Bit 1: 1=Key '(' pressed.
Bit 2: 1=Key '*' pressed.
Bit 3: 1=Key '/' pressed.
Bit 4: 1=Key '-' pressed.
Bit 5: 1=Key '9' pressed.
Bit 6: 1=Key '8' pressed.
Bit 7: 1=Key '7' pressed.
Stores keypad key press data for rows 4 and 5:
Bit 0: Always 0.
Bit 1: 1=Key '.' pressed.
Bit 2: Always 0.
Bit 3: 1=Key '0' pressed.
Bit 4: 1=Key 'ENTER' pressed.
Bit 5: 1=Key '3' pressed.
Bit 6: 1=Key '2' pressed.
Bit 7: 1=Key '1' pressed.
Return address for ONERR routine.
Last value printed by calculator.
Address of the length bytes in the line currently being renumbered.
Starting line number when renumbering. Default value of 10.
Step size when renumbering. Default value of 10.
Used as RAM disk transfer buffer (32 bytes to $5BB7).
Used to hold Sinclair stripe character patterns (16 bytes to $5BA7).
...
Temporary stack (grows downwards). The byte at $5BFF is not actually used.

Standard System Variables
These occupy addresses $5C00-$5CB5.
See the end of this document for descriptions of the standard system variables.

RAM Disk Catalogue
The catalogue can occupy addresses $C000-$EBFF in physical RAM bank 7, starting at $EBFF and growing downwards.
Each entry contains 20 bytes:
Bytes $00-$09: Filename.
Bytes $0A-$0C: Start address of file in RAM disk area.
Bytes $0D-$0F: Length of file in RAM disk area.
Bytes $10-$12: End address of file in RAM disk area (used as current position indicator when loading/saving).
Byte $13 : Flags:
Bit 0 : 1=Entry requires updating.
Bits 1-7: Not used (always hold 0).
The catalogue can store up to 562 entries, and hence the RAM disk can never hold more than 562 files no matter how small the files themselves are.
Note that filenames are case sensitive.
The shadow screen (SCREEN 1) also resides in physical RAM bank 7 and so if more than 217 catalogue entries are created then SCREEN 1 will become
corrupted [Credit: Toni Baker, ZX Computing Monthly].
However, since screen 1 cannot be used from BASIC, it may have been a design decision to allow the RAM disk to overwrite it.
The actual files are stored in physical RAM banks 1, 3, 4 and 6 (logical banks 0, 1, 2, 3), starting from $C000 in physical RAM bank 1 and growing upwards.
A file consists of a 9 byte header followed by the data for the file. The header bytes have the following meaning:
Byte $00 : File type - $00=Program, $01=Numeric array, $02=Character array, $03=Code/Screen$.
Bytes $01-$02: Length of program/code block/screen$/array ($1B00 for screen$).
Bytes $03-$04: Start of code block/screen$ ($4000 for screen$).
Bytes $05-$06: Offset to the variables (i.e. length of program) if a program. For an array, $05 holds the variable name.
Bytes $07-$08: Auto-run line number for a program ($80 in high byte if no auto-run).

Editor Workspace Variables
These occupy addresses $EC00-$FFFF in physical RAM bank 7, and form a workspace used by 128 BASIC Editor.
Byte 0: Flags used when inserting a line into the BASIC program (first 4 bits are
$EC00
mutually exclusive).
Bit 0: 1=First row of the BASIC line off top of screen.
Bit 1: 1=On first row of the BASIC line.

3

14

SPECTRUM 128 ROM 0 DISASSEMBLY

Bit 2: 1=Using lower screen and only first row of the BASIC line visible.
Bit 3: 1=At the end of the last row of the BASIC line.
Bit 4: Not used (always 0).
Bit 5: Not used (always 0).
Bit 6: Not used (always 0).
Bit 7: 1=Column with cursor not yet found.
Byte 1: Column number of current position within the BASIC line being inserted.
Used when fetching characters.
Byte 2: Row number of current position within the BASIC line is being inserted.
Used when fetching characters.
Byte 0: Flags used upon an error when inserting a line into the BASIC program (first
4 bits are mutually exclusive).
Bit 0: 1=First row of the BASIC line off top of screen.
Bit 1: 1=On first row of the BASIC line.
Bit 2: 1=Using lower screen and only first row of the BASIC line visible.
Bit 3: 1=At the end of the last row of the BASIC line.
Bit 4: Not used (always 0).
Bit 5: Not used (always 0).
Bit 6: Not used (always 0).
Bit 7: 1=Column with cursor not yet found.
Byte 1: Start column number where BASIC line is being entered. Always holds 0.
Byte 2: Start row number where BASIC line is being entered.
Count of the number of editable characters in the BASIC line up to the cursor within
the Screen Line Edit Buffer.
Version of E_PPC used by BASIC Editor to hold last line number entered.
Current menu index.
Flags used by 128 BASIC Editor:
Bit 0: 1=Screen Line Edit Buffer (including Below-Screen Line Edit Buffer) is full.
Bit 1: 1=Menu is displayed.
Bit 2: 1=Using RAM disk.
Bit 3: 1=Current line has been altered.
Bit 4: 1=Return to calculator, 0=Return to main menu.
Bit 5: 1=Do not process the BASIC line (used by the Calculator).
Bit 6: 1=Editing area is the lower screen, 0=Editing area is the main screen.
Bit 7: 1=Waiting for key press, 0=Got key press.
Mode:
$00 = Edit Menu mode.
$04 = Calculator mode.
$07 = Tape Loader mode. [Effectively not used as overwritten by $FF]
$FF = Tape Loader mode.
Main screen colours used by the 128 BASIC Editor - alternate ATTR_P.
Main screen colours used by the 128 BASIC Editor - alternate MASK_P.
Temporary screen colours used by the 128 BASIC Editor - alternate ATTR_T.
Temporary screen colours used by the 128 BASIC Editor - alternate MASK_T.
Temporary store for P_FLAG:
Bit 0: 1=OVER 1, 0=OVER 0.
Bit 1: Not used (always 0).
Bit 2: 1=INVERSE 1, INVERSE 0.
Bit 3: Not used (always 0).
Bit 4: 1=Using INK 9.
Bit 5: Not used (always 0).
Bit 6: 1=Using PAPER 9.
Bit 7: Not used (always 0).
Not used.
Holds the number of editing lines: 20 for the main screen, 1 for the lower screen.
Screen Line Edit Buffer. This represents the text on screen that can be edited. It
holds 21 rows,
with each row consisting of 32 characters followed by 3 data bytes. Areas of white
space that do not contain any editable characters (e.g. the indent that starts
subsequent
rows of a BASIC line) contain the value $00.
Data Byte 0:

15

$EC03

3

$EC06

$EC08
$EC0C
$EC0D

$EC0E

$EC0F
$EC10
$EC11
$EC12
$EC13

2

2
1
1

1

1
1
1
1
1

$EC14
$EC15
$EC16

1
1
735

$EEF5

1

$EEF6
$EEF7
$EEF9
$EEFA
$EEFC
$EEFE
$EF00
$EF01
$EF03
$EF05
$EF06
$EF07
$EF08
$EF09

$F4F1-$F6E9
$F6EA
$F6EC
$F6EE
$F6EF
$F6F0

$F6F1
$F6F2
$F6F3
$F6F4

$F6F5
$F6F6

$F6F8

1
1
1
2
2
2
2
1
2
1
1
1
1
1512

2
2
1
1
1

1
1
1
1

1
2

735

SPECTRUM 128 ROM 0 DISASSEMBLY

Bit 0: 1=The first row of the BASIC line.
Bit 1: 1=Spans onto next row.
Bit 2: Not used (always 0).
Bit 3: 1=The last row of the BASIC line.
Bit 4: 1=Associated line number stored.
Bit 5: Not used (always 0).
Bit 6: Not used (always 0).
Bit 7: Not used (always 0).
Data Bytes 1-2: Line number of corresponding BASIC line (stored for the first row of
the BASIC line only, holds $0000).
Flags used when listing the BASIC program:
Bit 0 : 0=Not on the current line, 1=On the current line.
Bit 1 : 0=Previously found the current line, 1=Not yet found the current line.
Bit 2 : 0=Enable display file updates, 1=Disable display file updates.
Bits 3-7: Not used (always 0).
Store for temporarily saving the value of TVFLAG.
Store for temporarily saving the value of COORDS.
Store for temporarily saving the value of P_POSN.
Store for temporarily saving the value of PR_CC.
Store for temporarily saving the value of ECHO_E.
Store for temporarily saving the value of DF_CC.
Store for temporarily saving the value of DF_CCL.
Store for temporarily saving the value of S_POSN.
Store for temporarily saving the value of SPOSNL.
Store for temporarily saving the value of SCR_CT.
Store for temporarily saving the value of ATTR_P.
Store for temporarily saving the value of MASK_P.
Store for temporarily saving the value of ATTR_T.
Used to store screen area (12 rows of 14 columns) where menu will be shown.
The rows are stored one after the other, with each row consisting of the following:
- 8 lines of 14 display file bytes.
- 14 attribute file bytes.
Not used. 505 bytes.
The jump table address for the current menu.
The text table address for the current menu.
Cursor position info - Current row number.
Cursor position info - Current column number.
Cursor position info - Preferred column number. Holds the last user selected column
position. The Editor will attempt to
place the cursor on this column when the user moves up or down to a new line.
Edit area info - Top row threshold for scrolling up.
Edit area info - Bottom row threshold for scrolling down.
Edit area info - Number of rows in the editing area.
Flags used when deleting:
Bit 0 : 1=Deleting on last row of the BASIC line, 0=Deleting on row other than the
last row of the BASIC line.
Bits 1-7: Not used (always 0).
Number of rows held in the Below-Screen Line Edit Buffer.
Intended to point to the next location to access within the Below-Screen Line Edit
Buffer, but incorrectly initialised to $0000 by the routine at $30D6 (ROM 0) and then
never used.
Below-Screen Line Edit Buffer. Holds the remainder of a BASIC line that has
overflowed off the bottom of the Screen Line Edit Buffer. It can hold 21 rows, with
each row
consisting of 32 characters followed by 3 data bytes. Areas of white space that do
not contain any editable characters (e.g. the indent that starts subsequent rows of a
BASIC line)
contain the value $00.
Data Byte 0:
Bit 0: 1=The first row of the BASIC line.
Bit 1: 1=Spans onto next row.
Bit 2: Not used (always 0).

16

SPECTRUM 128 ROM 0 DISASSEMBLY

Bit 3: 1=The last row of the BASIC line.
Bit 4: 1=Associated line number stored.
Bit 5: Not used (always 0).
Bit 6: Not used (always 0).
Bit 7: Not used (always 0).
Data Bytes 1-2: Line number of corresponding BASIC line (stored for the first row of
the BASIC line only, holds $0000).
Line number of the BASIC line in the program area being edited (or $0000 for no
line).
Number of rows held in the Above-Screen Line Edit Buffer.
Points to the next location to access within the Above-Screen Line Edit Buffer.
Above-Screen Line Edit Buffer. Holds the rows of a BASIC line that has overflowed
off the top of the Screen Line Edit Buffer.
It can hold 20 rows, with each row consisting of 32 characters followed by 3 data
bytes. Areas of white space that do not
contain any editable characters (e.g. the indent that starts subsequent rows of a
BASIC line) contain the value $00.
Data Byte 0:
Bit 0: 1=The first row of the BASIC line.
Bit 1: 1=Spans onto next row.
Bit 2: Not used (always 0).
Bit 3: 1=The last row of the BASIC line.
Bit 4: 1=Associated line number stored.
Bit 5: Not used (always 0).
Bit 6: Not used (always 0).
Bit 7: Not used (always 0).
Data Bytes 1-2: Line number of corresponding BASIC line (stored for the first row of
the BASIC line only, holds $0000).
The line number at the top of the screen, or $0000 for the first line.
$00=Print a leading space when constructing keyword.
Address of the next character to fetch within the BASIC line in the program area, or
$0000 for no next character.
Address of the next character to fetch from the Keyword Construction Buffer, or
$0000 for no next character.
Keyword Construction Buffer. Holds either a line number or keyword string
representation.
Construct a BASIC Line routine. « RAM routine - See end of file for description »
Copy String Into Keyword Construction Buffer routine. « RAM routine - See end of
file for description »
Identify Character Code of Token String routine. « RAM routine - See end of file for
description »
Flags used when shifting BASIC lines within edit buffer rows [Redundant]:
Bit 0 : 1=Set to 1 but never reset or tested. Possibly intended to indicate the start of
a new BASIC line and hence whether indentation required.
Bit 1-7: Not used (always 0).
The number of characters to indent subsequent rows of a BASIC line by.
Cursor settings (indexed by IX+$00) - initialised to $00, but never used.
Cursor settings (indexed by IX+$01) - number of rows above the editing area.
Cursor settings (indexed by IX+$02) - initialised to $00 (when using lower screen) or
$14 (when using main screen), but never subsequently used.
Cursor settings (indexed by IX+$03) - initialised to $00, but never subsequently
used.
Cursor settings (indexed by IX+$04) - initialised to $00, but never subsequently
used.
Cursor settings (indexed by IX+$05) - initialised to $00, but never subsequently
used.
Cursor settings (indexed by IX+$06) - attribute colour.
Cursor settings (indexed by IX+$07) - screen attribute where cursor is displayed.
The Keyword Conversion Buffer holding text to examine to see if it is a keyword.
Address of next available location within the Keyword Conversion Buffer.
Address of the space character between words in the Keyword Conversion Buffer.
Keyword Conversion Buffer flags, used when tokenizing a BASIC line:
Bit 0 : 1=Buffer contains characters.
Bit 1 : 1=Indicates within quotes.

17

$F9D7

$F9DB
$F9DC
$F9DE

2

1
2
700

$FC9A
$FC9E
$FC9F

$FCA1

$FCA3

$FCAE-$FCFC
$FCFD-$FD2D

$FD2E-$FD69

$FD6A

$FD6B
$FD6C
$FD6D
$FD6E

$FD6F

$FD70

$FD71

$FD72
$FD73
$FD74
$FD7D
$FD7F
$FD81

2
1
2

2

11

1

1
1
1
1

1

1

1

1
1
9
2
2
1

SPECTRUM 128 ROM 0 DISASSEMBLY

Bit 2 : 1=Indicates within a REM.
Bits 3-7: Not used (always reset to 0).
Address of the position to insert the next character within the BASIC line workspace.
The BASIC line
is created at the spare space pointed to by E_LINE.
BASIC line insertion flags, used when inserting a characters into the BASIC line
workspace:
Bit 0 : 1=The last character was a token.
Bit 1 : 1=The last character was a space.
Bits 2-7: Not used (always 0).
Count of the number of characters in the typed BASIC line being inserted.
Count of the number of characters in the tokenized version of the BASIC line being
inserted.
Holds '<' or '>' if this was the previously examined character during tokenization of a
BASIC line, else $00.
Locate Error Marker flag, holding $01 is a syntax error was detected on the BASIC
line being inserted and the equivalent position within
the typed BASIC line needs to be found with, else it holds $00 when tokenizing a
BASIC line.
Stores the stack pointer for restoration upon an insertion error into the BASIC line
workspace.
Not used. 408 bytes.
Never used. An attempt is made to set it to $EC00. This is a remnant from the
Spanish 128, which stored the address of the Screen Buffer here.
The value is written to RAM bank 0 instead of RAM bank 7, and the value never
subsequently accessed.
Not used.
Not used. On the Spanish 128 this memory holds a routine that copies a character
into the display file. The code to copy to routine into RAM,
and the routine itself are present in ROM 0 but are never executed. « RAM routine -
See end of file for description »
Not used. 159 bytes.

2

1

2
2

1

1

2

2

2

$FD82

$FD84

$FD85
$FD87

$FD89

$FD8A

$FD8B

$FD8C-$FF23
$FF24

$FF26
$FF28-$FF60

$FF61-$FFFF

Called ROM 1 Subroutines

EQU $0008
ERROR_1
EQU $0010
PRINT_A_1
EQU $0018
GET_CHAR
EQU $0020
NEXT_CHAR
EQU $0030
BC_SPACES
EQU $0095
TOKENS
EQU $03B5
BEEPER
EQU $03F8
BEEP
SA_ALL
EQU $075A
ME_CONTRL EQU $08B6
SA_CONTROL EQU $0970
EQU $09F4
PRINT_OUT
EQU $0B52
PO_T_UDG
EQU $0C0A
PO_MSG
EQU $0D4D
TEMPS
CLS
EQU $0D6B
CLS_LOWER EQU $0D6E
EQU $0DAF
CL_ALL
EQU $0E88
CL_ATTR
EQU $0E9B
CL_ADDR
EQU $0EDF
CLEAR_PRB
EQU $0F81
ADD_CHAR
EQU $107F
ED_ERROR
EQU $1097
CLEAR_SP
EQU $10A8
KEY_INPUT
EQU $10DB
KEY_M_CL
MAIN_4
EQU $1303
ERROR_MSGS EQU $1391
EQU $1537
MESSAGES

18

EQU $15C4
REPORT_J
OUT_CODE
EQU $15EF
CHAN_OPEN EQU $1601
CHAN_FLAG EQU $1615
EQU $1664
POINTERS
CLOSE
EQU $16E5
MAKE_ROOM EQU $1655
EQU $1695
LINE_NO
EQU $16B0
SET_MIN
EQU $16BF
SET_WORK
EQU $16C5
SET_STK
EQU $1736
OPEN
EQU $1822
LIST_5
EQU $18B6
NUMBER
EQU $196E
LINE_ADDR
EQU $198B
EACH_STMT
EQU $19B8
NEXT_ONE
EQU $19E5
RECLAIM
EQU $19E8
RECLAIM_2
EQU $19FB
E_LINE_NO
EQU $1A1B
OUT_NUM_1
EQU $1C1F
CLASS_01
EQU $1C56
VAL_FET_1
CLASS_04
EQU $1C6C
EXPT_2NUM EQU $1C7A
EXPT_1NUM EQU $1C82
EXPT_EXP
EQU $1C8C
EQU $1CBE
CLASS_09
FETCH_NUM EQU $1CDE
EQU $1CE6
USE_ZERO
STOP
EQU $1CEE
F_REORDER EQU $1D16
LOOK_PROG EQU $1D86
EQU $1DAB
NEXT
EQU $1E39
PASS_BY
EQU $1E42
RESTORE
EQU $1E45
REST_RUN
EQU $1E4F
RANDOMIZE
EQU $1E5F
CONTINUE
EQU $1E67
GO_TO
EQU $1E7A
COUT
POKE
EQU $1E80
EQU $1E99
FIND_INT2
TEST_ROOM EQU $1F05
EQU $1F3A
PAUSE
EQU $1FDF
PRINT_2
EQU $2048
PR_ST_END
EQU $2070
STR_ALTER
EQU $2096
INPUT_1
EQU $20C1
IN_ITEM_1
EQU $21FC
CO_TEMP_4
BORDER
EQU $2294
PIXEL_ADDR EQU $22AA
EQU $22DC
PLOT
EQU $22E5
PLOT_SUB
EQU $2320
CIRCLE
DR_3_PRMS
EQU $238D
LINE_DRAW EQU $2477
EQU $24FB
SCANNING
EQU $2530
SYNTAX_Z
EQU $28B2
LOOK_VARS
EQU $2996
STK_VAR
EQU $2BF1
STK_FETCH
EQU $2C15
D_RUN
EQU $2C8D
ALPHA
EQU $2D1B
NUMERIC
EQU $2D2B
STACK_BC

SPECTRUM 128 ROM 0 DISASSEMBLY

Should be OUT but renamed since some assemblers detect this as an instruction.

19

SPECTRUM 128 ROM 0 DISASSEMBLY

EQU $2DA2
FP_TO_BC
PRINT_FP
EQU $2DE3
HL_MULT_DE EQU $30A9
STACK_NUM EQU $33B4
EQU $34E9
TEST_ZERO
KP_SCAN
EQU $3C01
TEST_SCREEN EQU $3C04
EQU $3D00
CHAR_SET

RESTART ROUTINES — PART 1
RST $10, $18 and $20 call the equivalent subroutines in ROM 1, via RST $28.
RST $00 - Reset the machine.
RST $08 - Not used. Would have invoked the ZX Interface 1 if fitted.
RST $10 - Print a character (equivalent to RST $10 ROM 1).
RST $18 - Collect a character (equivalent to RST $18 ROM 1).
RST $20 - Collect next character (equivalent to RST $20 ROM 1).
RST $28 - Call routine in ROM 1.
RST $30 - Not used.
RST $38 - Not used.

RST $00 — Reset Machine

L0000:

L0004:

L000C:

ORG $0000
DI
LD BC,$692B
DEC BC
LD A,B
OR C
JR NZ,L0004

JP L00C7
DEFB $00, $00
DEFB $00, $00

Ensure interrupts are disabled.

Delay about 0.2s to allow screen switching mechanism to settle.

[There is no RST $08. No instruction fetch at $0008 hence ZX Interface 1 will not be
paged in from this ROM. Credit: Paul Farrow].
to the main reset routine.
[Spare bytes]

RST $10 — Print A Character

L0010:

L0014:

RST 28H
DEFW PRINT_A_1
RET
DEFB $00, $00
DEFB $00, $00

Call corresponding routine in ROM 1.
$0010.

[Spare bytes]

RST $18 — Collect A Character

L0018:

L001C:

RST 28H
DEFW GET_CHAR
RET
DEFB $00, $00
DEFB $00, $00

Call corresponding routine in ROM 1.
$0018.

[Spare bytes]

RST $20 — Collect Next Character

L0020:

L0024:

RST 28H
DEFW NEXT_CHAR
RET
DEFB $00, $00

Call corresponding routine in ROM 1.
$0020.

[Spare bytes]

20

SPECTRUM 128 ROM 0 DISASSEMBLY

DEFB $00, $00

RST $28 — Call Routine in ROM 1
RST 28 calls a routine in ROM 1 (or alternatively a routine in RAM while ROM 1 is paged in). Call as follows: RST 28 / DEFW address.

L0028:

L0037:

EX (SP),HL
PUSH AF
LD A,(HL)
INC HL
INC HL
LD (RETADDR),HL
DEC HL
LD H,(HL)
LD L,A
POP AF
JP L005C
DEFB $00

Get the address after the RST $28 into HL, saving HL on the stack.
Save the AF registers.
Fetch the first address byte.
Point HL to the byte after
the required address.
$5B5A. Store this in RETADDR.
(There is no RST $30)
Fetch the second address byte.
HL=Subroutine to call.
Restore AF.
Jump ahead to continue.
[Spare byte]

MASKABLE INTERRUPT ROUTINE
This routine preserves the HL register pair. It then performs the following: - Execute the ROM switching code held in RAM to switch to ROM 1.
- Execute the maskable interrupt routine in ROM 1.
- Execute the ROM switching code held in RAM to return to ROM 0.
- Return to address $0048 (ROM 0).

L0038:

L0048:

PUSH HL
LD HL,L0048
PUSH HL
LD HL,SWAP
PUSH HL
LD HL,L0038
PUSH HL
JP SWAP
POP HL
RET

Save HL register pair.
Return address of $0048 (ROM 0).

$5B00. Address of swap ROM routine held in RAM at $5B00.

Maskable interrupt routine address $0038 (ROM 0).

$5B00. Switch to other ROM (ROM 1) via routine held in RAM at $5B00.
Restore the HL register pair.
End of interrupt routine.

ERROR HANDLER ROUTINES — PART 1

128K Error Routine

L004A:

LD BC,$7FFD
XOR A
DI
OUT (C),A
LD (BANK_M),A
EI
DEC A
LD (IY+$00),A
JP L0321

ROM 0, Bank 0, Screen 0, 128K mode.
Ensure interrupts are disabled whilst paging.

$5B5C. Note the new paging status.
Re-enable interrupts.
A=$FF.
Set ERR_NR to no error ($FF).
Jump ahead to continue.

RESTART ROUTINES — PART 2

Call ROM 1 Routine (RST $28 Continuation)
Continuation from routine at $0028 (ROM 0).

L005C:

LD (TARGET),HL

$5B58. Save the address in ROM 0 to call.

21

SPECTRUM 128 ROM 0 DISASSEMBLY

LD HL,YOUNGER
EX (SP),HL
PUSH HL
LD HL,(TARGET)
EX (SP),HL
JP SWAP

$5B14. HL='Return to ROM 0' routine held in RAM.
Stack HL.
Save previous stack address.
$5B58. HL=Retrieve address to call. [There is no NMI code. Credit: Andrew Owen].
Stack HL.
$5B00. Switch to other ROM (ROM 1) and return to address to call.

RAM ROUTINES
The following code will be copied to locations $5B00 to $5B57, within the old ZX Printer buffer.

Swap to Other ROM (copied to $5B00)
Switch to the other ROM from that currently paged in.
[The switching between the two ROMs invariably enables interrupts, which may not always be desired (see the bug at $09CD (ROM 0) in the PLAY
command). To overcome this issue would require a rewrite of the SWAP routine as follows, but this is larger than the existing routine and so cannot
simply be used in direct replacement of it. A work-around solution is to poke a JP instruction at the start of the SWAP routine in the ZX Printer buffer and
direct control to the replacement routine held somewhere else in RAM. Credit: Toni Baker, ZX Computing Monthly] [However, the PLAY commnad bug
may be fixed in another manner within the PLAY command itself, in which case there is no need to modify the SWAP routine.]

SWAP:

SWAP_EXIT:

L006B:

PUSH AF
PUSH BC
LD A,R
PUSH AF
LD BC,$7FFD
LD A,(BANK_M)
XOR $10
DI
LD (BANK_M),A
OUT (C),A
POP AF
JP PO,SWAP_EXIT
EI

POP BC
POP AF
RET

PUSH AF
PUSH BC
LD BC,$7FFD
LD A,(BANK_M)
XOR $10
DI
LD (BANK_M),A
OUT (C),A
EI
POP BC
POP AF
RET

Stack AF.
Stack BC.
P/V flag=Interrupt status.
Stack interrupt status.
BC=Port number required for paging.
A=Current paging configuration.
Complement 'ROM' bit.
Disable interrupts (in case an interrupt occurs between the next two instructions).
Store revised paging configuration.
Page ROM.
P/V flag=Former interrupt status.
Jump if interrupts were previously disabled.
Re-enable interrupts.

Restore BC.
Restore AF.

Save AF and BC.

$5B5C.
Select other ROM.
Disable interrupts whilst switching ROMs.
$5B5C.
Switch to the other ROM.

Restore BC and AF.

Return to Other ROM Routine (copied to $5B14)
Switch to the other ROM from that currently paged in
and then return to the address held in RETADDR.
YOUNGER

L007F:

CALL SWAP
PUSH HL
LD HL,(RETADDR)
EX (SP),HL

$5B00. Toggle to the other ROM.

$5B5A.

22

SPECTRUM 128 ROM 0 DISASSEMBLY

RET

Return to the address held in RETADDR.

Error Handler Routine (copied to $5B1D)
This error handler routine switches back to ROM 0 and then
executes the routine pointed to by system variable TARGET.
ONERR

L0088:

DI
LD A,(BANK_M)
AND $EF
LD (BANK_M),A
LD BC,$7FFD
OUT (C),A
EI
JP L00C3

Ensure interrupts are disabled whilst paging.
$5B5C. Fetch current paging configuration.
Select ROM 0.
$5B5C. Save the new configuration

Switch to ROM 0.

Jump to $00C3 (ROM 0) to continue.

'P' Channel Input Routine (copied to $5B2F)
Called when data is read from channel 'P'.
It causes ROM 0 to be paged in so that the new RS232 routines can be accessed.
PIN

L009A:

LD HL,L06D8
JR L00A2

RS232 input routine within ROM 0.

'P' Channel Output Routine (copied to $5B34)
Called when data is written to channel 'P'.
It causes ROM 0 to be paged in so that the new RS232 routines can be accessed.
Entry:

A=Byte to send.

POUT

L009F:
L00A2:

LD HL,L07CA
EX AF,AF'
LD BC,$7FFD
LD A,(BANK_M)
PUSH AF
AND $EF
DI
LD (BANK_M),A
OUT (C),A
JP L05E6

RS232 output routine within ROM 0.
Save AF registers.

$5B5C. Fetch the current paging configuration
and save it.
Select ROM 0.
Ensure interrupts are disabled whilst paging.
$5B5C. Store the new paging configuration.
Switch to ROM 0.
Jump to the RS232 channel input/output handler routine.

'P' Channel Exit Routine (copied to $5B4A)
Used when returning from a channel 'P' read or write operation.
It causes the original ROM to be paged back in and returns back to the calling routine.
POUT2

L00B5:

EX AF,AF'

POP AF
LD BC,$7FFD
DI
LD (BANK_M),A
OUT (C),A
EI
EX AF,AF'

RET

Save AF registers. For a read, A holds the byte read and the flags the success
status.
Retrieve original paging configuration.

Ensure interrupts are disabled whilst paging.
$5B5C. Store original paging configuration.
Switch back to original paging configuration.

Restore AF registers. For a read, A holds the byte read and the flags the success
status.
« End of RAM Routines »

23

SPECTRUM 128 ROM 0 DISASSEMBLY

ERROR HANDLER ROUTINES — PART 2

Call Subroutine
Called from ONERR ($5B1D) to execute the routine pointed
to by system variable SYNRET.

L00C3:

LD HL,(SYNRET)
JP (HL)

$5B8B. Fetch the address to call.
and execute it.

INITIALISATION ROUTINES — PART 1

Reset Routine (RST $00 Continuation, Part 1)
Continuation from routine at $0000 (ROM 0). It performs a test on all RAM banks.
This test is crude and can fail to detect a variety of RAM errors.

L00C7:
L00C9:

LD B,$08
LD A,B
EXX
DEC A
LD BC,$7FFD
OUT (C),A
LD HL,$C000
LD DE,$C001
LD BC,$3FFF
LD A,$FF
LD (HL),A
CP (HL)
JR NZ,L0131
XOR A
LD (HL),A
CP (HL)
JR NZ,L0131
LDIR
EXX
DJNZ L00C9
LD (ROW01),A
LD C,$FD
LD D,$FF
LD E,$BF
LD B,D
LD A,$0E
OUT (C),A
LD B,E
LD A,$FF
OUT (C),A

L00FF:

JR L0137
DEFB $00

ROUTINE VECTOR TABLE

L0100:
L0103:
L0106:
L0109:
L010C:
L010F:

JP L17AF
JP L1838
JP L1ECF
JP L1F04
JP L004A
JP L03A2

Loop through all RAM banks.

Save B register.
RAM bank number 0 to 7. 128K mode, ROM 0, Screen 0.

Switch RAM bank.
Start of the current RAM bank.

All 16K of RAM bank.

Store $FF into RAM location.
Check RAM integrity.
Jump if RAM error found.

Store $00 into RAM location.
Check RAM integrity.
Jump if difference found.
Clear the whole page
Restore B registers.
Repeat for other RAM banks.
$5B88. Signal no communications in progress to the keypad.

BC=$FFFD, DE=$FFBF.

Select AY register 14.
BC=$BFFD.

Set AY register 14 to $FF. This will force a communications reset to the keypad if
present.
Jump ahead to continue.
[Spare byte]

BASIC interpreter parser.
'Line Run' entry point.
Transfer bytes to logical RAM bank 4.
Transfer bytes from logical RAM bank 4.
128K error routine.
Error routine. Called from patch at $3B3B in ROM 1.

24

L0112:
L0115:
L0118:
L011B:
L011E:
L0121:
L0124:
L0127:
L012A:
L012D:

JP L182A
JP L18A8
JP L012D
JP L0A05
JP L11A3
JP L06D8
JP L07CA
JP L08A3
JP L08F0
RST 28H
DEFW KP_SCAN-$0100

RET

SPECTRUM 128 ROM 0 DISASSEMBLY

'Statement Return' routine. Called from patch at $3B4D in ROM 1.
'Statement Next' routine. Called from patch at $3B5D in ROM 1.
Scan the keypad.
Play music strings.
MIDI byte output routine.
RS232 byte input routine.
RS232 text output routine.
RS232 byte output routine.
COPY (screen dump) routine.
Call keypad scan routine in ROM 1.
$3B01. [BUG - The address jumps into the middle of the keypad decode routine in
ROM 1. It
looks like it is supposed to deal with the keypad and so the most likely addresses
are $3A42 (read keypad) or $39A0 (scan keypad). At $3C01 in ROM 1 is a vector
jump command to $39A0 to scan the keypad and this is similar enough to the $3B01
to imply a simple error in one of the bytes. Credit: Paul Farrow]

INITIALISATION ROUTINES — PART 2

Fatal RAM Error
Set the border colour to indicate which RAM bank was found faulty: RAM bank 7 - Black.
RAM bank 6 - White.
RAM bank 5 - Yellow.
RAM bank 4 - Cyan.
RAM bank 3 - Green.
RAM bank 2 - Magenta.
RAM bank 1 - Red.
RAM bank 0 - Blue.

L0131:

L0135:

EXX
LD A,B
OUT ($FE),A
JR L0135

Retrieve RAM bank number + 1 in B.
Indicate which RAM bank failed by
setting the border colour.
Infinite loop.

Reset Routine (RST $00 Continuation, Part 2)
Continuation from routine at $00C7 (ROM 0).

L0137:

LD B,D
LD A,$07
OUT (C),A
LD B,E
LD A,$FF
OUT (C),A
LD DE,SWAP
LD HL,L006B
LD BC,$0058
LDIR
LD A,$CF
LD (RAMRST),A
LD SP,TSTACK
LD A,$04
CALL L1C64
LD IX,$EBEC
LD (SFNEXT),IX
LD (IX+$0A),$00
LD (IX+$0B),$C0
LD (IX+$0C),$00
LD HL,$2BEC
LD A,$01
LD (SFSPACE),HL
LD (SFSPACE+2),A

Complete setting up the sound chip registers.

Select AY register 7.

Disable AY-3-8912 sound channels.

$5B00. Copy the various paging routines to the old printer buffer.
The source is in this ROM.
There are eighty eight bytes to copy.
Copy the block of bytes.
Load A with the code for the Z80 instruction 'RST $08'.
$5B5D. Insert into new System Variable RAMRST.
$5BFF. Set the stack pointer to last location of old buffer.

Page in logical RAM bank 4 (physical RAM bank 7).
First free entry in RAM disk.
$5B83.

AHL=Free space in RAM disk.
$5B85. Current address.
$5B87. Current RAM bank.

25

LD A,$05
CALL L1C64
LD HL,$FFFF
LD ($5CB4),HL
LD DE,CHAR_SET+$01AF
LD BC,$00A8
EX DE,HL
RST 28H
DEFW MAKE_ROOM+$000C

EX DE,HL
INC HL
LD ($5C7B),HL
DEC HL
LD BC,$0040
LD ($5C38),BC
LD ($5CB2),HL

SPECTRUM 128 ROM 0 DISASSEMBLY

Page in logical RAM bank 5 (physical RAM bank 0).
Load HL with known last working byte - 65535.
P_RAMT. Set physical RAM top to 65535.
$3EAF. Set DE to address of the last bitmap of 'U' in ROM 1.
There are 21 User Defined Graphics to copy.
Swap so destination is $FFFF.

Calling this address (LDDR/RET) in the main ROM cleverly copies the 21 characters
to the end of RAM.
Transfer DE to HL.
Increment to address first byte of UDG 'A'.
UDG. Update standard System Variable UDG.

Set values 0 for PIP and 64 for RASP.
RASP. Update standard System Variables RASP and PIP.
RAMTOP. Update standard System Variable RAMTOP - the last byte of the BASIC
system area. Any machine code and graphics above this address are protected from
NEW.

Entry point for NEW with interrupts disabled and physical RAM bank 0 occupying the upper RAM region $C000 - $FFFF, i.e. the normal BASIC memory
configuration.

L019D:

LD HL,CHAR_SET-$0100
LD ($5C36),HL
LD HL,($5CB2)
INC HL
LD SP,HL
IM 1
LD IY,$5C3A

SET 4,(IY+$01)

EI
LD HL,$000B
LD (BAUD),HL
XOR A
LD (SERFL),A
LD (COL),A
LD (TVPARS),A
LD HL,$EC00

LD ($FF24),HL

LD A,$50
LD (WIDTH),A
LD HL,$000A
LD (RNFIRST),HL
LD (RNSTEP),HL
LD HL,$5CB6
LD ($5C4F),HL
LD DE,L0589

LD BC,$0015
EX DE,HL
LDIR
EX DE,HL
DEC HL
LD ($5C57),HL

$3C00. Set HL to where, in theory character zero would be.
CHARS. Update standard System Variable CHARS.
RAMTOP. Load HL with value of System Variable RAMTOP.
Address next location.
Set the Stack Pointer.
Select Interrupt Mode 1.
Set the IY register to address the standard System Variables and many of the new
System Variables and even those of ZX Interface 1 in some cases.
FLAGS. Signal 128K mode. [This bit was unused and therefore never set by 48K
BASIC]
With a stack and the IY register set, interrupts can be enabled.
Set HL to eleven, timing constant for 9600 baud.
$5B5F. Select default RS232 baud rate of 9600 baud.
Clear accumulator.
$5B61. Indicate no byte waiting in RS232 receive buffer.
$5B63. Set RS232 output column position to 0.
$5B65. Indicate no control code parameters expected.
[BUG - Should write to RAM bank 7. Main RAM has now been corrupted. The value
stored is subsequently never used. Credit: Geoff Wearmouth]
This is a remnant from the Spanish 128, which used this workspace variable to hold
the location of the Screen Buffer, but it also suffered from this bug. In fact there was
never a need to write to the value at this point since it is written again later during the
initialisation process. [The 1985 Sinclair Research ESPAGNOL source code says
that this instruction will write to the (previously cleared) main BASIC RAM during
initialization but that a different page of RAM will be present during NEW. Stuff and
Nonsense! Assemblers and other utilities present above RAMTOP will be corrupted
by the BASIC NEW command since $FF24, and later $EC13, will be written to even
if they are above RAMTOP.]
Default to a printer width of 80 columns.
$5B64. Set RS232 printer output width.
Use 10 as the initial renumber line and increment.
$5B94. Store the initial line number when renumbering.
$5B96. Store the renumber line increment.
Address after the System Variables.
CHANS. Set the default location for the channel area.
Point to Initial Channel Information in this ROM. This is similar to that in main ROM
but channel 'P' has input and output addresses in the new $5Bxx region.
There are 21 bytes to copy.
Switch pointer so destination is CHANS.
Copy the block of bytes.

Decrement to point to channel information end-marker.
DATADD. Set the default address of the terminator for the last DATA item.

26

INC HL
LD ($5C53),HL
LD ($5C4B),HL
LD (HL),$80
INC HL
LD ($5C59),HL
LD (HL),$0D
INC HL
LD (HL),$80
INC HL
LD ($5C61),HL
LD ($5C63),HL
LD ($5C65),HL
LD A,$38
LD ($5C8D),A
LD ($5C8F),A
LD ($5C48),A
XOR A
LD ($EC13),A

LD A,$07
OUT ($FE),A
LD HL,$0523
LD ($5C09),HL
DEC (IY-$3A)
DEC (IY-$36)
LD HL,L059E

LD DE,$5C10

SPECTRUM 128 ROM 0 DISASSEMBLY

PROG. Set the default address of the BASIC program area.
VARS. Set the default address of the BASIC variables area.
Insert the Variables end-marker.

E_LINE. Set the default address of the editing line area.
Insert a carriage return.

Insert the editing line end-marker.

WORKSP. Set the address of the workspace.
STKBOT. Set the address of the start of the calculator stack.
STKEND. Set the address of the end of the calculator stack.
Attribute colour of black ink on white paper.
ATTR_P. Set the permanent attribute colour.
MASK_P. Set the permanent attribute mask.
BORDCR. Set the default border colour.

Temporary P_FLAG. Clear the temporary store for P-FLAG. [BUG - Should write this
to RAM bank 7. Main RAM has now been corrupted again. The effect of the bug can
be seen by typing INVERSE 1: PRINT "Hello", followed by NEW, followed by PRINT
"World", and will cause the second word to also be printed in inverse. Credit: Geoff
Wearmouth]

Set the border white.
The values five and thirty five.
REPDEL. Set the default values for key delay and key repeat.
Set KSTATE+0 to $FF.
Set KSTATE+4 to $FF.
Address of the Initial Stream Data within this ROM (which is identical to that in main
ROM).
STRMS. Address of the system variable holding the channels attached to streams
data.

LD BC,$000E
LDIR
RES 1,(IY+$01)
LD (IY+$00),$FF
LD (IY+$31),$02
RST 28H
DEFW CLS
RST 28H
DEFW TEST_SCREEN
LD DE,L0561
CALL L057D
LD (IY+$31),$02
SET 5,(IY+$02)
LD HL,TSTACK
LD (OLDSP),HL
CALL L1F45
LD A,$38
LD ($EC11),A
LD ($EC0F),A

Initialise the streams system variables.
FLAGS. Signal printer not is use.
ERR_NR. Signal no error.
DF_SZ. Set the lower screen size to two rows.

$0D6B. Clear the screen.
Attempt to display TV tuning test screen.
$3C04. Will return if BREAK is not being pressed.
Address of the Sinclair copyright message.
Display the copyright message.
DF_SZ. Set the lower screen size to two rows.
TV_FLAG. Signal lower screen will require clearing.
$5BFF.
$5B81. Use the temporary stack as the previous stack.
Use Workspace RAM configuration (physical RAM bank 7).
Set colours to black ink on white paper.
Temporary ATTR_T used by the 128 BASIC Editor.
Temporary ATTR_P used by the 128 BASIC Editor.

[Note this is where $EC13 (temporary P_FLAG) and $FF24 should be set]

CALL L2584
CALL L1F20
JP L259F

Initialise mode and cursor settings. IX will point at editing settings information.
Use Normal RAM Configuration (physical RAM bank 0).
Jump to show the Main menu.

COMMAND EXECUTION ROUTINES — PART 1

Execute Command Line
A typed in command resides in the editing workspace. Execute it.

27

The command could either be a new line to insert, or a line number to delete, or a numerical expression to evaluate.

SPECTRUM 128 ROM 0 DISASSEMBLY

L026B:

LD HL,FLAGS3
SET 0,(HL)
LD (IY+$00),$FF
LD (IY+$31),$02
LD HL,ONERR
PUSH HL
LD ($5C3D),SP
LD HL,L02BA
LD (SYNRET),HL
CALL L228E
CALL L22CB
JP Z,L21F8
CP '('
JP Z,L21F8
CP '-'
JP Z,L21F8
CP '+'
JP Z,L21F8
CALL L22E0
JP Z,L21F8
CALL L1F45
LD A,($EC0E)
CALL L1F20
CP $04
JP NZ,L17AF

$5B66.
Select BASIC/Calculator mode.
ERR_NR. Set to '0 OK' status.
DF_SZ. Reset the number of rows in the lower screen.
$5B1D. Return address should an error occur.
Stack it.
Save the stack pointer in ERR_SP.
Return address in ROM 0 after syntax checking.
$5B8B. Store it in SYNRET.
Point to start of typed in BASIC command.
Is the first character a function token, i.e. the start of a numerical expression?
Jump if so to evaluate it.
$28. Is the first character the start of an expression?
Jump if so to evaluate it.
$2D. Is the first character the start of an expression?
Jump if so to evaluate it.
$2B. Is the first character the start of an expression?
Jump if so to evaluate it.
Is text just a number or a numerical expression?
Jump if a numerical expression to evaluate it.
Use Workspace RAM configuration (physical RAM bank 7).
Fetch mode.
Use Normal RAM Configuration (physical RAM bank 0).
Calculator mode?
Jump if not to parse and execute the BASIC command line, returning to $02BA
(ROM 0).

Calculator mode

CALL L2297
JP Z,L17AF

Is it a single LET command?
Jump if so to parse and execute the BASIC command line, returning to $02BA (ROM
0).

Otherwise ignore the command

POP HL
RET

Drop ONERR return address.

Return from BASIC Line Syntax Check
This routine is returned to when a BASIC line has been syntax checked.

L02BA:

BIT 7,(IY+$00)
JR NZ,L02C1
RET

Test ERR_NR.
Jump ahead if no error.
Simply return if an error.

The syntax check was successful, so now proceed to parse the line for insertion or execution

L02C1:

LD HL,($5C59)
LD ($5C5D),HL
RST 28H
DEFW E_LINE_NO
LD A,B
OR C
JP NZ,L03F7

ELINE. Point to start of editing area.
Store in CH_ADD.

$19FB. Call E_LINE_NO in ROM 1 to read the line number into editing area.

Jump ahead if there was a line number.

Parse a BASIC Line with No Line Number

RST 18H
CP $0D

Get character.
End of the line reached, i.e. no BASIC statement?

28

L02DF:

L02F4:

RET Z
CALL L21EF
BIT 6,(IY+$02)
JR NZ,L02DF
RST 28H
DEFW CLS_LOWER
RES 6,(IY+$02)
CALL L1F45
LD HL,$EC0D
BIT 6,(HL)
JR NZ,L02F4
INC HL
LD A,(HL)
CP $00
CALL Z,L3881
CALL L1F20
LD HL,$5C3C
RES 3,(HL)
LD A,$19
SUB (IY+$4F)
LD ($5C8C),A
SET 7,(IY+$01)
LD (IY+$0A),$01

SPECTRUM 128 ROM 0 DISASSEMBLY

Return if so.
Clear screen if it requires it.
TVFLAG. Clear lower screen?
Jump ahead if no need to clear lower screen.

$0D6E. Clear the lower screen.
TVFLAG. Signal to clear lower screen.
Use Workspace RAM configuration (physical RAM bank 7).
Editor flags.
Using lower screen area for editing?
Jump ahead if so.

Fetch the mode.
In Edit Menu mode?
If so then clear lower editing area display.
Use Normal RAM Configuration (physical RAM bank 0).
TVFLAG.
Signal mode has not changed.
25.
S_POSN+1. Subtract the current print row position.
SCR_CT. Set the number of scrolls.
FLAGS. Not syntax checking.
NSPPC. Set line to be jumped to as line 1.

[BUG - Whenever a typed in command is executed directly from the editing workspace, a new GO SUB marker is set up on the stack. Any existing GO
SUB calls that were on the stack are lost and as a result attempting to continue the program (without the use of CLEAR or RUN) will likely lead to a "7
RETURN without GOSUB" error report message being displayed. However, the stack marker will already have been lost due to the error handler routine
at $0321. The first action it does is to reset the stack pointer to point to the location of RAMTOP, i.e. after the GO SUB marker. This is why it is necessary
for a new GO SUB marker needs to be set up. Credit: Michal Skrzypek]

LD HL,$3E00
PUSH HL
LD HL,ONERR
PUSH HL
LD ($5C3D),SP
LD HL,L0321
LD (SYNRET),HL
JP L1838

The end of GO SUB stack marker.
Place it on the stack.
$5B1D. The return address should an error occur.
Place it on the stack.
ERR_SP. Store error routine address.
Address of error handler routine in ROM 0.
$5B8B. Store it in SYNRET.
Jump ahead to the main parser routine to execute the line.

ERROR HANDLER ROUTINES — PART 3

Error Handler Routine
[BUG - Upon terminating a BASIC program, either via reaching the end of the program or due to an error occurring, execution is passed to this routine.
The first action it does is to reset the stack pointer to point to the location of RAMTOP, i.e. after the GO SUB marker. However, this means that any
existing GO SUB calls that were on the stack are lost and so attempting to continue the program (without the use of CLEAR or RUN) will likely lead to
a "7 RETURN without GOSUB" error report message being displayed. When a new typed in command is executed, the code at $030C sets up a new
GO SUB marker on the stack. Credit: Michal Skrzypek]

L0321:

LD SP,($5CB2)
INC SP
LD HL,TSTACK
LD (OLDSP),HL
HALT
RES 5,(IY+$01)
LD HL,FLAGS3
BIT 2,(HL)
JR Z,L034A
CALL L1F45
LD IX,(SFNEXT)
LD BC,$0014
ADD IX,BC
CALL L1D56
CALL L1F20

RAMTOP.
Reset SP to top of memory map.
$5BFF.
$5B81. Use the temporary stack as the previous stack.
Trap error conditions where interrupts are disabled.
FLAGS. Signal no new key.
$5B66.
Editing RAM disk catalogue?
Jump if not.
Use Workspace RAM configuration (physical RAM bank 7).
$5B83.
Catalogue entry size.
Remove last entry.
Update catalogue entry (leaves logical RAM bank 4 paged in).
Use Normal RAM Configuration (physical RAM bank 0).

29

Display error code held in ERR_NR

SPECTRUM 128 ROM 0 DISASSEMBLY

L034A:

L034E:

L037D:
L037F:

LD A,($5C3A)
INC A
PUSH AF
LD HL,$0000
LD (IY+$37),H
LD (IY+$26),H
LD ($5C0B),HL
LD HL,$0001
LD ($5C16),HL
RST 28H
DEFW SET_MIN
RES 5,(IY+$37)
RST 28H
DEFW CLS_LOWER
SET 5,(IY+$02)
POP AF
LD B,A
CP $0A
JR C,L037F
CP $1D
JR C,L037D
ADD A,$14
JR L037F

ADD A,$07
RST 28H
DEFW OUT_CODE
LD A,$20
RST 10H
LD A,B
CP $1D
JR C,L039C

Fetch error number from ERR_NR.
Increment to give true error code.
Save the error code.

FLAGX. Ensure not INPUT mode.
X_PTR_hi. Clear to suppress error '?' marker.
DEFADD. Clear to signal no defined function is currently being evaluated.
[Could have saved 2 bytes by using INC L].
STRMS+$0006. Ensure STRMS-00 specifies the keyboard.

$16B0. Clears editing area and areas after it.
FLAGX. Signal not INPUT mode. [Redundant since all flags were reset earlier]

$0D6E. Clear lower editing screen.
TVFLAG. Signal lower screen requires clearing.
Retrieve error code.
Store error code in B.
Is it a numeric error code (1-9), i.e. suitable for immediate display?
If so jump ahead to display it.
Is it one of the standard errors (A-R)?
If so jump ahead to convert it into an upper case letter.
Otherwise convert it into a lower case letter.
Jump ahead to display it. [Could have saved 2 bytes by using ADD A,$0C instead of
these two instructions]
Increase code to point to upper case letters.

$15EF. Display the character held in the A register.
Display a space.

Retrieve the error code.
Is it one of the standard errors (A-R)?
Jump if an standard error message (A-R).

Display a new error message
[Note that there is no test to range check the error code value and therefore whether a message exists for it. Poking directly to system variable ERR_NR
with an invalid code (43 or above) will more than likely cause a crash]

SUB $1D
LD B,$00
LD C,A
LD HL,L046C
ADD HL,BC
ADD HL,BC
LD E,(HL)
INC HL
LD D,(HL)
CALL L057D
JR L03A2

A=Code $00 - $0E.

Pass code to BC.
Error message vector table.

Find address in error message vector table.

DE=Address of message to print.
Print error message.
Jump ahead.

Display a standard error message.

L039C:

LD DE,ERROR_MSGS
RST 28H
DEFW PO_MSG

$1391. Position of the error messages in ROM 1.
A holds the error code.
$0C0A. Call message printing routine.

Continue to display the line and statement number

L03A2:

XOR A
LD DE,MESSAGES-1
RST 28H
DEFW PO_MSG
LD BC,($5C45)
RST 28H

Select the first message ", " (a 'comma' and a 'space').
$1536. Message base address in ROM 1.

Print a comma followed by a space.
PPC. Fetch current line number.

30

DEFW OUT_NUM_1
LD A,$3A
RST 10H
LD C,(IY+$0D)
LD B,$00
RST 28H
DEFW OUT_NUM_1
RST 28H
DEFW CLEAR_SP
LD A,($5C3A)
INC A
JR Z,L03DF
CP $09
JR Z,L03CC
CP $15
JR NZ,L03CF
INC (IY+$0D)
LD BC,$0003
LD DE,$5C70
LD HL,$5C44
BIT 7,(HL)
JR Z,L03DD
ADD HL,BC
LDDR
LD (IY+$0A),$FF
RES 3,(IY+$01)
LD HL,FLAGS3
RES 0,(HL)
JP L25CB

L03CC:
L03CF:

L03DD:
L03DF:

SPECTRUM 128 ROM 0 DISASSEMBLY

$1A1B. Print the line number.
Print ':'.

SUBPPC. Fetch current statement number.

$1A1B. Print the statement number.

$1097. Clear editing and workspace areas.
ERR_NR. Fetch the error code.

Jump ahead for "0 OK".

Jump for "A Invalid argument", thereby advancing to the next statement.

Jump unless "M Ramtop no good".
SUBPPC. Advance to the next statement.

OSPPC. Continue statement number.
NSPPC. Next statement number.
Is there a statement number?
Jump if so.
HL=SUBPPC. The current statement number.
Copy SUBPPC and PPC to OSPPC and OLDPPC, for use by CONTINUE.
NSPPC. Signal no current statement number.
FLAGS. Select K-Mode.
$5B66.
Select 128 Editor mode.
Jump ahead to return control to the Editor.

Error Handler Routine When Parsing BASIC Line

L03EF:

LD A,$10
LD BC,$0000
JP L034E

Error code 'G - No room for line'.

Jump to print the error code.

COMMAND EXECUTION ROUTINES — PART 2

Parse a BASIC Line with a Line Number
This routine handles insertion of a BASIC line specified with a line number, or just a line number specified on its own, i.e. delete the line.

L03F7:

L040A:

LD ($5C49),BC
CALL L1F45
LD A,B

OR C
JR Z,L040A
LD ($5C49),BC

LD ($EC08),BC
CALL L1F20
LD HL,($5C5D)
EX DE,HL
LD HL,L03EF
PUSH HL
LD HL,($5C61)
SCF
SBC HL,DE
PUSH HL
LD H,B
LD L,C

E_PPC. Store the line as the current line number with the program cursor.
Use Workspace RAM configuration (physical RAM bank 7).
[This test could have been performed before paging in bank 7 and hence could have
benefited from a slight speed improvement.
The test is redundant since BC holds a non-zero line number]
Jump if no line number.
E_PPC. Current edit line number. [Redundant instruction - Line number has already
been stored]
Temporary E_PPC used by BASIC Editor.
Use Normal RAM Configuration (physical RAM bank 0).
CH_ADD. Point to the next character in the BASIC line.

Address of error handler routine should there be no room for the line.
Stack it.
WORKSP.

HL=Length of BASIC line.
Stack it.

Transfer edit line number to HL.

31

SPECTRUM 128 ROM 0 DISASSEMBLY

RST 28H
DEFW LINE_ADDR
JR NZ,L0429

$196E. Returns address of the line in HL.
Jump if the line does not exist.

The line already exists so delete it

L0429:

RST 28H
DEFW NEXT_ONE
RST 28H
DEFW RECLAIM_2
POP BC
LD A,C
DEC A
OR B
JR NZ,L0442

$19B8. Find the address of the next line.

$19E8. Delete the line.
BC=Length of the BASIC line.

Is it 1, i.e. just an 'Enter' character, and hence only
a line number was entered?
Jump if there is a BASIC statement.

Just a line number entered. The requested line has already been deleted so move the program cursor to the next line

CALL L1F45
PUSH HL
LD HL,($5C49)
CALL L334A
LD ($5C49),HL
POP HL
CALL L1F20
JR L046A
PUSH BC
INC BC
INC BC
INC BC
INC BC
DEC HL
LD DE,($5C53)
PUSH DE
RST 28H
DEFW MAKE_ROOM
POP HL
LD ($5C53),HL
POP BC
PUSH BC
INC DE
LD HL,($5C61)
DEC HL
DEC HL
LDDR
LD HL,($5C49)
EX DE,HL
POP BC
LD (HL),B
DEC HL
LD (HL),C
DEC HL
LD (HL),E
DEC HL
LD (HL),D
POP AF
RET

L0442:

L046A:

Use Workspace RAM configuration (physical RAM bank 7).
Save the address of the line.
E_PPC. Fetch current edit line number.
Find closest line number (or $0000 if no line).
E_PPC. Store current edit line number. Effectively refresh E_PPC.
HL=Address of the line.
Use Normal RAM Configuration (physical RAM bank 0).
Jump ahead to exit.
BC=Length of the BASIC line. Stack it.

BC=BC+4. Allow for line number and length bytes.
Point to before the current line, i.e. the location to insert bytes at.
PROG. Get start address of the BASIC program.
Stack it.

$1655. Insert BC spaces at address HL.
HL=Start address of BASIC program.
PROG. Save start address of BASIC program.
BC=Length of the BASIC line.

Point to the first location of the newly created space.
WORKSP. Address of end of the BASIC line in the workspace.

Skip over the newline and terminator bytes.
Copy the BASIC line from the workspace into the program area.
E_PPC. Current edit line number.

BC=Length of BASIC line.
Store the line length.

DE=line number.

Store the line number.
Drop item (address of error handler routine).
Exit with HL=Address of the line.

ERROR HANDLER ROUTINES — PART 4

New Error Message Vector Table
Pointers into the new error message table.

32

L046C:

DEFW L048C
DEFW L0497
DEFW L04A6
DEFW L04B0
DEFW L04C1
DEFW L04D4
DEFW L04E0
DEFW L04E0
DEFW L04F3
DEFW L0501
DEFW L0512
DEFW L0523
DEFW L0531
DEFW L0542
DEFW L054E
DEFW L0561

New Error Message Table

L048C:

L0497:

L04A6:

L04B0:

L04C1:

L04D4:

L04E0:

L04F3:

L0501:

L0512:

L0523:

L0531:

L0542:

L054E:

L0561:

DEFM "MERGE erro"
DEFB 'r'+$80
DEFM "Wrong file typ"
DEFB 'e'+$80
DEFM "CODE erro"
DEFB 'r'+$80
DEFM "Too many bracket"
DEFB 's'+$80
DEFM "File already exist"
DEFB 's'+$80
DEFM "Invalid nam"
DEFB 'e'+$80
DEFM "File does not exis"
DEFB 't'+$80
DEFM "Invalid devic"
DEFB 'e'+$80
DEFM "Invalid baud rat"
DEFB 'e'+$80
DEFM "Invalid note nam"
DEFB 'e'+$80
DEFM "Number too bi"
DEFB 'g'+$80
DEFM "Note out of rang"
DEFB 'e'+$80
DEFM "Out of rang"
DEFB 'e'+$80
DEFM "Too many tied note"
DEFB 's'+$80
DEFB $7F
DEFM " 1986 Sinclair Research
Lt"
DEFB 'd'+$80

SPECTRUM 128 ROM 0 DISASSEMBLY

Error report 'a'.
Error report 'b'.
Error report 'c'.
Error report 'd'.
Error report 'e'.
Error report 'f'.
Error report 'g'.
Error report 'h'.
Error report 'i'.
Error report 'j'.
Error report 'k'.
Error report 'l'
Error report 'm'.
Error report 'n'.
Error report 'o'.
Error report 'p'.

Report 'a'.

Report 'b'.

Report 'c'.

Report 'd'.

Report 'e'.

Report 'f'.

Report 'g' & 'h'.

Report 'i'.

Report 'j'.

Report 'k'.

Report 'l'.

Report 'm'.

Report 'n'.

Report 'o'.

'(c)'.
Copyright. [There should have been an error report "p Bad parameterr" here as
there was in the Spanish 128,
or the error code byte at $232F (ROM 0) should have been $19 for "Q Parameter
error"]

Print Message
Print a message which is terminated by having bit 7 set, pointed at by DE.

L057D:

LD A,(DE)
AND $7F
PUSH DE
RST 10H
POP DE
LD A,(DE)

Fetch next byte.
Mask off top bit.
Save address of current message byte.
Print character.
Restore message byte pointer.

33

SPECTRUM 128 ROM 0 DISASSEMBLY

INC DE
ADD A,A
JR NC,L057D
RET

Carry flag will be set if byte is $FF.
Else print next character.

INITIALISATION ROUTINES — PART 3

The 'Initial Channel Information'
Initially there are four channels ('K', 'S', 'R', & 'P') for communicating with the 'keyboard', 'screen', 'work space' and 'printer'.
For each channel the output routine address comes before the input routine address and the channel's code.
This table is almost identical to that in ROM 1 at $15AF but with changes to the channel P routines to use the RS232 port instead of the ZX Printer.
Used at $01DD (ROM 0).

L0589:

DEFW PRINT_OUT
DEFW KEY_INPUT
DEFB 'K'
DEFW PRINT_OUT
DEFW REPORT_J
DEFB 'S'
DEFW ADD_CHAR
DEFW REPORT_J
DEFB 'R'
DEFW POUT
DEFW PIN
DEFB 'P'
DEFB $80

$09F4 - K channel output routine.
$10A8 - K channel input routine.
$4B - Channel identifier 'K'.
$09F4 - S channel output routine.
$15C4 - S channel input routine.
$53 - Channel identifier 'S'.
$0F81 - R channel output routine.
$15C4 - R channel input routine.
$52 - Channel identifier 'R'.
$5B34 - P Channel output routine.
$5B2F - P Channel input routine.
$50 - Channel identifier 'P'.
End marker.

The 'Initial Stream Data'
Initially there are seven streams - $FD to $03.
This table is identical to that in ROM 1 at $15C6.
Used at $0226 (ROM 0).

L059E:

DEFB $01, $00
DEFB $06, $00
DEFB $0B, $00
DEFB $01, $00
DEFB $01, $00
DEFB $06, $00
DEFB $10, $00

Stream $FD leads to channel 'K'.
Stream $FE leads to channel 'S'.
Stream $FF leads to channel 'R'.
Stream $00 leads to channel 'K'.
Stream $01 leads to channel 'K'.
Stream $02 leads to channel 'S'.
Stream $03 leads to channel 'P'.

ERROR HANDLER ROUTINES — PART 5

Produce Error Report

L05AC:

POP HL
LD BC,$7FFD
XOR A
DI
LD (BANK_M),A
OUT (C),A
EI
LD SP,($5C3D)
LD A,(HL)
LD (RAMERR),A
INC A
CP $1E

Point to the error byte.

ROM 0, Screen 0, Bank 0, 128 mode.
Ensure interrupts disable whilst paging.
$5B5C. Store new state in BANK_M.
Switch to ROM 0.

Restore SP from ERR_SP.
Fetch the error number.
$5B5E. Store the error number.

[BUG - This should be $1D. As such, error code 'a' will be diverted to ROM 1 for
handling. Credit: Paul Farrow]

34

SPECTRUM 128 ROM 0 DISASSEMBLY

JR NC,L05C8

Jump if not a standard error code.

Handle a standard error code

RST 28H
DEFW RAMRST

$5B5D. Call the error handler routine in ROM 1.

Handle a new error code

L05C8:

DEC A
LD (IY+$00),A
LD HL,($5C5D)
LD ($5C5F),HL
RST 28H
DEFW SET_STK
RET

Store in ERR_NR.
CH_ADD.
X_PTR. Set up the address of the character after the '?' marker.

$16C5. Set the calculator stack.
Return to the error routine.

Check for BREAK into Program

L05D6:

LD A,$7F
IN A,($FE)
RRA
RET C
LD A,$FE
IN A,($FE)
RRA
RET C
CALL L05AC
DEFB $14

Read keyboard row B - SPACE.

Extract the SPACE key.
Return if SPACE not pressed.
Read keyboard row CAPS SHIFT - V.

Extract the CAPS SHIFT key.
Return if CAPS SHIFT not pressed.
Produce an error.
"L Break into program"

RS232 PRINTER ROUTINES

RS232 Channel Handler Routines
This routine handles input and output RS232 requested. It is similar to the routine in the ZX Interface 1 ROM at $0D5A, but in that ROM the routine
is only used for input.

L05E6:

Handle INPUT#

L060A:

EI
EX AF,AF'
LD DE,POUT2
PUSH DE
RES 3,(IY+$02)
PUSH HL
LD HL,($5C3D)
LD E,(HL)
INC HL
LD D,(HL)
AND A
LD HL,ED_ERROR
SBC HL,DE
JR NZ,L0637

POP HL
LD SP,($5C3D)
POP DE
POP DE

LD ($5C3D),DE
PUSH HL

Enabled interrupts.
Save AF registers.
$5B4A. Address of the RS232 exit routine held in RAM.
Stack it.
TVFLAG. Indicate not automatic listing.
Save the input/output routine address.
Fetch location of error handler routine from ERR_SP.

DE=Address of error handler routine.

$107F in ROM 1.

Jump if error handler address is different, i.e. due to INKEY$# or PRINT#.

Retrieve the input/output routine address.
ERR_SP.
Discard the error handler routine address.
Fetch the original address of ERR_SP (this was stacked at the beginning of the
INPUT routine in ROM 1).
ERR_SP.
Save the input/output routine address.

35

SPECTRUM 128 ROM 0 DISASSEMBLY

LD DE,L0610
PUSH DE
JP (HL)

Address to return to.
Stack the address.
Jump to the RS232 input/output routine.

Return here from the input/output routine

L0610:

L0614:

JR C,L061B
JR Z,L0618
CALL L05AC
DEFB $07

A character was not received

L0618:

POP HL
JR L060A

A character was received

Jump if a character was received.
Jump if a character was not received.
Produce an error "8 End of file".

Retrieve the input routine address.
Jump back to await another character.

L061B:

CP $0D
JR Z,L062D
LD HL,(RETADDR)
PUSH HL
RST 28H
DEFW ADD_CHAR+4
POP HL
LD (RETADDR),HL
POP HL
JR L060A

Is it a carriage return?
Jump ahead if so.
$5B5A. Fetch the return address.

$0F85. Insert the character into the INPUT line.

$5B5A. Restore the return address.
Retrieve the input routine address.
Jump back to await another character.

Enter was received so end reading the stream

L062D:

POP HL
LD A,(BANK_M)
OR $10
PUSH AF
JP POUT2

Handle INKEY$# and PRINT#

L0637:

POP HL
LD DE,L063D
PUSH DE
JP (HL)

Discard the input routine address.
$5B5C. Fetch current paging configuration.
Select ROM 1.
Stack the required paging configuration.
$5B4A. Exit.

Retrieve the input/output routine address.

Stack the return address.
Jump to input or output routine.

Return here from the input/output routine. When returning from the output routine, either the carry or zero flags should always be set to avoid the false
generation of error report "8 End of file" [though this is not always the case - see bugs starting at $086C (ROM 0)].

L063D:

RET C
RET Z
JR L0614

Return if a character was received.
Return if a character was not received or was written.
Produce error report "8 End of file".

FORMAT Routine
The format command sets the RS232 baud rate, e.g. FORMAT "P"; 9600.
It attempts to match against one of the supported baud rates, or uses the next higher baud rate if a non-standard value is requested. The maximum baud
rate supported is 9600, and this is used for any rates specified that are higher than this.

L0641:

RST 28H
DEFW GET_CHAR
RST 28H
DEFW EXPT_EXP
BIT 7,(IY+$01)
JR Z,L0661

[Could just do RST $18]
$0018.
Get an expression.
$1C8C.
FLAGS.
Jump ahead if syntax checking.

36

L0659:

L0661:

L067D:

L0689:

RST 28H
DEFW STK_FETCH
LD A,C
DEC A
OR B
JR Z,L0659
CALL L05AC
DEFB $24
LD A,(DE)
AND $DF
CP 'P'
JP NZ,L1912
LD HL,($5C5D)
LD A,(HL)
CP $3B
JP NZ,L1912
RST 28H
DEFW NEXT_CHAR
RST 28H
DEFW EXPT_1NUM
BIT 7,(IY+$01)
JR Z,L067D
RST 28H
DEFW FIND_INT2
LD (HD_00),BC
RST 28H
DEFW GET_CHAR
CP $0D
JR Z,L0689
CP ':'
JP NZ,L1912
CALL L18A1
LD BC,(HD_00)
LD A,B
OR C
JR NZ,L0698
CALL L05AC
DEFB $25

SPECTRUM 128 ROM 0 DISASSEMBLY

$2BF1. Fetch the expression.

Jump ahead if string is 1 character long.
Produce error report.
"i Invalid device".
Get character.
Convert to upper case.
$50. Is it channel 'P'?
Jump if not to produce error report "C Nonsense in BASIC".
CH_ADD. Next character to be interpreted.

Next character must be ';'.
Jump if not to produce error report "C Nonsense in BASIC".
Skip past the ';' character.
$0020. [Could just do RST $20]
Get a numeric expression from the line.
$1C82.
FLAGS. Checking syntax mode?
Jump ahead if so.
Get the result as an integer.
$1E99.
$5B71. Store the result temporarily for use later.
[Could just do RST $18]
$0018. Get the next character in the BASIC line.
It should be ENTER.
Jump ahead if it is.
$3A. Or the character is allowed to be ':'.
Jump if not to produce error report "C Nonsense in BASIC".
Check for end of line.
$5B71. Get the baud rate saved earlier.
Is it zero?

Jump if not, i.e. a numeric value was specified.
Produce error report.
"j invalid baud rate"

Lookup the timing constant to use for the specified baud rate

L0698:
L069B:

LD HL,L06B8
LD E,(HL)
INC HL
LD D,(HL)
INC HL
EX DE,HL
LD A,H
CP $25
JR NC,L06AF
AND A
SBC HL,BC
JR NC,L06AF
EX DE,HL
INC HL
INC HL
JR L069B

The baud rate has been matched

L06AF:

EX DE,HL
LD E,(HL)
INC HL
LD D,(HL)
LD (BAUD),DE
RET

Table of supported baud rates.

HL=Supported baud rate value.

Reached the last baud rate value in the table?
Jump is so to use a default baud rate of 9600.

Table entry matches or is higher than requested baud rate?
Jump ahead if so to use this baud rate.

Skip past the timing constant value
for this baud rate entry.

HL points to timing value for the baud rate.

DE=Timing value for the baud rate.
$5B71. Store new value in system variable BAUD.

37

SPECTRUM 128 ROM 0 DISASSEMBLY

Baud Rate Table
Consists of entries of baud rate value followed by timing constant to use in the RS232 routines.

L06B8:

DEFW $0032, $0AA5
DEFW $006E, $04D4
DEFW $012C, $01C3
DEFW $0258, $00E0
DEFW $04B0, $006E
DEFW $0960, $0036
DEFW $12C0, $0019
DEFW $2580, $000B

Baud=50.
Baud=110.
Baud=300.
Baud=600.
Baud=1200.
Baud=2400.
Baud=4800.
Baud=9600.

RS232 Input Routine
Exit: Carry flag set if a byte was read with the byte in A. Carry flag reset upon error.

L06D8:

LD HL,SERFL
LD A,(HL)
AND A
JR Z,L06E5
LD (HL),$00
INC HL
LD A,(HL)
SCF
RET

$5B61. SERFL holds second char that can be received
Is the second-character received flag set?
i.e. have we already received data?
Jump ahead if not.
Otherwise clear the flag

and return the data which we received earlier.
Set carry flag to indicate success

Read Byte from RS232 Port
The timing of the routine is achieved using the timing constant held in system variable BAUD.
Exit: Carry flag set if a byte was read, or reset upon error.
A=Byte read in.

L06E5:

CALL L05D6
DI
EXX
LD DE,(BAUD)
LD HL,(BAUD)
SRL H
RR L
OR A
LD B,$FA
EXX
LD C,$FD
LD D,$FF
LD E,$BF
LD B,D
LD A,$0E
OUT (C),A
IN A,(C)
OR $F0
AND $FB
LD B,E
OUT (C),A
LD H,A

Check the BREAK key, and produce error message if it is being pressed.
Ensure interrupts are disabled to achieve accurate timing.

$5B71. Fetch the baud rate timing constant.
$5B71.

HL=BAUD/2. So that will sync to half way point in each bit.
[Redundant byte]
Waiting time for start bit.
Save B.

Selects register 14, port I/O of AY-3-8912.
Read the current state of the I/O lines.
%11110000. Default all input lines to 1.
%11111011. Force CTS line to 0.
B=$BF.
Make CTS (Clear To Send) low to indicate ready to receive.
Store status of other I/O lines.

Look for the start bit

L070E:

L0715:

LD B,D
IN A,(C)
AND $80
JR Z,L071E
EXX

Read the input line.
%10000000. Test TXD (input) line.
Jump if START BIT found.
Fetch timeout counter

38

L071E:

DEC B
EXX
JR NZ,L070E
XOR A
PUSH AF
JR L0757
IN A,(C)
AND $80
JR NZ,L0715
IN A,(C)
AND $80
JR NZ,L0715

SPECTRUM 128 ROM 0 DISASSEMBLY

and decrement it.
Store it.
Continue to wait for start bit if not timed out.
Reset carry flag to indicate no byte read.
Save the failure flag.
Timed out waiting for START BIT.
Second test of START BIT - it should still be 0.
Test TXD (input) line.
Jump back if it is no longer 0.
Third test of START BIT - it should still be 0.
Test TXD (input) line.
Jump back if it is no longer 0.

A start bit has been found, so the 8 data bits are now read in.
As each bit is read in, it is shifted into the msb of A. Bit 7 of A is preloaded with a 1 to represent the start bit and when this is shifted into the carry flag
it signifies that 8 data bits have been read in.

L0731:

BD-DELAY

L0736:

Received one 1

Received one 0

L074B:

EXX
LD BC,$FFFD
LD A,$80
EX AF,AF'
ADD HL,DE
NOP
NOP
NOP
NOP

DEC HL
LD A,H
OR L
JR NZ,L0736
IN A,(C)
AND $80
JP Z,L074B

EX AF,AF'
SCF
RRA
JR C,L0754
EX AF,AF'
JP L0731

EX AF,AF'
OR A
RRA
JR C,L0754
EX AF,AF'
JP L0731

Preload A with the START BIT. It forms a shift counter used to count
the number of bits to read in.
HL=1.5*(BAUD).
(4) Fine tune the following delay.

(6) Delay for 26*BAUD.
(4)
(4)
(12) Jump back to until delay completed.
Read a bit.
Test TXD (input) line.
Jump if a 0 received.

Fetch the bit counter.
Set carry flag to indicate received a 1.
Shift received bit into the byte (C->76543210->C).
Jump if START BIT has been shifted out indicating all data bits have been received.
Save the bit counter.
Jump back to read the next bit.

Fetch the bit counter.
Clear carry flag to indicate received a 0.
Shift received bit into the byte (C->76543210->C).
Jump if START BIT has been shifted out indicating all data bits have been received.
Save the bit counter.
Jump back to read next bit.

After looping 8 times to read the 8 data bits, the start bit in the bit counter will be shifted out and hence A will contain a received byte.

L0754:

SCF
PUSH AF
EXX

Signal success.
Push success flag.

The success and failure paths converge here

L0757:

LD A,H

39

OR $04
LD B,E
OUT (C),A
EXX
LD H,D
LD L,E
LD BC,$0007
OR A
SBC HL,BC
DEC HL
LD A,H
OR L
JR NZ,L0766
LD BC,$FFFD
ADD HL,DE
ADD HL,DE
ADD HL,DE

L0766:

SPECTRUM 128 ROM 0 DISASSEMBLY

A=%1111x1xx. Force CTS line to 1.
B=$BF.
Make CTS (Clear To Send) high to indicate not ready to receive.

HL=(BAUD).

HL=(BAUD)-7.
Delay for the stop bit.

Jump back until delay completed.
HL will be $0000.
DE=(BAUD).

HL=3*(BAUD). This is how long to wait for the next start bit.

The device at the other end of the cable may send a second byte even though CTS is low. So repeat the procedure to read another byte.

L0771:

IN A,(C)
AND $80
JR Z,L077F
DEC HL
LD A,H
OR L
JR NZ,L0771

Read the input line.
%10000000. Test TXD (input) line.
Jump if START BIT found.
Decrement timeout counter.

Jump back looping for a start bit until a timeout occurs.

No second byte incoming so return status of the first byte read attempt

L077F:

POP AF
EI
RET
IN A,(C)
AND $80
JR NZ,L0771
IN A,(C)
AND $80
JR NZ,L0771

Return status of first byte read attempt - carry flag reset for no byte received or
carry flag set and A holds the received byte.

Second test of START BIT - it should still be 0.
Test TXD (input) line.
Jump back if it is no longer 0.
Third test of START BIT - it should still be 0.
Test TXD (input) line.
Jump back if it is no longer 0.

A second byte is on its way and is received exactly as before

LD H,D
LD L,E
LD BC,$0002
SRL H
RR L
OR A
SBC HL,BC
LD BC,$FFFD
LD A,$80
EX AF,AF'
NOP
NOP
NOP
NOP
ADD HL,DE
DEC HL
LD A,H
OR L
JR NZ,L07A2
IN A,(C)
AND $80
JP Z,L07B7

L079D:

L07A2:

HL=(BAUD).

HL=(BAUD)/2.

HL=(BAUD)/2 - 2.

Preload A with the START BIT. It forms a shift counter used to count
the number of bits to read in.
Fine tune the following delay.

HL=1.5*(BAUD).
Delay for 26*(BAUD).

Jump back to until delay completed.
Read a bit.
Test TXD (input) line.
Jump if a 0 received.

40

Received one 1

Received one 0

L07B7:

EX AF,AF'
SCF
RRA
JR C,L07C0
EX AF,AF'
JP L079D

EX AF,AF'
OR A
RRA
JR C,L07C0
EX AF,AF'
JP L079D

Exit with the byte that was read in

L07C0:

LD HL,SERFL
LD (HL),$01
INC HL
LD (HL),A
POP AF
EI
RET

SPECTRUM 128 ROM 0 DISASSEMBLY

Fetch the bit counter.
Set carry flag to indicate received a 1.
Shift received bit into the byte (C->76543210->C).
Jump if START BIT has been shifted out indicating all data bits have been received.
Save the bit counter.
Jump back to read the next bit.

Fetch the bit counter.
Clear carry flag to indicate received a 0.
Shift received bit into the byte (C->76543210->C).
Jump if START BIT has been shifted out indicating all data bits have been received.
Save the bit counter.
Jump back to read next bit.

$5B61.
Set the flag indicating a second byte is in the buffer.

Store the second byte read in the buffer.
Return the first byte.
Re-enable interrupts.

RS232 Output Routine
This routine handles control codes, token expansion, graphics and UDGs. It therefore cannot send binary data and hence cannot support EPSON format
ESC control codes [Credit: Andrew Owen].
The routine suffers from a number of bugs as described in the comments below. It also suffers from a minor flaw in the design, which prevents interlacing
screen and printer control codes and their parameters. For example, the following will not work correctly: 10 LPRINT CHR$ 16
20 PRINT AT 0,0
30 LPRINT CHR$ 0;"ABC"
The control byte 16 gets stored in TVDATA so that the system knows how to interpret its parameter byte. However, the AT control code 22 in line 20
will overwrite it. When line 30 is executed, TVDATA still holds the control code for 'AT' and so this line is interpreted as PRINT AT instead of PRINT
INK. [Credit: Ian Collier (+3)]
Entry:
Exit :

A=character to output.
Carry flag reset indicates success.

L07CA:

PUSH AF
LD A,(TVPARS)
OR A
JR Z,L07E0
DEC A
LD (TVPARS),A
JR NZ,L07DB

All parameters processed

POP AF
JP L0872
POP AF
LD ($5C0F),A
RET
POP AF
CP $A3
JR C,L07F2

L07DB:

L07E0:

Process tokens

Save the character to print.
$5B65. Number of parameters expected.

Jump if no parameters.
Ignore the parameter.
$5B65.
Jump ahead if we have not processed all parameters.

Retrieve character to print.
Jump ahead to continue.
Retrieve character to print.
TVDATA+1. Store it for use later.

Retrieve character to print.
Test against code for 'SPECTRUM'.
Jump ahead if not a token.

41

LD HL,(RETADDR)
PUSH HL
RST 28H
DEFW PO_T_UDG
POP HL
LD (RETADDR),HL
SCF
RET
LD HL,$5C3B
RES 0,(HL)
CP ' '
JR NZ,L07FD
SET 0,(HL)
CP $7F
JR C,L0803
LD A,'?'
CP $20
JR C,L081E

L07F2:

L07FD:

L0803:

Printable character

L0807:

L081A:

PUSH AF
LD HL,COL
INC (HL)
LD A,(WIDTH)
CP (HL)
JR NC,L081A
CALL L0822
LD A,$01
LD (COL),A
POP AF
JP L08A3

Process control codes

SPECTRUM 128 ROM 0 DISASSEMBLY

$5B5A. Save RETADDR temporarily.

$0B52. Print tokens via call to ROM 1 routine PO-T&UDG.

$5B5A. Restore the original contents of RETADDR.

FLAGS.
Suppress printing a leading space.
$20. Is character to output a space?
Jump ahead if not a space.
Signal leading space required.
Compare against copyright symbol.
Jump ahead if not a graphic or UDG character.
$3F. Print a '?' for all graphic and UDG characters.
Is it a control character?
Jump ahead if so.

Save the character to print.
$5B63. Point to the column number.
Increment the column number.
$5B64. Fetch the number of columns.

Jump if end of row not reached.
Print a carriage return and line feed.

$5B63. Set the print position to column 1.
Retrieve character to print.
Jump ahead to print the character.

L081E:

CP $0D
JR NZ,L0830

Is it a carriage return?
Jump ahead if not.

Handle a carriage return

L0822:

L0830:

XOR A
LD (COL),A
LD A,$0D
CALL L08A3
LD A,$0A
JP L08A3
CP $06
JR NZ,L0853

Handle a comma

L083A:

L0840:

LD BC,(COL)
LD E,$00
INC E
INC C
LD A,C
CP B
JR Z,L0848
SUB $08
JR Z,L0848
JR NC,L0840
JR L083A

$5B63. Set the print position back to column 0.

Print a carriage return.

Print a line feed.
Is it a comma?
Jump ahead if not.

$5B63. Fetch the column position.
Will count number of columns to move across to reach next comma position.
Increment column counter.
Increment column position.

End of row reached?
Jump if so.

Jump if column 8, 16 or 32 reached.
Column position greater so subtract another 8.
Jump back and increment column position again.

Column 8, 16 or 32 reached. Output multiple spaces until the desired column position is reached.

42

L0848:

L0853:

PUSH DE
LD A,$20
CALL L07CA
POP DE
DEC E
RET Z
JR L0848
CP $16
JR Z,L0860
CP $17
JR Z,L0860
CP $10
RET C
JR L0869

Handle AT and TAB

L0860:

LD ($5C0E),A
LD A,$02
LD (TVPARS),A
RET

SPECTRUM 128 ROM 0 DISASSEMBLY

Save column counter in E.

Output a space via a recursive call.
Retrieve column counter to E.
More spaces to output?
Return if no more to output.
Repeat for the next space to output.
Is it AT?
Jump ahead to handle AT.
Is it TAB?
Jump ahead to handle TAB.
Check for INK, PAPER, FLASH, BRIGHT, INVERSE, OVER.
Ignore if not one of these.
Jump ahead to handle INK, PAPER, FLASH, BRIGHT, INVERSE, OVER.

TV_DATA. Store the control code for use later, $16 (AT) or $17 (TAB).
Two parameters expected (even for TAB).
$5B65.
Return with zero flag set.

Handle INK, PAPER, FLASH, BRIGHT, INVERSE, OVER

L0869:

LD ($5C0E),A
LD A,$02

LD (TVPARS),A
RET

All parameters processed

L0872:

LD D,A
LD A,($5C0E)
CP $16
JR Z,L0882
CP $17
CCF

RET NZ

TV_DATA. Store the control code for use later.
Two parameters expected. [BUG - Should be 1 parameter. 'LPRINT INK 4' will
produce error report 'C Nonsense in BASIC'. Credit: Toni Baker, ZX Computing
Monthly].
$5B65.
[BUG - Should return with the carry flag reset and the zero flag set. It causes a
statement such as 'LPRINT INK 1;' to produce error report '8 End of file'. It is due
to the main RS232 processing loop using the state of the flags to determine the
success/failure response of the RS232 output routine. Credit: Ian Collier (+3),
Andrew Owen (128)] [The bug can be fixed by inserting a XOR A instruction before
the RET instruction. Credit: Paul Farrow]

D=Character to print.
TV_DATA. Fetch the control code.
Is it AT?
Jump ahead to handle AT parameter.
Is it TAB?
[BUG - Should return with the carry flag reset and the zero flag set. It causes a
statement such as 'LPRINT INK 1;' to produce error report '8 End of file'. It is due
to the main RS232 processing loop using the state of the flags to determine the
success/failure response of the RS232 output routine. Credit: Toni Baker, ZX
Computing Monthly]
Ignore if not TAB.

[The bug can be fixed by replacing the instructions CCF and RET NZ with the following. Credit: Paul Farrow.

JR Z,NOT_TAB
XOR A
RET

NOT_TAB

Handle TAB parameter

LD A,($5C0F)
LD D,A

TV_DATA+1. Fetch the saved parameter.
Fetch parameter to D.

Process AT and TAB

43

SPECTRUM 128 ROM 0 DISASSEMBLY

L0882:

LD A,(WIDTH)
CP D
JR Z,L088A
JR NC,L0890

$5B64.
Reached end of row?
Jump ahead if so.
Jump ahead if before end of row.

Column position equal or greater than length of row requested

L088A:

L0890:

L0895:

LD B,A
LD A,D
SUB B
LD D,A
JR L0882
LD A,D
OR A
JP Z,L0822
LD A,(COL)
CP D
RET Z
PUSH DE
LD A,$20
CALL L07CA
POP DE
JR L0895

(WIDTH).
TAB/AT column position.
TAB/AT position - WIDTH.
The new required column position.
Handle the new TAB/AT position.
Fetch the desired column number.

Jump to output a carriage return if column 0 required.
$5B63. Fetch the current column position.
Compare against desired column position.
Done if reached requested column.
Save the number of spaces to output.

Output a space via a recursive call.
Retrieve number of spaces to output.
Keep outputting spaces until desired column reached.

Write Byte to RS232 Port
The timing of the routine is achieved using the timing constant held in system variable BAUD.
Entry:
Exit:

A holds character to send.
Carry and zero flags reset.

L08A3:

L08AF:

PUSH AF
LD C,$FD
LD D,$FF
LD E,$BF
LD B,D
LD A,$0E
OUT (C),A
CALL L05D6
IN A,(C)
AND $40
JR NZ,L08AF
LD HL,(BAUD)
LD DE,$0002
OR A
SBC HL,DE
EX DE,HL
POP AF
CPL
SCF
LD B,$0B
DI

Transmit each bit

PUSH BC
PUSH AF
LD A,$FE
LD H,D
LD L,E
LD BC,$BFFD
JP NC,L08DA

L08C8:

Transmit a 0

Save the byte to send.

Select AY register 14 to control the RS232 port.
Check the BREAK key, and produce error message if it is being pressed.
Read status of data register.
%01000000. Test the DTR line.
Jump back until device is ready for data.
$5B5F. HL=Baud rate timing constant.

DE=(BAUD)-2.
Retrieve the byte to send.
Invert the bits of the byte (RS232 logic is inverted).
Carry is used to send START BIT.
B=Number of bits to send (1 start + 8 data + 2 stop).
Disable interrupts to ensure accurate timing.

Save the number of bits to send.
Save the data bits.

HL=(BAUD)-2.
AY-3-8912 data register.
Branch to transmit a 1 or a 0 (initially sending a 0 for the start bit).

44

AND $F7
OUT (C),A
JR L08E0

OR $08
OUT (C),A
JR L08E0

Transmit a 1

L08DA:

Delay the length of a bit

L08E0:

DEC HL
LD A,H
OR L
JR NZ,L08E0
NOP
NOP
NOP
POP AF
POP BC
OR A
RRA
DJNZ L08C8
EI
RET

SPECTRUM 128 ROM 0 DISASSEMBLY

Clear the RXD (out) line.
Send out a 0 (high level).
Jump ahead to continue with next bit.

Set the RXD (out) line.
Send out a 1 (low level).
Jump ahead to continue with next bit.

(6) Delay 26*BAUD cycles.
(4)
(4)
(12) Jump back until delay is completed.
(4) Fine tune the timing.
(4)
(4)
Retrieve the data bits to send.
Retrieve the number of bits left to send.
Clear carry flag.
Shift the next bit to send into the carry flag.
Jump back to send next bit until all bits sent.
Re-enable interrupts.
Return with carry and zero flags reset.

COPY Command Routine
This routine copies 22 rows of the screen, outputting them to the printer a half row at a time. It is designed for EPSON compatible printers supporting
double density bit graphics and 7/72 inch line spacing.
Only the pixel information is processed; the attributes are ignored.

L08F0:

L08F5:

LD HL,HD_0B
LD (HL),$2B
LD HL,L0979

CALL L095F
CALL L0915
LD HL,L0980
CALL L095F
LD HL,HD_0B
XOR A
CP (HL)
JR Z,L090E
DEC (HL)
JR L08F5

Half row counter.
Set the half row counter to 43 half rows (will output 44 half rows in total).
Point to printer configuration data (7/72 inch line spacing, double density bit
graphics).
Send the configuration data to printer.
Output a half row, at double height.
Table holds a line feed only.
Send a line feed to printer.
$5B72. The half row counter is tested to see if it is zero
and if so then the line spacing is reset to its
original value.
Jump if done, resetting printer line spacing.
Decrement half row counter.
Repeat for the next half row.

Copy done so reset printer line spacing before exiting

L090E:

LD HL,L0982
CALL L095F
RET

Point to printer configuration data (1/6 inch line spacing).
Send the configuration data to printer.
[Could have saved 1 byte by using JP $095F (ROM 0)]

Output Half Row

L0915:

L091A:

LD HL,HD_00
LD (HL),$FF
CALL L0926
LD HL,HD_00
XOR A
CP (HL)

$5B71. Pixel column counter.
Set pixel column counter to 255 pixels.
Output a column of pixels, at double height.
$5B71. Pixel column counter.

Check if all pixels in this row have been output.

45

SPECTRUM 128 ROM 0 DISASSEMBLY

RET Z
DEC (HL)
JR L091A

Return if so.
Decrement pixel column counter.
Repeat for all pixels in this row.

Output a column of pixels (at double height)

L0926:

L093A:

L0944:

LD DE,$C000
LD BC,(HD_00)
SCF
RL B
SCF
RL B
LD A,C
CPL
LD C,A
XOR A
PUSH AF
PUSH DE
PUSH BC
CALL L096D
POP BC
POP DE
LD E,$00
JR Z,L0944
LD E,D

POP AF
OR E
PUSH AF
DEC B
SRL D
SRL D
PUSH DE
PUSH BC
JR NC,L093A
POP BC
POP DE
POP AF
LD B,$03

D=%11000000. Used to hold the double height pixel.
$5B71. C=Pixel column counter, B=Half row counter.

B=2xB+1

B=4xB+3. The pixel row coordinate.
Pixel column counter.

C=255-C. The pixel column coordinate.
Clear A. Used to generate double height nibble of pixels to output.

Save registers.
Test whether pixel (B,C) is set

Restore registers.
Set double height pixel = 0.
Jump if pixel is reset.
The double height pixel to output (%11000000, %00110000, %00001100 or
%00000011).

Add the double height pixel value to the byte to output.

Decrement half row coordinate.

Create next double height pixel value (%00110000, %00001100 or %00000011).

Repeat for all four pixels in the half row.

Unload the stack.

Send double height nibble of pixels output 3 times.

Output Nibble of Pixels
Send each nibble of pixels (i.e. column of 4 pixels) output 3 times so that the width of a pixel is the same size as its height.

L0955:

PUSH BC
PUSH AF
CALL L08A3
POP AF
POP BC
DJNZ L0955
RET

Send byte to RS232 port.

Output Characters from Table
This routine is used to send a sequence of EPSON printer control codes out to the RS232 port.
It sends (HL) characters starting from HL+1.

L095F:

L0961:

LD B,(HL)
INC HL
LD A,(HL)
PUSH HL
PUSH BC
CALL L08A3
POP BC

Get number of bytes to send.
Point to the data to send.
Retrieve value.

Send byte to RS232 port.

46

SPECTRUM 128 ROM 0 DISASSEMBLY

POP HL
INC HL
DJNZ L0961
RET

Point to next data byte to send.
Repeat for all bytes.

Test Whether Pixel (B,C) is Set

L096D:

L0974:

RST 28H
DEFW PIXEL_ADDR
LD B,A
INC B
XOR A
SCF
RRA
DJNZ L0974
AND (HL)
RET

Get address of (B,C) pixel into HL and pixel position within byte into A.
$22AA.
B=Pixel position within byte (0-7).

Pixel mask.
Carry flag holds bit to be rotated into the mask.
Shift the mask bit into the required bit position.

Isolate this pixel from A.

EPSON Printer Control Code Tables

L0979:

L0980:

L0982:

DEFB $06
DEFB $1B, $31
DEFB $1B, $4C, $00, $03
DEFB $01
DEFB $0A
DEFB $02
DEFB $1B, $32

6 characters follow.
ESC '1' - 7/72 inch line spacing.
ESC 'L' 0 3 - Double density (768 bytes per row).
1 character follows.
Line feed.
2 characters follow.
ESC '2' - 1/6 inch line spacing.

PLAY COMMAND ROUTINES
Up to 3 channels of music/noise are supported by the AY-3-8912 sound generator.
Up to 8 channels of music can be sent to support synthesisers, drum machines or sequencers via the MIDI interface, with the first 3 channels also played
by the AY-3-8912 sound generator. For each channel of music, a MIDI channel can be assigned to it using the 'Y' command.
The PLAY command reserves and initialises space for the PLAY command. This comprises a block of $003C bytes used to manage the PLAY command
(IY points to this command data block) and a block of $0037 bytes for each channel string (IX is used to point to the channel data block for the current
channel). [Note that the command data block is $04 bytes larger than it needs to be, and each channel data block is $11 bytes larger than it needs to be]
Entry:

B=The number of strings in the PLAY command (1..8).

Command Data Block Format
IY+$00 / IY+$01
IY+$02 / IY+$03
IY+$04 / IY+$05
IY+$06 / IY+$07
IY+$08 / IY+$09
IY+$0A / IY+$0B
IY+$0C / IY+$0D
IY+$0E / IY+$0F
IY+$10

Channel 0 data block pointer. Points to the data for channel 0 (string 1).
Channel 1 data block pointer. Points to the data for channel 1 (string 2).
Channel 2 data block pointer. Points to the data for channel 2 (string 3).
Channel 3 data block pointer. Points to the data for channel 3 (string 4).
Channel 4 data block pointer. Points to the data for channel 4 (string 5).
Channel 5 data block pointer. Points to the data for channel 5 (string 6).
Channel 6 data block pointer. Points to the data for channel 6 (string 7).
Channel 7 data block pointer. Points to the data for channel 7 (string 8).
Channel bitmap. Initialised to $FF and a 0 rotated in to the left for each string parameters
of the PLAY command, thereby indicating the channels in use.
Channel data block duration pointer. Points to duration length store in channel 0 data block (string 1).
Channel data block duration pointer. Points to duration length store in channel 1 data block (string 2).
Channel data block duration pointer. Points to duration length store in channel 2 data block (string 3).
Channel data block duration pointer. Points to duration length store in channel 3 data block (string 4).
Channel data block duration pointer. Points to duration length store in channel 4 data block (string 5).
Channel data block duration pointer. Points to duration length store in channel 5 data block (string 6).
Channel data block duration pointer. Points to duration length store in channel 6 data block (string 7).
Channel data block duration pointer. Points to duration length store in channel 7 data block (string 8).
Channel selector. It is used as a shift register with bit 0 initially set and then shift to the left

IY+$11 / IY+$12
IY+$13 / IY+$14
IY+$15 / IY+$16
IY+$17 / IY+$18
IY+$19 / IY+$1A
IY+$1B / IY+$1C
IY+$1D / IY+$1E
IY+$1F / IY+$20
IY+$21

47

SPECTRUM 128 ROM 0 DISASSEMBLY

IY+$22
IY+$23 / IY+$24

IY+$25 / IY+$26
IY+$27 / IY+$28
IY+$29
IY+$2A
IY+$2B..IY+$37
IY+$38..IY+$3B

until a carry occurs, thereby indicating all 8 possible channels have been processed.
Temporary channel bitmap, used to hold a working copy of the channel bitmap at IY+$10.
Address of the channel data block pointers, or address of the channel data block duration pointers
(allows the routine at $0A6E (ROM 0) to be used with both set of pointers).
Stores the smallest duration length of all currently playing channel notes.
The current tempo timing value (derived from the tempo parameter 60..240 beats per second).
The current effect waveform value.
Temporary string counter selector.
Holds a floating point calculator routine.
Not used.

Channel Data Block Format
IX+$00
IX+$01
IX+$02
IX+$03
IX+$04
IX+$05
IX+$06 / IX+$07
IX+$08 / IX+$09
IX+$0A

The note number being played on this channel (equivalent to index offset into the note table).
MIDI channel assigned to this string (range 0 to 15).
Channel number (range 0 to 7), i.e. index position of the string within the PLAY command.
12*Octave number (0, 12, 24, 36, 48, 60, 72, 84 or 96).
Current volume (range 0 to 15, or if bit 4 set then using envelope).
Last note duration value as specified in the string (range 1 to 9).
Address of current position in the string.
Address of byte after the end of the string.
Flags:
Bit 0 : 1=Single closing bracket found (repeat string indefinitely).
Bits 1-7: Not used (always 0).
Open bracket nesting level (range $00 to $04).
Return address for opening bracket nesting level 0 (points to character after the bracket).
Return address for opening bracket nesting level 1 (points to character after the bracket).
Return address for opening bracket nesting level 2 (points to character after the bracket).
Return address for opening bracket nesting level 3 (points to character after the bracket).
Return address for opening bracket nesting level 4 (points to character after the bracket).
Closing bracket nesting level (range $FF to $04).
Return address for closing bracket nesting level 0 (points to character after the bracket).
Return address for closing bracket nesting level 1 (points to character after the bracket).
Return address for closing bracket nesting level 2 (points to character after the bracket).
Return address for closing bracket nesting level 3 (points to character after the bracket).
Return address for closing bracket nesting level 4 (points to character after the bracket).
Tied notes counter (for a single note the value is 1).
Duration length, specified in 96ths of a note.
Subsequent note duration length (used only with triplets), specified in 96ths of a note.
Not used.

IX+$0B
IX+$0C / IX+$0D
IX+$0E / IX+$0F
IX+$10 / IX+$11
IX+$12 / IX+$13
IX+$14 / IX+$15
IX+$16
IX+$17...IX+$18
IX+$19...IX+$1A
IX+$1B...IX+$1C
IX+$1D...IX+$1E
IX+$1F...IX+$20
IX+$21
IX+$22 / IX+$23
IX+$24...IX+$25
IX+$26...IX+$36

L0985:

DI

Disable interrupts to ensure accurate timing.

Create a workspace for the play channel command strings

L098D:

PUSH BC

LD DE,$0037
LD HL,$003C
ADD HL,DE
DJNZ L098D
LD C,L
LD B,H
RST 28H
DEFW BC_SPACES
DI
PUSH DE
POP IY
PUSH HL
POP IX
LD (IY+$10),$FF

B=Number of channel string (range 1 to 8). Also used as string index number in the
following loop.

Calculate HL=$003C + ($0037 * B).

BC=Space required (maximum = $01F4).

$0030. Make BC bytes of space in the workspace.
Interrupts get re-enabled by the call mechanism to ROM 1 so disable them again.

IY=Points at first new byte - the command data block.

IX=Points at last new byte - byte after all channel information blocks.
Initial channel bitmap with value meaning 'zero strings'

48

Loop over each string to be played

L09A0:

LD BC,$FFC9
ADD IX,BC
LD (IX+$03),$3C
LD (IX+$01),$FF
LD (IX+$04),$0F
LD (IX+$05),$05
LD (IX+$21),$00
LD (IX+$0A),$00
LD (IX+$0B),$00
LD (IX+$16),$FF
LD (IX+$17),$00
LD (IX+$18),$00

SPECTRUM 128 ROM 0 DISASSEMBLY

$-37 ($37 bytes is the size of a play channel string information block).
IX points to start of space for the last channel.
Default octave is 5.
No MIDI channel assigned.
Default volume is 15.
Default note duration.
Count of the number of tied notes.
Signal not to repeat the string indefinitely.
No opening bracket nesting level.
No closing bracket nesting level.
Return address for closing bracket nesting level 0.
[No need to initialise this since it is written to before it is ever tested]

[BUG - At this point interrupts are disabled and IY is now being used as a pointer to the master PLAY information block. Unfortunately, interrupts are
enabled during the STK_FETCH call and IY is left containing the wrong value. This means that if an interrupt were to occur during execution of the
subroutine then there would be a one in 65536 chance that (IY+$40) will be corrupted - this corresponds to the volume setting for music channel A.
Rewriting the SWAP routine to only re-enable interrupts if they were originally enabled would cure this bug (see end of file for description of her suggested
fix). Credit: Toni Baker, ZX Computing Monthly] [An alternative and simpler solution to the fix Toni Baker describes would be to stack IY, set IY to point
to the system variables at $5C3A, call STK_FETCH, disable interrupts, then pop the stacked value back to IY. Credit: Paul Farrow]

RST 28H
DEFW STK_FETCH
DI
LD (IX+$06),E
LD (IX+$07),D
LD (IX+$0C),E
LD (IX+$0D),D
EX DE,HL
ADD HL,BC
LD (IX+$08),L
LD (IX+$09),H
POP BC
PUSH BC
DEC B
LD C,B
LD B,$00
SLA C
PUSH IY
POP HL
ADD HL,BC
PUSH IX
POP BC
LD (HL),C
INC HL
LD (HL),B
OR A
RL (IY+$10)

POP BC
DEC B
PUSH BC
LD (IX+$02),B
JR NZ,L09A0
POP BC

Entry point here from the vector table at $011B

L0A05:

LD (IY+$27),$1A
LD (IY+$28),$0B
PUSH IY
POP HL
LD BC,$002B
ADD HL,BC

Get the details of the string from the stack.
$2BF1.
Interrupts get re-enabled by the call mechanism to ROM 1 so disable them again.
Store the current position within in the string, i.e. the beginning of it.

Store the return position within the string for a closing bracket,
which is initially the start of the string in case a single closing bracket is found.
HL=Points to start of string. BC=Length of string.
HL=Points to address of byte after the string.
Store the address of the character just
after the string.
B=String index number (range 1 to 8).
Save it on the stack again.
Reduce the index so it ranges from 0 to 7.

BC=String index*2.

HL=Address of the command data block.
Skip 8 channel data pointer words.

BC=Address of current channel information block.
Store the pointer to the channel information block.

Clear the carry flag.
Rotate one zero-bit into the least significant bit of the channel bitmap. This initially
holds $FF but once this loop is over, this byte has a zero bit for each string
parameter of the PLAY command.
B=Current string index.
Decrement string index so it ranges from 0 to 7.
Save it for future use on the next iteration.
Store the channel number.
Jump back while more channel strings to process.
Drop item left on the stack.

Set the initial tempo timing value.
Corresponds to a 'T' command value of 120, and gives two crotchets per second.

HL=Points to the command data block.

49

EX DE,HL
LD HL,L0A31
LD BC,$000D
LDIR
LD D,$07
LD E,$F8
CALL L0E7C
LD D,$0B
LD E,$FF
CALL L0E7C
INC D
CALL L0E7C
JR L0A7D

SPECTRUM 128 ROM 0 DISASSEMBLY

DE=Address to store RAM routine.
HL=Address of the RAM routine bytes.

Copy the calculator routine to RAM.
Register 7 - Mixer.
I/O ports are inputs, noise output off, tone output on.
Write to sound generator register.
Register 11 - Envelope Period (Fine).
Set period to maximum.
Write to sound generator register.
Register 12 - Envelope Period (Coarse).
Write to sound generator register.
Jump ahead to continue. [Could have saved these 2 bytes by having the code at
$0A7D (ROM 0) immediately follow]

Calculate Timing Loop Counter « RAM Routine »
This routine is copied into the command data block (offset $2B..$37) by the routine at $0A05 (ROM 0).
It uses the floating point calculator found in ROM 1, which is usually invoked via a RST $28 instruction. Since ROM 0 uses RST $28 to call a routine in
ROM 1, it is unable to invoke the floating point calculator this way. It therefore copies the following routine to RAM and calls it with ROM 1 paged in.
The routine calculates (10/x)/7.33e-6, where x is the tempo 'T' parameter value multiplied by 4. The result is used an inner loop counter in the wait
routine at $0F76 (ROM 0).
Each iteration of this loop takes 26 T-states. The time taken by 26 T-states is 7.33e-6 seconds. So the total time for the loop to execute is 2.5/TEMPO
seconds.
Entry:
Exit :

The value 4*TEMPO exists on the calculator stack (where TEMPO is in the range 60..240).
The calculator stack holds the result.

L0A31:

RST 28H
DEFB $A4
DEFB $01
DEFB $05
DEFB $34
DEFB $DF
DEFB $75
DEFB $F4
DEFB $38
DEFB $75
DEFB $05
DEFB $38
RET

Invoke the floating point calculator.
stk-ten. = x, 10
exchange. = 10, x
division. = 10/x
stk-data. = 10/x, 7.33e-6
- exponent $6F (floating point number 7.33e-6).
- mantissa byte 1
- mantissa byte 2
- mantissa byte 3
- mantissa byte 4
division. = (10/x)/7.33e-6
end-calc.

Test BREAK Key
Test for BREAK being pressed.
Exit: Carry flag reset if BREAK is being pressed.

L0A3E:

LD A,$7F
IN A,($FE)
RRA
RET C
LD A,$FE
IN A,($FE)
RRA
RET

Return with carry flag set if SPACE not pressed.

Return with carry flag set if CAPS not pressed.

Select Channel Data Block Duration Pointers
Point to the start of the channel data block duration pointers within the command data block.
Entry:
Exit :

IY=Address of the command data block.
HL=Address of current channel pointer.

L0A4A:

LD BC,$0011

Offset to the channel data block duration pointers table.

50

SPECTRUM 128 ROM 0 DISASSEMBLY

JR L0A52

Jump ahead to continue.

Select Channel Data Block Pointers
Point to the start of the channel data block pointers within the command data block.
Entry:
Exit :

IY=Address of the command data block.
HL=Address of current channel pointer.

L0A4F:
L0A52:

LD BC,$0000
PUSH IY
POP HL
ADD HL,BC
LD (IY+$23),L
LD (IY+$24),H
LD A,(IY+$10)
LD (IY+$22),A
LD (IY+$21),$01
RET

Offset to the channel data block pointers table.

HL=Point to the command data block.
Point to the desired channel pointers table.

Store the start address of channels pointer table.
Fetch the channel bitmap.
Initialise the working copy.
Channel selector. Set the shift register to indicate the first channel.

Get Channel Data Block Address for Current String

L0A67:

LD E,(HL)
INC HL
LD D,(HL)
PUSH DE
POP IX
RET

Next Channel Data Pointer

L0A6E:

LD L,(IY+$23)
LD H,(IY+$24)
INC HL
INC HL
LD (IY+$23),L
LD (IY+$24),H
RET

Fetch the address of the current channel data block.

Return it in IX.

The address of current channel data pointer.

Advance to the next channel data pointer.

The address of new channel data pointer.

PLAY Command (Continuation)
This section is responsible for processing the PLAY command and is a continuation of the routine at $0985 (ROM 0). It begins by determining the first
note to play on each channel and then enters a loop to play these notes, fetching the subsequent notes to play at the appropriate times.

L0A7D:
L0A80:

CALL L0A4F
RR (IY+$22)
JR C,L0A8C

Select channel data block pointers.
Working copy of channel bitmap. Test if next string present.
Jump ahead if there is no string for this channel.

HL=Address of channel data pointer.

L0A8C:

CALL L0A67
CALL L0B5C
SLA (IY+$21)
JR C,L0A97
CALL L0A6E
JR L0A80

Get address of channel data block for the current string into IX.
Find the first note to play for this channel from its play string.
Have all channels been processed?
Jump ahead if so.
Advance to the next channel data block pointer.
Jump back to process the next channel.

The first notes to play for each channel have now been determined. A loop is entered that coordinates playing the notes and fetching subsequent notes
when required. Notes across channels may be of different lengths and so the shortest one is determined, the tones for all channels set and then a waiting
delay entered for the shortest note delay. This delay length is then subtracted from all channel note lengths to leave the remaining lengths that each

51

SPECTRUM 128 ROM 0 DISASSEMBLY

note needs to be played for. For the channel with the smallest note length, this will now have completely played and so a new note is fetched for it. The
smallest length of the current notes is then determined again and the process described above repeated. A test is made on each iteration to see if all
channels have run out of data to play, and if so this ends the PLAY command.

L0A97:

L0A9F:

L0AAB:

CALL L0F91
PUSH DE
CALL L0F42
POP DE
LD A,(IY+$10)
CP $FF
JR NZ,L0AAB
CALL L0E93
EI
RET
DEC DE

CALL L0F76
CALL L0FC1
CALL L0F91
JR L0A9F

Find smallest duration length of the current notes across all channels.
Save the smallest duration length.
Play a note on each channel.
DE=The smallest duration length.
Channel bitmap.
Is there anything to play?
Jump if there is.
Turn off all sound and restore IY.
Re-enable interrupts.
End of play command.
DE=Smallest channel duration length, i.e. duration until the next channel state
change.
Perform a wait.
Play a note on each channel and update the channel duration lengths.
Find smallest duration length of the current notes across all channels.
Jump back to see if there is more to process.

PLAY Command Character Table
Recognised characters in PLAY commands.

L0AB7:

DEFM "HZYXWUVMT)(NO!"

Get Play Character
Get the current character from the PLAY string and then increment the character pointer within the string.
Exit: Carry flag set if string has been fully processed.
Carry flag reset if character is available.
A=Character available.

L0AC5:

CALL L0EE3
RET C
INC (IX+$06)
RET NZ
INC (IX+$07)
RET

Get the current character from the play string for this channel.
Return if no more characters.
Increment the low byte of the string pointer.
Return if it has not overflowed.
Else increment the high byte of the string pointer.
Returns with carry flag reset.

Get Next Note in Semitones
Finds the number of semitones above C for the next note in the string,
Entry:
Exit :

IX=Address of the channel data block.
A=Number of semitones above C, or $80 for a rest.

L0AD1:

L0AD4:

L0ADF:

L0AE1:

L0AEC:

PUSH HL
LD C,$00
CALL L0AC5
JR C,L0AE1
CP '&'
JR NZ,L0AEC
LD A,$80
POP HL
RET
LD A,(IY+$21)
OR (IY+$10)
LD (IY+$10),A
JR L0ADF
CP '#'
JR NZ,L0AF3

Save HL.
Default is for a 'natural' note, i.e. no adjustment.
Get the current character from the PLAY string, and advance the position pointer.
Jump if at the end of the string.
$26. Is it a rest?
Jump ahead if not.
Signal that it is a rest.
Restore HL.

Fetch the channel selector.
Clear the channel flag for this string.
Store the new channel bitmap.
Jump back to return.
$23. Is it a sharpen?
Jump ahead if not.

52

L0AF3:

L0AFA:

L0B04:

INC C
JR L0AD4
CP '$'
JR NZ,L0AFA
DEC C
JR L0AD4
BIT 5,A
JR NZ,L0B04
PUSH AF
LD A,$0C
ADD A,C
LD C,A
POP AF
AND $DF
SUB $41
JP C,L0F22
CP $07
JP NC,L0F22
PUSH BC
LD B,$00
LD C,A
LD HL,L0DF9
ADD HL,BC
LD A,(HL)
POP BC
ADD A,C
POP HL
RET

SPECTRUM 128 ROM 0 DISASSEMBLY

Increment by a semitone.
Jump back to get the next character.
$24. Is it a flatten?
Jump ahead if not.
Decrement by a semitone.
Jump back to get the next character.
Is it a lower case letter?
Jump ahead if lower case.
It is an upper case letter so
increase an octave
by adding 12 semitones.

Convert to upper case.
Reduce to range 'A'->0 .. 'G'->6.
Jump if below 'A' to produce error report "k Invalid note name".
Is it 7 or above?
Jump if so to produce error report "k Invalid note name".
C=Number of semitones.

BC holds 0..6 for 'a'..'g'.
Look up the number of semitones above note C for the note.

A=Number of semitones above note C.
C=Number of semitones due to sharpen/flatten characters.
Adjust number of semitones above note C for the sharpen/flatten characters.
Restore HL.

Get Numeric Value from Play String
Get a numeric value from a PLAY string, returning 0 if no numeric value present.
Entry:
Exit :

IX=Address of the channel data block.
BC=Numeric value, or 0 if no numeric value found.

L0B1D:

L0B28:

L0B42:

PUSH HL
PUSH DE
LD L,(IX+$06)
LD H,(IX+$07)
LD DE,$0000
LD A,(HL)
CP '0'
JR C,L0B45
CP ':'
JR NC,L0B45
INC HL
PUSH HL
CALL L0B50
SUB '0'
LD H,$00
LD L,A
ADD HL,DE
JR C,L0B42
EX DE,HL
POP HL
JR L0B28
JP L0F1A

Save registers.

Get the pointer into the PLAY string.

Initialise result to 0.

$30. Is character numeric?
Jump ahead if not.
$3A. Is character numeric?
Jump ahead if not.
Advance to the next character.
Save the pointer into the string.
Multiply result so far by 10.
$30. Convert ASCII digit to numeric value.

HL=Numeric digit value.
Add the numeric value to the result so far.
Jump ahead if an overflow to produce error report "l number too big".
Transfer the result into DE.
Retrieve the pointer into the string.
Loop back to handle any further numeric digits.
Jump to produce error report "l number too big". [Could have saved 1 byte by
directly using JP C,$0F1A (ROM 0) instead of using this JP and the two JR C,$0B42
(ROM 0) instructions that come here]

The end of the numeric value was reached

L0B45:

LD (IX+$06),L
LD (IX+$07),H
PUSH DE

Store the new pointer position into the string.

53

POP BC
POP DE
POP HL
RET

Multiply DE by 10

L0B50:

L0B55:

LD HL,$0000
LD B,$0A
ADD HL,DE
JR C,L0B42
DJNZ L0B55
EX DE,HL
RET

SPECTRUM 128 ROM 0 DISASSEMBLY

Return the result in BC.
Restore registers.

Add DE to HL ten times.

Jump ahead if an overflow to produce error report "l number too big".

Transfer the result into DE.

Find Next Note from Channel String

L0B5C:

L0B69:

CALL L0A3E
JR C,L0B69
CALL L0E93
EI
CALL L05AC
DEFB $14
CALL L0AC5
JP C,L0DA2
CALL L0DF0
LD B,$00
SLA C
LD HL,L0DCA
ADD HL,BC
LD E,(HL)
INC HL
LD D,(HL)
EX DE,HL
CALL L0B84
JR L0B5C

Test for BREAK being pressed.
Jump ahead if not pressed.
Turn off all sound and restore IY.
Re-enable interrupts.
Produce error report. [Could have saved 1 byte by using JP $05D6 (ROM 0)]
"L Break into program"
Get the current character from the PLAY string, and advance the position pointer.
Jump if at the end of the string.
Find the handler routine for the PLAY command character.

Generate the offset into the
command vector table.
HL points to handler routine for this command character.

Fetch the handler routine address.
HL=Handler routine address for this command character.
Make an indirect call to the handler routine.
Jump back to handle the next character in the string.

Comes here after processing a non-numeric digit that does not have a specific command routine handler Hence the next note to play has been determined
and so a return is made to process the other channels.

L0B83:
L0B84:

RET
JP (HL)

Just make a return.
Jump to the command handler routine.

Play Command '!' (Comment)
A comment is enclosed within exclamation marks, e.g. "! A comment !".
Entry:

IX=Address of the channel data block.

L0B85:

CALL L0AC5
JP C,L0DA1
CP '!'
RET Z
JR L0B85

Get the current character from the PLAY string, and advance the position pointer.
Jump if at the end of the string.
$21. Is it the end-of-comment character?
Return if it is.
Jump back to test the next character.

Play Command 'O' (Octave)
The 'O' command is followed by a numeric value within the range 0 to 8, although due to loose range checking the value MOD 256 only needs to be
within 0 to 8. Hence O256 operates the same as O0.
Entry:

IX=Address of the channel data block.

54

L0B90:

CALL L0B1D
LD A,C
CP $09
JP NC,L0F12
SLA A
SLA A
LD B,A
SLA A
ADD A,B
LD (IX+$03),A
RET

SPECTRUM 128 ROM 0 DISASSEMBLY

Get following numeric value from the string into BC.
Is it between 0 and 8?

Jump if above 8 to produce error report "n Out of range".
Multiply A by 12.

Store the octave value.

Play Command 'N' (Separator)
The 'N' command is simply a separator marker and so is ignored.
IX=Address of the channel data block.
Entry:

L0BA5:

RET

Nothing to do so make an immediate return.

Play Command '(' (Start of Repeat)
A phrase can be enclosed within brackets causing it to be repeated, i.e. played twice.
Entry:

IX=Address of the channel data block.

L0BA6:

LD A,(IX+$0B)
INC A
CP $05
JP Z,L0F2A
LD (IX+$0B),A
LD DE,$000C
CALL L0C27
LD A,(IX+$06)
LD (HL),A
INC HL
LD A,(IX+$07)
LD (HL),A
RET

A=Current level of open bracket nesting.
Increment the count.
Only 4 levels supported.
Jump if this is the fifth to produce error report "d Too many brackets".
Store the new open bracket nesting level.
Offset to the bracket level return position stores.
HL=Address of the pointer in which to store the return location of the bracket.
Store the current string position as the return address of the open bracket.

Play Command ')' (End of Repeat)
A phrase can be enclosed within brackets causing it to be repeated, i.e. played twice.
Brackets can also be nested within each other, to 4 levels deep.
If a closing bracket if used without a matching opening bracket then the whole string up until that point is repeated indefinitely.
Entry:

IX=Address of the channel data block.

L0BC2:

LD A,(IX+$16)
LD DE,$0017
OR A
JP M,L0BF0

Fetch the nesting level of closing brackets.
Offset to the closing bracket return address store.
Is there any bracket nesting so far?
Jump if none. [Could have been faster by jumping to $0BF3 (ROM 0)]

Has the bracket level been repeated, i.e. re-reached the same position in the string as the closing bracket return address?

CALL L0C27
LD A,(IX+$06)
CP (HL)
JR NZ,L0BF0
INC HL
LD A,(IX+$07)
CP (HL)
JR NZ,L0BF0

HL=Address of the pointer to the corresponding closing bracket return address store.
Fetch the low byte of the current address.
Re-reached the closing bracket?
Jump ahead if not.
Point to the high byte.
Fetch the high byte address of the current address.
Re-reached the closing bracket?
Jump ahead if not.

55

The bracket level has been repeated. Now check whether this was the outer bracket level.

SPECTRUM 128 ROM 0 DISASSEMBLY

DEC (IX+$16)
LD A,(IX+$16)

OR A
RET P

Decrement the closing bracket nesting level since this level has been repeated.
[There is no need for the LD A,(IX+$16) and OR A instructions since the DEC (IX+
$16) already set the flags]
Reached the outer bracket nesting level?
Return if not the outer bracket nesting level such that the character after the closing
bracket is processed next.

The outer bracket level has been repeated

BIT 0,(IX+$0A)
RET Z

Was this a single closing bracket?
Return if it was not.

The repeat was caused by a single closing bracket so re-initialise the repeat

LD (IX+$16),$00
XOR A
JR L0C0B

Restore one level of closing bracket nesting.
Select closing bracket nesting level 0.
Jump ahead to continue.

A new level of closing bracket nesting

L0BF0:

L0C0B:

LD A,(IX+$16)
INC A
CP $05

JP Z,L0F2A
LD (IX+$16),A
CALL L0C27
LD A,(IX+$06)
LD (HL),A
INC HL
LD A,(IX+$07)
LD (HL),A
LD A,(IX+$0B)
LD DE,$000C
CALL L0C27
LD A,(HL)
LD (IX+$06),A
INC HL
LD A,(HL)
LD (IX+$07),A
DEC (IX+$0B)
RET P

Fetch the nesting level of closing brackets.
Increment the count.
Only 5 levels supported (4 to match up with opening brackets and a 5th to repeat
indefinitely).
Jump if this is the fifth to produce error report "d Too many brackets".
Store the new closing bracket nesting level.
HL=Address of the pointer to the appropriate closing bracket return address store.
Store the current string position as the return address for the closing bracket.

Fetch the nesting level of opening brackets.

HL=Address of the pointer to the opening bracket nesting level return address store.
Set the return address of the nesting level's opening bracket
as new current position within the string.

For a single closing bracket only, this will be the start address of the string.

Decrement level of open bracket nesting.
Return if the closing bracket matched an open bracket.

There is one more closing bracket then opening brackets, i.e. repeat string indefinitely

LD (IX+$0B),$00
SET 0,(IX+$0A)
RET

Set the opening brackets nesting level to 0.
Signal a single closing bracket only, i.e. to repeat the string indefinitely.

Get Address of Bracket Pointer Store

L0C27:

PUSH IX
POP HL
ADD HL,DE
LD B,$00
LD C,A
SLA C
ADD HL,BC
RET

HL=IX.
HL=IX+DE.

HL=IX+DE+2*A.

56

SPECTRUM 128 ROM 0 DISASSEMBLY

Play Command 'T' (Tempo)
A temp command must be specified in the first play string and is followed by a numeric value in the range 60 to 240 representing the number of beats
(crotchets) per minute.
Entry:

IX=Address of the channel data block.

L0C32:

CALL L0B1D
LD A,B
OR A
JP NZ,L0F12
LD A,C
CP $3C
JP C,L0F12
CP $F1
JP NC,L0F12

A holds a value in the range 60 to 240

LD A,(IX+$02)
OR A
RET NZ
LD B,$00
PUSH BC
POP HL
ADD HL,HL
ADD HL,HL
PUSH HL
POP BC

PUSH IY
RST 28H
DEFW STACK_BC
DI
POP IY
PUSH IY
PUSH IY
POP HL
LD BC,$002B
ADD HL,BC
LD IY,$5C3A
PUSH HL
LD HL,L0C76
LD (RETADDR),HL
LD HL,YOUNGER
EX (SP),HL
PUSH HL
JP SWAP

Get following numeric value from the string into BC.

Jump if 256 or above to produce error report "n Out of range".

Jump if 59 or below to produce error report "n Out of range".

Jump if 241 or above to produce error report "n Out of range".

Fetch the channel number.
Tempo 'T' commands have to be specified in the first string.
If it is in a later string then ignore it.
[Redundant instruction - B is already zero]
C=Tempo value.

HL=Tempo*4.

BC=Tempo*4. [Would have been quicker to use the combination LD B,H and LD
C,L]
Save the pointer to the play command data block.

$2D2B. Place the contents of BC onto the stack. The call restores IY to $5C3A.
Interrupts get re-enabled by the call mechanism to ROM 1 so disable them again.
Restore IY to point at the play command data block.
Save the pointer to the play command data block.

HL=pointer to the play command data block.

HL =IY+$002B.
Reset IY to $5C3A since this is required by the floating point calculator.
HL=Points to the calculator RAM routine.

$5B5A. Set up the return address.

Stack the address of the swap routine used when returning to this ROM.
Re-stack the address of the calculator RAM routine.
$5B00. Toggle to other ROM and make a return to the calculator RAM routine.

Tempo Command Return
The calculator stack now holds the value (10/(Tempo*4))/7.33e-6 and this is stored as the tempo value.
The result is used an inner loop counter in the wait routine at $0F76 (ROM 0). Each iteration of this loop takes 26 T-states. The time taken by 26 T-states
is 7.33e-6 seconds. So the total time for the loop to execute is 2.5/TEMPO seconds.

L0C76:

DI
RST 28H
DEFW FP_TO_BC
DI
POP IY
LD (IY+$27),C
LD (IY+$28),B
RET

Interrupts get re-enabled by the call mechanism to ROM 1 so disable them again.

$2DA2. Fetch the value on the top of the calculator stack.
Interrupts get re-enabled by the call mechanism to ROM 1 so disable them again.
Restore IY to point at the play command data block.
Store tempo timing value.

57

SPECTRUM 128 ROM 0 DISASSEMBLY

Play Command 'M' (Mixer)
This command is used to select whether to use tone and/or noise on each of the 3 channels.
It is followed by a numeric value in the range 1 to 63, although due to loose range checking the value MOD 256 only needs to be within 0 to 63. Hence
M256 operates the same as M0.
Entry:

IX=Address of the channel data block.

Get following numeric value from the string into BC.
A=Mixer value.
Is it 64 or above?
Jump if so to produce error report "n Out of range".

L0C84:

CALL L0B1D
LD A,C
CP $40
JP NC,L0F12

Bit 0: 1=Enable channel A tone.
Bit 1: 1=Enable channel B tone.
Bit 2: 1=Enable channel C tone.
Bit 3: 1=Enable channel A noise.
Bit 4: 1=Enable channel B noise.
Bit 5: 1=Enable channel C noise.

CPL

LD E,A
LD D,$07
CALL L0E7C
RET

Invert the bits since the sound generator's mixer register uses active low enable.
This also sets bit 6 1, which selects the I/O port as an output.
E=Mixer value.
D=Register 7 - Mixer.
Write to sound generator register to set the mixer.
[Could have saved 1 byte by using JP $0E7C (ROM 0)]

Play Command 'V' (Volume)
This sets the volume of a channel and is followed by a numeric value in the range 0 (minimum) to 15 (maximum), although due to loose range checking
the value MOD 256 only needs to be within 0 to 15. Hence V256 operates the same as V0.
Entry:

IX=Address of the channel data block.

L0C95:

CALL L0B1D
LD A,C
CP $10
JP NC,L0F12
LD (IX+$04),A

Get following numeric value from the string into BC.

Is it 16 or above?
Jump if so to produce error report "n Out of range".
Store the volume level.

[BUG - An attempt to set the volume for a sound chip channel is now made. However, this routine fails to take into account that it is also called to set the
volume for a MIDI only channel, i.e. play strings 4 to 8. As a result, corruption occurs to various sound generator registers, causing spurious sound output.
There is in fact no need for this routine to set the volume for any channels since this is done every time a new note is played - see routine at $0A97 (ROM
0). the bug fix is to simply to make a return at this point. This routine therefore contains 11 surplus bytes. Credit: Ian Collier (+3), Paul Farrow (128)]

LD E,(IX+$02)
LD A,$08
ADD A,E
LD D,A
LD E,C
CALL L0E7C
RET

E=Channel number.
Offset by 8.
A=8+index.
D=Sound generator register number for the channel.
E=Volume level.
Write to sound generator register to set the volume for the channel.
[Could have saved 1 byte by using JP $0E7C (ROM 0)]

Play Command 'U' (Use Volume Effect)
This command turns on envelope waveform effects for a particular sound chip channel. The volume level is now controlled by the selected envelope
waveform for the channel, as defined by the 'W' command. MIDI channels do not support envelope waveforms and so the routine has the effect of setting
the volume of a MIDI channel to maximum, i.e. 15. It might seem odd that the volume for MIDI channels is set to 15 rather than just filtered out. However,
the three sound chip channels can also drive three MIDI channels and so it would be inconsistent for these MIDI channels to have their volume set to 15
but have the other MIDI channels behave differently. However, it could be argued that all MIDI channels should be unaffected by the 'U' command.
There are no parameters to this command.
Entry:

IX=Address of the channel data block.

58

L0CAD:

LD E,(IX+$02)
LD A,$08
ADD A,E
LD D,A

LD E,$1F

LD (IX+$04),E
RET

SPECTRUM 128 ROM 0 DISASSEMBLY

Get the channel number.
Offset by 8.
A=8+index.
D=Sound generator register number for the channel. [This is not used and so there
is no need to generate it. It was probably a left over from copying and modifying the
'V' command routine. Deleting it would save 7 bytes. Credit: Ian Collier (+3), Paul
Farrow (128)]
E=Select envelope defined by register 13, and reset volume bits to maximum
(though these are not used with the envelope).
Store that the envelope is being used (along with the reset volume level).

Play command 'W' (Volume Effect Specifier)
This command selects the envelope waveform to use and is followed by a numeric value in the range 0 to 7, although due to loose range checking the
value MOD 256 only needs to be within 0 to 7.
Hence W256 operates the same as W0.
Entry:

IX=Address of the channel data block.

L0CBA:

CALL L0B1D
LD A,C
CP $08
JP NC,L0F12
LD B,$00
LD HL,L0DE8
ADD HL,BC
LD A,(HL)
LD (IY+$29),A
RET

Get following numeric value from the string into BC.

Is it 8 or above?
Jump if so to produce error report "n Out of range".

Envelope waveform lookup table.
HL points to the corresponding value in the table.

Store new effect waveform value.

Play Command 'X' (Volume Effect Duration)
This  command  allows  the  duration  of  a  waveform  effect  to  be  specified,  and  is  followed  by  a  numeric  value  in  the  range  0  to  65535.  A  value  of  1
corresponds to the minimum duration, increasing up to 65535 and then maximum duration for a value of 0. If no numeric value is specified then the
maximum duration is used.
Entry:

IX=Address of the channel data block.

L0CCE:

CALL L0B1D
LD D,$0B
LD E,C
CALL L0E7C
INC D
LD E,B
CALL L0E7C
RET

Get following numeric value from the string into BC.
Register 11 - Envelope Period Fine.

Write to sound generator register to set the envelope period (low byte).
Register 12 - Envelope Period Coarse.

Write to sound generator register to set the envelope period (high byte).
[Could have saved 1 byte by using JP $0E7C (ROM 0)]

Play Command 'Y' (MIDI Channel)
This command sets the MIDI channel number that the string is assigned to and is followed by a numeric value in the range 1 to 16, although due to loose
range checking the value MOD 256 only needs to be within 1 to 16.
Hence Y257 operates the same as Y1.
Entry:

IX=Address of the channel data block.

L0CDD:

CALL L0B1D
LD A,C
DEC A
JP M,L0F12
CP $10
JP NC,L0F12
LD (IX+$01),A
RET

Get following numeric value from the string into BC.

Is it 0?
Jump if so to produce error report "n Out of range".
Is it 10 or above?
Jump if so to produce error report "n Out of range".
Store MIDI channel number that this string is assigned to.

59

SPECTRUM 128 ROM 0 DISASSEMBLY

Play Command 'Z' (MIDI Programming Code)
This command is used to send a programming code to the MIDI port. It is followed by a numeric value in the range 0 to 255, although due to loose range
checking the value MOD 256 only needs to be within 0 to 255. Hence Z256 operates the same as Z0.
Entry:

IX=Address of the channel data block.

L0CEE:

CALL L0B1D
LD A,C
CALL L11A3
RET

Get following numeric value from the string into BC.
A=(low byte of) the value.
Write byte to MIDI device.
[Could have saved 1 byte by using JP $0E7C (ROM 0)]

Play Command 'H' (Stop)
This command stops further processing of a play command. It has no parameters.
Entry:

IX=Address of the channel data block.

L0CF6:

LD (IY+$10),$FF
RET

Indicate no channels to play, thereby causing
the play command to terminate.

Play Commands 'a'..'g', 'A'..'G', '1'.."12", '&' and '_'
This handler routine processes commands 'a'..'g', 'A'..'G', '1'.."12", '&' and '_', and determines the length of the next note to play. It provides the handling
of triplet and tied notes.
It stores the note duration in the channel data block's duration length entry, and sets a pointer in the command data block's duration lengths pointer table
to point at it. A single note letter is deemed to be a tied note count of 1. Triplets are deemed a tied note count of at least 2.
Entry:

IX=Address of the channel data block.
A=Current character from play string.

L0CFB:

CALL L0E19
JP C,L0D81

Is the current character a number?
Jump if not number digit.

The character is a number digit

CALL L0DAC
CALL L0DB4

XOR A
LD (IX+$21),A
CALL L0EC8
CALL L0B1D
LD A,C
OR A
JP Z,L0F12
CP $0D
JP NC,L0F12
CP $0A
JR C,L0D32

HL=Address of the duration length within the channel data block.
Store address of duration length in command data block's channel duration length
pointer table.

Set no tied notes.
Get the previous character in the string, the note duration.
Get following numeric value from the string into BC.

Is the value 0?
Jump if so to produce error report "n Out of range".
Is it 13 or above?
Jump if so to produce error report "n Out of range".
Is it below 10?
Jump if so.

It is a triplet semi-quaver (10), triplet quaver (11) or triplet crotchet (12)

L0D28:

CALL L0E00
CALL L0D74
LD (HL),E
INC HL
LD (HL),D
CALL L0D74
INC HL
LD (HL),E
INC HL
LD (HL),D
INC HL

DE=Note duration length for the duration value.
Increment the tied notes counter.
HL=Address of the duration length within the channel data block.

Store the duration length.
Increment the counter of tied notes.

Store the subsequent note duration length in the channel data block.

60

SPECTRUM 128 ROM 0 DISASSEMBLY

JR L0D38

Jump ahead to continue.

The note duration was in the range 1 to 9

L0D32:

L0D38:
L0D3B:

LD (IX+$05),C
CALL L0E00
CALL L0D74
CALL L0EE3
CP '_'
JR NZ,L0D6E
CALL L0AC5
CALL L0B1D
LD A,C
CP $0A
JR C,L0D5F

A triplet note was found as part of a tied note

C=Note duration value (1..9).
DE=Duration length for this duration value.
Increment the tied notes counter.
Get the current character from the play string for this channel.
$5F. Is it a tied note?
Jump ahead if not.
Get the current character from the PLAY string, and advance the position pointer.
Get following numeric value from the string into BC.
Place the value into A.
Is it below 10?
Jump ahead for 1 to 9 (semiquaver ... semibreve).

PUSH HL
PUSH DE
CALL L0E00
POP HL
ADD HL,DE
LD C,E
LD B,D
EX DE,HL
POP HL
LD (HL),E
INC HL
LD (HL),D
LD E,C
LD D,B
JR L0D28

HL=Address of the duration length within the channel data block.
DE=First tied note duration length.
DE=Note duration length for this new duration value.
HL=Current tied note duration length.
HL=Current+new tied note duration lengths.

BC=Note duration length for the duration value.
DE=Current+new tied note duration lengths.
HL=Address of the duration length within the channel data block.

Store the combined note duration length in the channel data block.

DE=Note duration length for the second duration value.
Jump back.

A non-triplet tied note

L0D5F:

LD (IX+$05),C
PUSH HL
PUSH DE
CALL L0E00
POP HL
ADD HL,DE
EX DE,HL
POP HL
JP L0D3B

Store the note duration value.
HL=Address of the duration length within the channel data block.
DE=First tied note duration length.
DE=Note duration length for this new duration value.
HL=Current tied note duration length.
HL=Current+new tied not duration lengths.
DE=Current+new tied not duration lengths.
HL=Address of the duration length within the channel data block.
Jump back to process the next character in case it is also part of a tied note.

The number found was not part of a tied note, so store the duration value

L0D6E:

LD (HL),E
INC HL
LD (HL),D
JP L0D9C

HL=Address of the duration length within the channel data block.
(For triplet notes this could be the address of the subsequent note duration length)
Store the duration length.
Jump forward to make a return.

This subroutine is called to increment the tied notes counter

L0D74:

LD A,(IX+$21)
INC A
CP $0B
JP Z,L0F3A
LD (IX+$21),A
RET

Increment counter of tied notes.

Has it reached 11?
Jump if so to produce to error report "o too many tied notes".
Store the new tied notes counter.

The character is not a number digit so is 'A'..'G', '&' or '_'

61

SPECTRUM 128 ROM 0 DISASSEMBLY

L0D81:

CALL L0EC8
LD (IX+$21),$01

Get the previous character from the string.
Set the number of tied notes to 1.

Store a pointer to the channel data block's duration length into the command data block

CALL L0DAC
CALL L0DB4

LD C,(IX+$05)
PUSH HL
CALL L0E00
POP HL
LD (HL),E
INC HL
LD (HL),D
JP L0D9C
POP HL
INC HL
INC HL
PUSH HL
RET

L0D9C:

HL=Address of the duration length within the channel data block.
Store address of duration length in command data block's channel duration length
pointer table.
C=The duration value of the note (1 to 9).
[Not necessary]
Find the duration length for the note duration value.
[Not necessary]
Store it in the channel data block.

Jump to the instruction below. [Redundant instruction]

Modify the return address to point to the RET instruction at $0B83 (ROM 0).

[Over elaborate when a simple POP followed by RET would have sufficed, saving 3
bytes]

End of String Found
This routine is called when the end of string is found within a comment. It marks the string as having been processed and then returns to the main loop
to process the next string.

L0DA1:

POP HL

Drop the return address of the call to the comment command.

Enter here if the end of the string is found whilst processing a string.

L0DA2:

LD A,(IY+$21)
OR (IY+$10)
LD (IY+$10),A
RET

Fetch the channel selector.
Clear the channel flag for this string.
Store the new channel bitmap.

Point to Duration Length within Channel Data Block

L0DAC:

PUSH IX
POP HL
LD BC,$0022
ADD HL,BC
RET

HL=Address of the channel data block.

HL=Address of the store for the duration length.

Store Entry in Command Data Block's Channel Duration Length Pointer Table

L0DB4:

PUSH HL
PUSH IY
POP HL
LD BC,$0011
ADD HL,BC

LD B,$00
LD C,(IX+$02)
SLA C
ADD HL,BC

POP DE

Save the address of the duration length within the channel data block.

HL=Address of the command data block.

HL=Address within the command data block of the channel duration length pointer
table.

BC=Channel number.
BC=2*Index number.
HL=Address within the command data block of the pointer to the current channel's
data block duration length.
DE=Address of the duration length within the channel data block.

62

SPECTRUM 128 ROM 0 DISASSEMBLY

Store the pointer to the channel duration length in the command data block's
channel duration pointer table.

LD (HL),E

INC HL
LD (HL),D
EX DE,HL
RET

PLAY Command Jump Table
Handler routine jump table for all PLAY commands.

L0DCA:

DEFW L0CFB
DEFW L0B85
DEFW L0B90
DEFW L0BA5
DEFW L0BA6
DEFW L0BC2
DEFW L0C32
DEFW L0C84
DEFW L0C95
DEFW L0CAD
DEFW L0CBA
DEFW L0CCE
DEFW L0CDD
DEFW L0CEE
DEFW L0CF6

Command handler routine for all other characters.
'!' command handler routine.
'O' command handler routine.
'N' command handler routine.
'(' command handler routine.
')' command handler routine.
'T' command handler routine.
'M' command handler routine.
'V' command handler routine.
'U' command handler routine.
'W' command handler routine.
'X' command handler routine.
'Y' command handler routine.
'Z' command handler routine.
'H' command handler routine.

Envelope Waveform Lookup Table
Table used by the play 'W' command to find the corresponding envelope value to write to the sound generator envelope shape register (register 13). This
filters out the two duplicate waveforms possible from the sound generator and allows the order of the waveforms to be arranged in a more logical fashion.

L0DE8:

DEFB $00
DEFB $04
DEFB $0B
DEFB $0D
DEFB $08
DEFB $0C
DEFB $0E
DEFB $0A

W0 - Single decay then off. (Continue off, attack off, alternate off, hold off)
W1 - Single attack then off. (Continue off, attack on, alternate off, hold off)
W2 - Single decay then hold. (Continue on, attack off, alternate on, hold on)
W3 - Single attack then hold. (Continue on, attack on, alternate off, hold on)
W4 - Repeated decay. (Continue on, attack off, alternate off, hold off)
W5 - Repeated attack. (Continue on, attack on, alternate off, hold off)
W6 - Repeated attack-decay. (Continue on, attack on, alternate on, hold off)
W7 - Repeated decay-attack. (Continue on, attack off, alternate on, hold off)

Identify Command Character
This routines attempts to match the command character to those in a table.
The index position of the match indicates which command handler routine is required to process the character. Note that commands are case sensitive.
Entry:
Exit :

A=Command character.
Zero flag set if a match was found.
BC=Indentifying the character matched, 1 to 15 for match and 0 for no match.

L0DF0:

LD BC,$000F
LD HL,L0AB7
CPIR
RET

Number of characters + 1 in command table.
Start of command table.
Search for a match.

Semitones Table
This table contains an entry for each note of the scale, A to G, and is the number of semitones above the note C.

L0DF9:

DEFB $09
DEFB $0B
DEFB $00

'A'
'B'
'C'

63

SPECTRUM 128 ROM 0 DISASSEMBLY

DEFB $02
DEFB $04
DEFB $05
DEFB $07

'D'
'E'
'F'
'G'

Find Note Duration Length

L0E00:

PUSH HL
LD B,$00
LD HL,L0E0C
ADD HL,BC
LD D,$00
LD E,(HL)
POP HL
RET

Save HL.

Note duration table.
Index into the table.

Fetch the length from the table.
Restore HL.

Note Duration Table
A whole note is given by a value of 96d and other notes defined in relation to this.
The value of 96d is the lowest common denominator from which all note durations can be defined.

L0E0C:

DEFB $80
DEFB $06
DEFB $09
DEFB $0C
DEFB $12
DEFB $18
DEFB $24
DEFB $30
DEFB $48
DEFB $60
DEFB $04
DEFB $08
DEFB $10

Rest [Not used since table is always indexed into with a value of 1 or more]
Semi-quaver (sixteenth note).
Dotted semi-quaver (3/32th note).
Quaver (eighth note).
Dotted quaver (3/16th note).
Crotchet (quarter note).
Dotted crotchet (3/8th note).
Minim (half note).
Dotted minim (3/4th note).
Semi-breve (whole note).
Triplet semi-quaver (1/24th note).
Triplet quaver (1/12th note).
Triplet crochet (1/6th note).

Is Numeric Digit?
Tests whether a character is a number digit.
Entry:
Exit :

A=Character.
Carry flag reset if a number digit.

L0E19:

CP '0'
RET C
CP ':'
CCF
RET

$30. Is it '0' or less?
Return with carry flag set if so.
$3A. Is it more than '9'?

Return with carry flag set if so.

Play a Note On a Sound Chip Channel
This routine plays the note at the current octave and current volume on a sound chip channel. For play strings 4 to 8, it simply stores the note number
and this is subsequently played later.
Entry:

IX=Address of the channel data block.
A=Note value as number of semitones above C (0..11).

L0E20:

LD C,A
LD A,(IX+$03)
ADD A,C
CP $80
JP NC,L0F32
LD C,A

C=The note value.
Octave number * 12.
Add the octave number and the note value to form the note number.
Is note within range?
Jump if not to produce error report "m Note out of range".
C=Note number.

64

SPECTRUM 128 ROM 0 DISASSEMBLY

LD A,(IX+$02)
OR A
JR NZ,L0E3F

Get the channel number.
Is it the first channel?
Jump ahead if not.

Only set the noise generator frequency on the first channel

LD A,C
CPL
AND $7F
SRL A
SRL A
LD D,$06
LD E,A
CALL L0E7C
LD (IX+$00),C
LD A,(IX+$02)
CP $03
RET NC

L0E3F:

Channel 0, 1 or 2

A=Note number (0..107), in ascending audio frequency.
Invert since noise register value is in descending audio frequency.
Mask off bit 7.

Divide by 4 to reduce range to 0..31.
Register 6 - Noise pitch.

Write to sound generator register.
Store the note number.
Get the channel number.
Is it channel 0, 1 or 2, i.e. a sound chip channel?
Do not output anything for play strings 4 to 8.

LD HL,L1096
LD B,$00
LD A,C
SUB $15
JR NC,L0E57
LD DE,$0FBF
JR L0E5E

Start of note lookup table.
BC=Note number.
A=Note number.
A=Note number - 21.
Jump if note number was 21 or above.
Note numbers $00 to $14 use the lowest note value.
[Could have saved 4 bytes by using XOR A and dropping through to $0E57 (ROM
0)]

Note number 21 to 107 (range 0 to 86)

L0E57:

L0E5E:

LD C,A
SLA C
ADD HL,BC
LD E,(HL)
INC HL
LD D,(HL)
EX DE,HL
LD D,(IX+$02)
SLA D

LD E,L
CALL L0E7C
INC D
LD E,H
CALL L0E7C
BIT 4,(IX+$04)
RET Z
LD D,$0D
LD A,(IY+$29)
LD E,A
CALL L0E7C
RET

Generate offset into the table.
Point to the entry in the table.

DE=Word to write to the sound chip registers to produce this note.
HL=Register word value to produce the note.
Get the channel number.
D=2*Channel number, to give the tone channel register (fine control) number 0, 2, or
4.
E=The low value byte.
Write to sound generator register.
D=Tone channel register (coarse control) number 1, 3, or 5.
E=The high value byte.
Write to sound generator register.
Is the envelope waveform being used?
Return if it is not.
Register 13 - Envelope Shape.
Get the effect waveform value.

Write to sound generator register.
[Could have saved 4 bytes by dropping down into the routine below.]

Set Sound Generator Register

L0E7C:

PUSH BC
LD BC,$FFFD
OUT (C),D
LD BC,$BFFD
OUT (C),E
POP BC

Select the register.

Write out the value.

65

SPECTRUM 128 ROM 0 DISASSEMBLY

RET

Read Sound Generator Register

L0E89:

PUSH BC
LD BC,$FFFD
OUT (C),A
IN A,(C)
POP BC
RET

Turn Off All Sound

L0E93:

LD D,$07
LD E,$FF
CALL L0E7C

Turn off the sound from the AY-3-8912

Select the register.
Read the register's value.

Register 7 - Mixer.
I/O ports are inputs, noise output off, tone output off.
Write to sound generator register.

LD D,$08
LD E,$00
CALL L0E7C
INC D
CALL L0E7C
INC D
CALL L0E7C
CALL L0A4F

Register 8 - Channel A volume.
Volume of 0.
Write to sound generator register to set the volume to 0.
Register 9 - Channel B volume.
Write to sound generator register to set the volume to 0.
Register 10 - Channel C volume.
Write to sound generator register to set the volume to 0.
Select channel data block pointers.

Now reset all MIDI channels in use

L0EAC:

L0EB8:

L0EC3:

RR (IY+$22)
JR C,L0EB8
CALL L0A67
CALL L118D
SLA (IY+$21)
JR C,L0EC3
CALL L0A6E
JR L0EAC
LD IY,$5C3A
RET

Working copy of channel bitmap. Test if next string present.
Jump ahead if there is no string for this channel.
Get address of channel data block for the current string into IX.
Turn off the MIDI channel sound assigned to this play string.
Have all channels been processed?
Jump ahead if so.
Advance to the next channel data block pointer.
Jump back to process the next channel.
Restore IY.

Get Previous Character from Play String
Get the previous character from the PLAY string, skipping over spaces and 'Enter' characters.
Entry:

IX=Address of the channel data block.

L0EC8:

L0ED0:

PUSH HL
PUSH DE
LD L,(IX+$06)
LD H,(IX+$07)
DEC HL
LD A,(HL)
CP ' '
JR Z,L0ED0
CP $0D
JR Z,L0ED0
LD (IX+$06),L
LD (IX+$07),H
POP DE
POP HL

Save registers.

Get the current pointer into the PLAY string.

Point to previous character.
Fetch the character.
$20. Is it a space?
Jump back if a space.
Is it an 'Enter'?
Jump back if an 'Enter'.
Store this as the new current pointer into the PLAY string.

Restore registers.

66

SPECTRUM 128 ROM 0 DISASSEMBLY

RET

Get Current Character from Play String
Get the current character from the PLAY string, skipping over spaces and 'Enter' characters.
Exit: Carry flag set if string has been fully processed.
Carry flag reset if character is available.
A=Character available.

L0EE3:

L0EEC:

L0EFB:

L0F05:

L0F09:

PUSH HL
PUSH DE
PUSH BC
LD L,(IX+$06)
LD H,(IX+$07)
LD A,H
CP (IX+$09)
JR NZ,L0EFB
LD A,L
CP (IX+$08)
JR NZ,L0EFB
SCF
JR L0F05
LD A,(HL)
CP ' '
JR Z,L0F09
CP $0D
JR Z,L0F09
OR A
POP BC
POP DE
POP HL
RET
INC HL
LD (IX+$06),L
LD (IX+$07),H
JR L0EEC

Save registers.

HL=Pointer to next character to process within the PLAY string.

Reached end-of-string address high byte?
Jump forward if not.

Reached end-of-string address low byte?
Jump forward if not.
Indicate string all processed.
Jump forward to return.
Get the next play character.
$20. Is it a space?
Ignore the space by jumping ahead to process the next character.
Is it 'Enter'?
Ignore the 'Enter' by jumping ahead to process the next character.
Clear the carry flag to indicate a new character has been returned.
Restore registers.

Point to the next character.

Update the pointer to the next character to process with the PLAY string.
Jump back to get the next character.

Produce Play Error Reports

L0F12:

L0F1A:

L0F22:

L0F2A:

L0F32:

L0F3A:

CALL L0E93
EI
CALL L05AC
DEFB $29
CALL L0E93
EI
CALL L05AC
DEFB $27
CALL L0E93
EI
CALL L05AC
DEFB $26
CALL L0E93
EI
CALL L05AC
DEFB $1F
CALL L0E93
EI
CALL L05AC
DEFB $28
CALL L0E93
EI
CALL L05AC
DEFB $2A

Turn off all sound and restore IY.

Produce error report.
"n Out of range"
Turn off all sound and restore IY.

Produce error report.
"l Number too big"
Turn off all sound and restore IY.

Produce error report.
"k Invalid note name"
Turn off all sound and restore IY.

Produce error report.
"d Too many brackets"
Turn off all sound and restore IY.

Produce error report.
"m Note out of range"
Turn off all sound and restore IY.

Produce error report.
"o Too many tied notes"

67

SPECTRUM 128 ROM 0 DISASSEMBLY

Play Note on Each Channel
Play a note and set the volume on each channel for which a play string exists.

L0F42:
L0F45:

CALL L0A4F
RR (IY+$22)
JR C,L0F6C
CALL L0A67
CALL L0AD1
CP $80
JR Z,L0F6C
CALL L0E20
LD A,(IX+$02)
CP $03
JR NC,L0F69

Select channel data block pointers.
Working copy of channel bitmap. Test if next string present.
Jump ahead if there is no string for this channel.
Get address of channel data block for the current string into IX.
Get the next note in the string as number of semitones above note C.
Is it a rest?
Jump ahead if so and do nothing to the channel.
Play the note if a sound chip channel.
Get channel number.
Is it channel 0, 1 or 2, i.e. a sound chip channel?
Jump if not to skip setting the volume.

One of the 3 sound chip generator channels so set the channel's volume for the new note

LD D,$08
ADD A,D
LD D,A
LD E,(IX+$04)
CALL L0E7C
CALL L116E
SLA (IY+$21)
RET C
CALL L0A6E
JR L0F45

L0F69:
L0F6C:

A=0 to 2.
D=Register (8 + string index), i.e. channel A, B or C volume register.
E=Volume for the current channel.
Write to sound generator register to set the output volume.
Play a note and set the volume on the assigned MIDI channel.
Have all channels been processed?
Return if so.
Advance to the next channel data block pointer.
Jump back to process the next channel.

Wait Note Duration
This routine is the main timing control of the PLAY command.
It waits for the specified length of time, which will be the lowest note duration of all active channels.
The actual duration of the wait is dictated by the current tempo.
Entry:

DE=Note duration, where 96d represents a whole note.

Enter a loop waiting for (135+ ((26*(tempo-100))-5) )*DE+5 T-states

L0F76:

PUSH HL
LD L,(IY+$27)
LD H,(IY+$28)
LD BC,$0064
OR A
SBC HL,BC
PUSH HL
POP BC
POP HL

(11) Save HL.
(19) Get the tempo timing value.
(19)
(10) BC=100
(4)
(15) HL=tempo timing value - 100.
(11)
(10) BC=tempo timing value - 100.
(10) Restore HL.

Tempo timing value = (10/(TEMPO*4))/7.33e-6, where 7.33e-6 is the time for 26 T-states.
The loop below takes 26 T-states per iteration, where the number of iterations is given by the tempo timing value.
So the time for the loop to execute is 2.5/TEMPO seconds.
For a TEMPO of 60 beats (crotchets) per second, the time per crotchet is 1/24 second.
The duration of a crotchet is defined as 24 from the table at $0E0C, therefore the loop will get executed 24 times and hence the total time taken will
be 1 second.
The tempo timing value above has 100 subtracted from it, presumably to approximately compensate for the overhead time previously taken to prepare
the notes for playing. This reduces the total time by 2600 T-states, or 733us.

L0F86:

DEC BC
LD A,B
OR C
JR NZ,L0F86
DEC DE
LD A,D
OR E

(6) Wait for tempo-100 loops.
(4)
(4)
(12/7)
(6) Repeat DE times
(4)
(4)

68

SPECTRUM 128 ROM 0 DISASSEMBLY

JR NZ,L0F76
RET

(12/7)
(10)

Find Smallest Duration Length
This routine finds the smallest duration length for all current notes being played across all channels.
Exit: DE=Smallest duration length.

L0F91:

L0F97:

LD DE,$FFFF
CALL L0A4A
RR (IY+$22)
JR C,L0FAF

Set smallest duration length to 'maximum'.
Select channel data block duration pointers.
Working copy of channel bitmap. Test if next string present.
Jump ahead if there is no string for this channel.

HL=Address of channel data pointer. DE holds the smallest duration length found so far.

PUSH DE
LD E,(HL)
INC HL
LD D,(HL)
EX DE,HL
LD E,(HL)
INC HL
LD D,(HL)
PUSH DE
POP HL
POP BC
OR A
SBC HL,BC
JR C,L0FAF

Save the smallest duration length.

DE=Channel data block duration length.

DE=Channel duration length.

HL=Channel duration length.
Last channel duration length.

Is current channel's duration length smaller than the smallest so far?
Jump ahead if so, with the new smallest value in DE.

The current channel's duration was not smaller so restore the last smallest into DE.

L0FAF:

L0FBA:

PUSH BC
POP DE
SLA (IY+$21)
JR C,L0FBA
CALL L0A6E
JR L0F97
LD (IY+$25),E
LD (IY+$26),D
RET

DE=Smallest duration length.
Have all channel strings been processed?
Jump ahead if so.
Advance to the next channel data block duration pointer.
Jump back to process the next channel.

Store the smallest channel duration length.

Play a Note on Each Channel and Update Channel Duration Lengths
This routine is used to play a note and set the volume on all channels.
It subtracts an amount of time from the duration lengths of all currently playing channel note durations. The amount subtracted is equivalent to the smallest
note duration length currently being played, and as determined earlier.
Hence one channel's duration will go to 0 on each call of this routine, and the others will show the remaining lengths of their corresponding notes.
Entry:

IY=Address of the command data block.

L0FC1:

L0FC8:

XOR A
LD (IY+$2A),A
CALL L0A4F
RR (IY+$22)
JP C,L105A
CALL L0A67
PUSH IY
POP HL
LD BC,$0011
ADD HL,BC
LD B,$00
LD C,(IX+$02)
SLA C

Holds a temporary channel bitmap.
Select channel data block pointers.
Working copy of channel bitmap. Test if next string present.
Jump ahead if there is no string for this channel.
Get address of channel data block for the current string into IX.

HL=Address of the command data block.

HL=Address of channel data block duration pointers.

BC=Channel number.
BC=2*Channel number.

69

ADD HL,BC
LD E,(HL)
INC HL
LD D,(HL)
EX DE,HL
PUSH HL
LD E,(HL)
INC HL
LD D,(HL)
EX DE,HL
LD E,(IY+$25)
LD D,(IY+$26)
OR A
SBC HL,DE
EX DE,HL
POP HL
JR Z,L0FFC
LD (HL),E
INC HL
LD (HL),D
JR L105A

SPECTRUM 128 ROM 0 DISASSEMBLY

HL=Address of channel data block duration pointer for this channel.

DE=Address of duration length within the channel data block.
HL=Address of duration length within the channel data block.
Save it.

DE=Duration length for this channel.
HL=Duration length for this channel.

DE=Smallest duration length of all current channel notes.

HL=Duration length - smallest duration length.
DE=Duration length - smallest duration length.
HL=Address of duration length within the channel data block.
Jump if this channel uses the smallest found duration length.

Update the duration length for this channel with the remaining length.

Jump ahead to update the next channel.

The current channel uses the smallest found duration length
[A note has been completed and so the channel volume is set to 0 prior to the next note being played. This occurs on both sound chip channels and MIDI
channels. When a MIDI channel is assigned to more than one play string and a rest is used in one of those strings. As soon as the end of the rest period
is encountered, the channel's volume is set to off even though one of the other play strings controlling the MIDI channel may still be playing. This can
be seen using the command PLAY "Y1a&", "Y1N9a". Here, string 1 starts playing 'a' for the period of a crotchet (1/4 of a note), where as string 2 starts
playing 'a' for nine periods of a crotchet (9/4 of a note). When string 1 completes its crotchet, it requests to play a period of silence via the rest '&'. This
turns the volume of the MIDI channel off even though string 2 is still timing its way through its nine crotchets. The play command will therefore continue
for a further seven crotchets but in silence. This is because the volume for note is set only at its start and no coordination occurs between strings to turn
the volume back on for the second string. It is arguably what the correct behaviour should be in such a circumstance where the strings are providing
conflicting instructions, but having the latest command or note take precedence seems a logical approach. Credit: Ian Collier (+3), Paul Farrow (128)]

L0FFC:

L100C:

LD A,(IX+$02)
CP $03
JR NC,L100C
LD D,$08
ADD A,D
LD D,A
LD E,$00
CALL L0E7C
CALL L118D
PUSH IX
POP HL
LD BC,$0021
ADD HL,BC
DEC (HL)
JR NZ,L1026
CALL L0B5C
LD A,(IY+$21)
AND (IY+$10)
JR NZ,L105A
JR L103D

The channel has more tied notes

L1026:

PUSH IY
POP HL
LD BC,$0011
ADD HL,BC
LD B,$00
LD C,(IX+$02)
SLA C
ADD HL,BC
LD E,(HL)
INC HL

Get the channel number.
Is it channel 0, 1 or 2, i.e. a sound chip channel?
Jump ahead if not a sound generator channel.

D=Register (8+channel number) - Channel volume.
E=Volume level of 0.
Write to sound generator register to turn the volume off.
Turn off the assigned MIDI channel sound.

HL=Address of channel data block.

HL=Points to the tied notes counter.
Decrement the tied notes counter. [This contains a value of 1 for a single note]
Jump ahead if there are more tied notes.
Find the next note to play for this channel from its play string.
Fetch the channel selector.
Test whether this channel has further data in its play string.
Jump to process the next channel if this channel does not have a play string.
The channel has more data in its play string so jump ahead.

HL=Address of the command data block.

HL=Address of channel data block duration pointers.

BC=Channel number.
BC=2*Channel number.
HL=Address of channel data block duration pointer for this channel.

70

L103D:

LD D,(HL)
INC DE
INC DE
LD (HL),D
DEC HL
LD (HL),E
CALL L0AD1
LD C,A
LD A,(IY+$21)
AND (IY+$10)
JR NZ,L105A
LD A,C
CP $80
JR Z,L105A
CALL L0E20

LD A,(IY+$21)
OR (IY+$2A)

LD (IY+$2A),A

SPECTRUM 128 ROM 0 DISASSEMBLY

DE=Address of duration length within the channel data block.

Point to the subsequent note duration length.

Store the new duration length.
Get next note in the string as number of semitones above note C.
C=Number of semitones.
Fetch the channel selector.
Test whether this channel has a play string.
Jump to process the next channel if this channel does not have a play string.
A=Number of semitones.
Is it a rest?
Jump to process the next channel if it is.
Play the new note on this channel at the current volume if a sound chip channel, or
simply store the note for play strings 4 to 8.
Fetch the channel selector.
Insert a bit in the temporary channel bitmap to indicate this channel has more to
play.
Store it.

Check whether another channel needs its duration length updated

L105A:

SLA (IY+$21)
JR C,L1066
CALL L0A6E
JP L0FC8

Have all channel strings been processed?
Jump ahead if so.
Advance to the next channel data pointer.
Jump back to update the duration length for the next channel.

[BUG - By this point, the volume for both sound chip and MIDI channels has been set to 0, i.e. off. So although the new notes have been set playing on
the sound chip channels, no sound is audible. For MIDI channels, no new notes have yet been output and hence these are also silent. If the time from
turning the volume off for the current note to the time to turn the volume on for the next note is short enough, then it will not be noticeable. However, the
code at $1066 (ROM 0) introduces a 1/96th of a note delay and as a result a 1/96th of a note period of silence between notes. The bug can be resolved
by simply deleting the two instructions below that introduce the delay. A positive side effect of the bug in the 'V' volume command at $0C95 (ROM 0) is
that it can be used to overcome the gaps of silence between notes for sound chip channels. By interspersing volume commands between notes, a new
volume level is immediately set before the 1/96th of a note delay is introduced for the new note. Therefore, the delay occurs when the new note is audible
instead of when it is silent. For example, PLAY "cV15cV15c" instead of PLAY "ccc". The note durations are still 1/96th of a note longer than they should
be though. This technique will only work on the sound chip channels and not for any MIDI channels. Credit: Ian Collier (+3), Paul Farrow (128)]

L1066:

LD DE,$0001
CALL L0F76
CALL L0A4F

Delay for 1/96th of a note.

Select channel data block pointers.

All channel durations have been updated. Update the volume on each sound chip channel, and the volume and note on each MIDI channel

L106F:

L1089:
L108C:

RR (IY+$2A)
JR NC,L108C
CALL L0A67
LD A,(IX+$02)
CP $03
JR NC,L1089
LD D,$08
ADD A,D
LD D,A
LD E,(IX+$04)
CALL L0E7C
CALL L116E
SLA (IY+$21)
RET C
CALL L0A6E
JR L106F

Temporary channel bitmap. Test if next string present.
Jump ahead if there is no string for this channel.
Get address of channel data block for the current string into IX.
Get the channel number.
Is it channel 0, 1 or 2, i.e. a sound chip channel?
Jump ahead if so to process the next channel.

D=Register (8+channel number) - Channel volume.
Get the current volume.
Write to sound generator register to set the volume of the channel.
Play a note and set the volume on the assigned MIDI channel.
Have all channels been processed?
Return if so.
Advance to the next channel data pointer.
Jump back to process the next channel.

Note Lookup Table
Each word gives the value of the sound generator tone registers for a given note.

71

SPECTRUM 128 ROM 0 DISASSEMBLY

There are 9 octaves, containing a total of 108 notes. These represent notes 21 to 128. Notes 0 to 20 cannot be reproduced on the sound chip and so
note 21 will be used for all of these (they will however be sent to a MIDI device if one is assigned to a channel). [Note that both the sound chip and the
MIDI port can not play note 128 and so its inclusion in the table is a waste of 2 bytes]. The PLAY command does not allow octaves higher than 8 to
be selected directly. Using PLAY "O8G" will select note 115. To select higher notes, sharps must be included, e.g. PLAY "O8#G" for note 116, PLAY
"O8##G" for note 117, etc, up to PLAY "O8############G" for note 127. Attempting to access note 128 using PLAY "O8#############G" will lead
to error report "m Note out of range".

L1096:

DEFW $0FBF
DEFW $0EDC
DEFW $0E07
DEFW $0D3D
DEFW $0C7F
DEFW $0BCC
DEFW $0B22
DEFW $0A82
DEFW $09EB
DEFW $095D
DEFW $08D6
DEFW $0857
DEFW $07DF
DEFW $076E
DEFW $0703
DEFW $069F
DEFW $0640
DEFW $05E6
DEFW $0591
DEFW $0541
DEFW $04F6
DEFW $04AE
DEFW $046B
DEFW $042C
DEFW $03F0
DEFW $03B7
DEFW $0382
DEFW $034F
DEFW $0320
DEFW $02F3
DEFW $02C8
DEFW $02A1
DEFW $027B
DEFW $0257
DEFW $0236
DEFW $0216
DEFW $01F8
DEFW $01DC
DEFW $01C1
DEFW $01A8
DEFW $0190
DEFW $0179
DEFW $0164
DEFW $0150
DEFW $013D
DEFW $012C
DEFW $011B
DEFW $010B
DEFW $00FC
DEFW $00EE
DEFW $00E0
DEFW $00D4
DEFW $00C8
DEFW $00BD
DEFW $00B2
DEFW $00A8
DEFW $009F
DEFW $0096
DEFW $008D
DEFW $0085

Octave 1, Note 21 - A (27.50 Hz, Ideal=27.50 Hz, Error=-0.01%) C0
Octave 1, Note 22 - A# (29.14 Hz, Ideal=29.16 Hz, Error=-0.08%)
Octave 1, Note 23 - B (30.87 Hz, Ideal=30.87 Hz, Error=-0.00%)
Octave 2, Note 24 - C (32.71 Hz, Ideal=32.70 Hz, Error=+0.01%) C1
Octave 2, Note 25 - C# (34.65 Hz, Ideal=34.65 Hz, Error=-0.00%)
Octave 2, Note 26 - D (36.70 Hz, Ideal=36.71 Hz, Error=-0.01%)
Octave 2, Note 27 - D# (38.89 Hz, Ideal=38.89 Hz, Error=+0.01%)
Octave 2, Note 28 - E (41.20 Hz, Ideal=41.20 Hz, Error=+0.00%)
Octave 2, Note 29 - F (43.66 Hz, Ideal=43.65 Hz, Error=+0.00%)
Octave 2, Note 30 - F# (46.24 Hz, Ideal=46.25 Hz, Error=-0.02%)
Octave 2, Note 31 - G (49.00 Hz, Ideal=49.00 Hz, Error=+0.00%)
Octave 2, Note 32 - G# (51.92 Hz, Ideal=51.91 Hz, Error=+0.01%)
Octave 2, Note 33 - A (55.01 Hz, Ideal=55.00 Hz, Error=+0.01%)
Octave 2, Note 34 - A# (58.28 Hz, Ideal=58.33 Hz, Error=-0.08%)
Octave 2, Note 35 - B (61.75 Hz, Ideal=61.74 Hz, Error=+0.02%)
Octave 3, Note 36 - C ( 65.39 Hz, Ideal= 65.41 Hz, Error=-0.02%) C2
Octave 3, Note 37 - C# ( 69.28 Hz, Ideal= 69.30 Hz, Error=-0.04%)
Octave 3, Note 38 - D ( 73.40 Hz, Ideal= 73.42 Hz, Error=-0.01%)
Octave 3, Note 39 - D# ( 77.78 Hz, Ideal= 77.78 Hz, Error=+0.01%)
Octave 3, Note 40 - E ( 82.41 Hz, Ideal= 82.41 Hz, Error=+0.00%)
Octave 3, Note 41 - F ( 87.28 Hz, Ideal= 87.31 Hz, Error=-0.04%)
Octave 3, Note 42 - F# ( 92.52 Hz, Ideal= 92.50 Hz, Error=+0.02%)
Octave 3, Note 43 - G ( 98.00 Hz, Ideal= 98.00 Hz, Error=+0.00%)
Octave 3, Note 44 - G# (103.78 Hz, Ideal=103.83 Hz, Error=-0.04%)
Octave 3, Note 45 - A (109.96 Hz, Ideal=110.00 Hz, Error=-0.04%)
Octave 3, Note 46 - A# (116.55 Hz, Ideal=116.65 Hz, Error=-0.08%)
Octave 3, Note 47 - B (123.43 Hz, Ideal=123.47 Hz, Error=-0.03%)
Octave 4, Note 48 - C (130.86 Hz, Ideal=130.82 Hz, Error=+0.04%) C3
Octave 4, Note 49 - C# (138.55 Hz, Ideal=138.60 Hz, Error=-0.04%)
Octave 4, Note 50 - D (146.81 Hz, Ideal=146.83 Hz, Error=-0.01%)
Octave 4, Note 51 - D# (155.68 Hz, Ideal=155.55 Hz, Error=+0.08%)
Octave 4, Note 52 - E (164.70 Hz, Ideal=164.82 Hz, Error=-0.07%)
Octave 4, Note 53 - F (174.55 Hz, Ideal=174.62 Hz, Error=-0.04%)
Octave 4, Note 54 - F# (185.04 Hz, Ideal=185.00 Hz, Error=+0.02%)
Octave 4, Note 55 - G (195.83 Hz, Ideal=196.00 Hz, Error=-0.09%)
Octave 4, Note 56 - G# (207.57 Hz, Ideal=207.65 Hz, Error=-0.04%)
Octave 4, Note 57 - A (219.92 Hz, Ideal=220.00 Hz, Error=-0.04%)
Octave 4, Note 58 - A# (232.86 Hz, Ideal=233.30 Hz, Error=-0.19%)
Octave 4, Note 59 - B (246.86 Hz, Ideal=246.94 Hz, Error=-0.03%)
Octave 5, Note 60 - C (261.42 Hz, Ideal=261.63 Hz, Error=-0.08%) C4 Middle C
Octave 5, Note 61 - C# (277.10 Hz, Ideal=277.20 Hz, Error=-0.04%)
Octave 5, Note 62 - D (294.01 Hz, Ideal=293.66 Hz, Error=+0.12%)
Octave 5, Note 63 - D# (311.35 Hz, Ideal=311.10 Hz, Error=+0.08%)
Octave 5, Note 64 - E (329.88 Hz, Ideal=329.63 Hz, Error=+0.08%)
Octave 5, Note 65 - F (349.65 Hz, Ideal=349.23 Hz, Error=+0.12%)
Octave 5, Note 66 - F# (369.47 Hz, Ideal=370.00 Hz, Error=-0.14%)
Octave 5, Note 67 - G (391.66 Hz, Ideal=392.00 Hz, Error=-0.09%)
Octave 5, Note 68 - G# (415.13 Hz, Ideal=415.30 Hz, Error=-0.04%)
Octave 5, Note 69 - A (439.84 Hz, Ideal=440.00 Hz, Error=-0.04%)
Octave 5, Note 70 - A# (465.72 Hz, Ideal=466.60 Hz, Error=-0.19%)
Octave 5, Note 71 - B (494.82 Hz, Ideal=493.88 Hz, Error=+0.19%)
Octave 6, Note 72 - C (522.83 Hz, Ideal=523.26 Hz, Error=-0.08%) C5
Octave 6, Note 73 - C# (554.20 Hz, Ideal=554.40 Hz, Error=-0.04%)
Octave 6, Note 74 - D (586.46 Hz, Ideal=587.32 Hz, Error=-0.15%)
Octave 6, Note 75 - D# (622.70 Hz, Ideal=622.20 Hz, Error=+0.08%)
Octave 6, Note 76 - E (659.77 Hz, Ideal=659.26 Hz, Error=+0.08%)
Octave 6, Note 77 - F (697.11 Hz, Ideal=698.46 Hz, Error=-0.19%)
Octave 6, Note 78 - F# (738.94 Hz, Ideal=740.00 Hz, Error=-0.14%)
Octave 6, Note 79 - G (786.10 Hz, Ideal=784.00 Hz, Error=+0.27%)
Octave 6, Note 80 - G# (833.39 Hz, Ideal=830.60 Hz, Error=+0.34%)

72

DEFW $007E
DEFW $0077
DEFW $0070
DEFW $006A
DEFW $0064
DEFW $005E
DEFW $0059
DEFW $0054
DEFW $004F
DEFW $004B
DEFW $0047
DEFW $0043
DEFW $003F
DEFW $003B
DEFW $0038
DEFW $0035
DEFW $0032
DEFW $002F
DEFW $002D
DEFW $002A
DEFW $0028
DEFW $0025
DEFW $0023
DEFW $0021
DEFW $001F
DEFW $001E
DEFW $001C
DEFW $001A
DEFW $0019
DEFW $0018
DEFW $0016
DEFW $0015
DEFW $0014
DEFW $0013
DEFW $0012
DEFW $0011
DEFW $0010
DEFW $000F
DEFW $000E
DEFW $000D
DEFW $000C
DEFW $000C
DEFW $000B
DEFW $000B
DEFW $000A
DEFW $0009
DEFW $0009
DEFW $0008

SPECTRUM 128 ROM 0 DISASSEMBLY

Octave 6, Note 81 - A (879.69 Hz, Ideal=880.00 Hz, Error=-0.04%)
Octave 6, Note 82 - A# (931.43 Hz, Ideal=933.20 Hz, Error=-0.19%)
Octave 6, Note 83 - B (989.65 Hz, Ideal=987.76 Hz, Error=+0.19%)
Octave 7, Note 84 - C (1045.67 Hz, Ideal=1046.52 Hz, Error=-0.08%) C6
Octave 7, Note 85 - C# (1108.41 Hz, Ideal=1108.80 Hz, Error=-0.04%)
Octave 7, Note 86 - D (1179.16 Hz, Ideal=1174.64 Hz, Error=+0.38%)
Octave 7, Note 87 - D# (1245.40 Hz, Ideal=1244.40 Hz, Error=+0.08%)
Octave 7, Note 88 - E (1319.53 Hz, Ideal=1318.52 Hz, Error=+0.08%)
Octave 7, Note 89 - F (1403.05 Hz, Ideal=1396.92 Hz, Error=+0.44%)
Octave 7, Note 90 - F# (1477.88 Hz, Ideal=1480.00 Hz, Error=-0.14%)
Octave 7, Note 91 - G (1561.14 Hz, Ideal=1568.00 Hz, Error=-0.44%)
Octave 7, Note 92 - G# (1654.34 Hz, Ideal=1661.20 Hz, Error=-0.41%)
Octave 7, Note 93 - A (1759.38 Hz, Ideal=1760.00 Hz, Error=-0.04%)
Octave 7, Note 94 - A# (1878.65 Hz, Ideal=1866.40 Hz, Error=+0.66%)
Octave 7, Note 95 - B (1979.30 Hz, Ideal=1975.52 Hz, Error=+0.19%)
Octave 8, Note 96 - C (2091.33 Hz, Ideal=2093.04 Hz, Error=-0.08%) C7
Octave 8, Note 97 - C# (2216.81 Hz, Ideal=2217.60 Hz, Error=-0.04%)
Octave 8, Note 98 - D (2358.31 Hz, Ideal=2349.28 Hz, Error=+0.38%)
Octave 8, Note 99 - D# (2463.13 Hz, Ideal=2488.80 Hz, Error=-1.03%)
Octave 8, Note 100 - E (2639.06 Hz, Ideal=2637.04 Hz, Error=+0.08%)
Octave 8, Note 101 - F (2771.02 Hz, Ideal=2793.84 Hz, Error=-0.82%)
Octave 8, Note 102 - F# (2995.69 Hz, Ideal=2960.00 Hz, Error=+1.21%)
Octave 8, Note 103 - G (3166.88 Hz, Ideal=3136.00 Hz, Error=+0.98%)
Octave 8, Note 104 - G# (3358.81 Hz, Ideal=3322.40 Hz, Error=+1.10%)
Octave 8, Note 105 - A (3575.50 Hz, Ideal=3520.00 Hz, Error=+1.58%)
Octave 8, Note 106 - A# (3694.69 Hz, Ideal=3732.80 Hz, Error=-1.02%)
Octave 8, Note 107 - B (3958.59 Hz, Ideal=3951.04 Hz, Error=+0.19%)
Octave 9, Note 108 - C (4263.10 Hz, Ideal=4186.08 Hz, Error=+1.84%) C8
Octave 9, Note 109 - C# (4433.63 Hz, Ideal=4435.20 Hz, Error=-0.04%)
Octave 9, Note 110 - D (4618.36 Hz, Ideal=4698.56 Hz, Error=-1.71%)
Octave 9, Note 111 - D# (5038.21 Hz, Ideal=4977.60 Hz, Error=+1.22%)
Octave 9, Note 112 - E (5278.13 Hz, Ideal=5274.08 Hz, Error=+0.08%)
Octave 9, Note 113 - F (5542.03 Hz, Ideal=5587.68 Hz, Error=-0.82%)
Octave 9, Note 114 - F# (5833.72 Hz, Ideal=5920.00 Hz, Error=-1.46%)
Octave 9, Note 115 - G (6157.81 Hz, Ideal=6272.00 Hz, Error=-1.82%)
Octave 9, Note 116 - G# (6520.04 Hz, Ideal=6644.80 Hz, Error=-1.88%)
Octave 9, Note 117 - A (6927.54 Hz, Ideal=7040.00 Hz, Error=-1.60%)
Octave 9, Note 118 - A# (7389.38 Hz, Ideal=7465.60 Hz, Error=-1.02%)
Octave 9, Note 119 - B (7917.19 Hz, Ideal=7902.08 Hz, Error=+0.19%)
Octave 10, Note 120 - C ( 8526.20 Hz, Ideal= 8372.16 Hz, Error=+1.84%) C9
Octave 10, Note 121 - C# ( 9236.72 Hz, Ideal= 8870.40 Hz, Error=+4.13%)
Octave 10, Note 122 - D ( 9236.72 Hz, Ideal= 9397.12 Hz, Error=-1.71%)
Octave 10, Note 123 - D# (10076.42 Hz, Ideal= 9955.20 Hz, Error=+1.22%)
Octave 10, Note 124 - E (10076.42 Hz, Ideal=10548.16 Hz, Error=-4.47%)
Octave 10, Note 125 - F (11084.06 Hz, Ideal=11175.36 Hz, Error=-0.82%)
Octave 10, Note 126 - F# (12315.63 Hz, Ideal=11840.00 Hz, Error=+4.02%)
Octave 10, Note 127 - G (12315.63 Hz, Ideal=12544.00 Hz, Error=-1.82%)
Octave 10, Note 128 - G# (13855.08 Hz, Ideal=13289.60 Hz, Error=+4.26%)

Play Note on MIDI Channel
This routine turns on a note on the MIDI channel and sets its volume, if MIDI channel is assigned to the current string.
Three bytes are sent, and have the following meaning:
Byte 1: Channel number $00..$0F, with bits 4 and 7 set.
Byte 2: Note number $00..$7F.
Byte 3: Note velocity $00..$78.
Entry:

IX=Address of the channel data block.

L116E:

LD A,(IX+$01)
OR A
RET M

Is a MIDI channel assigned to this string?

Return if not.

A holds the assigned channel number ($00..$0F)

OR $90

Set bits 4 and 7 of the channel number. A=$90..$9F.

73

CALL L11A3
LD A,(IX+$00)
CALL L11A3
LD A,(IX+$04)
RES 4,A
SLA A
SLA A
SLA A
CALL L11A3
RET

SPECTRUM 128 ROM 0 DISASSEMBLY

Write byte to MIDI device.
The note number.
Write byte to MIDI device.
Fetch the channel's volume.
Ensure the 'using envelope' bit is reset so
that A holds a value between $00 and $0F.
Multiply by 8 to increase the range to $00..$78.
A=Note velocity.
Write byte to MIDI device.
[Could have saved 1 byte by using JP $11A3 (ROM 0)]

Turn MIDI Channel Off
This routine turns off a note on the MIDI channel, if a MIDI channel is assigned to the current string.
Three bytes are sent, and have the following meaning:
Byte 1: Channel number $00..$0F, with bit 7 set.
Byte 2: Note number $00..$7F.
Byte 3: Note velocity $40.
Entry:

IX=Address of the channel data block.

L118D:

LD A,(IX+$01)
OR A
RET M

Is a MIDI channel assigned to this string?

Return if not.

A holds the assigned channel number ($00..$0F)

OR $80
CALL L11A3
LD A,(IX+$00)
CALL L11A3
LD A,$40
CALL L11A3
RET

Set bit 7 of the channel number. A=$80..$8F.
Write byte to MIDI device.
The note number.
Write byte to MIDI device.
The note velocity.
Write byte to MIDI device.
[Could have saved 1 byte by using JP $11A3 (ROM 0)]

Send Byte to MIDI Device
This routine sends a byte to the MIDI port. MIDI devices communicate at 31250 baud, although this routine actually generates a baud rate of 31388,
which is within the 1% tolerance supported by MIDI devices.
Entry:

A=Byte to send.

L11A3:

L11B4:

L11BE:

LD L,A
LD BC,$FFFD
LD A,$0E
OUT (C),A
LD BC,$BFFD
LD A,$FA

OUT (C),A
LD E,$03
DEC E
JR NZ,L11B4
NOP
NOP
NOP
NOP
LD A,L
LD D,$08
RRA
LD L,A
JP NC,L11C9
LD A,$FE

OUT (C),A

Store the byte to send.

Select register 14 - I/O port.

Set RS232 'RXD' transmit line to 0. (Keep KEYPAD 'CTS' output line low to prevent
the keypad resetting)
Send out the START bit.
(7) Introduce delays such that the next bit is output 113 T-states from now.
(4)
(12/7)
(4)
(4)
(4)
(4)
(4) Retrieve the byte to send.
(7) There are 8 bits to send.
(4) Rotate the next bit to send into the carry.
(4) Store the remaining bits.
(10) Jump if it is a 0 bit.
(7) Set RS232 'RXD' transmit line to 1. (Keep KEYPAD 'CTS' output line low to
prevent the keypad resetting)
(11)

74

L11C9:

L11CF:
L11D1:

L11E7:

JR L11CF
LD A,$FA

OUT (C),A
JR L11CF
LD E,$02
DEC E
JR NZ,L11D1
NOP
ADD A,$00
LD A,L
DEC D
JR NZ,L11BE
NOP
NOP
ADD A,$00
NOP
NOP
LD A,$FE

OUT (C),A
LD E,$06
DEC E
JR NZ,L11E7
RET

SPECTRUM 128 ROM 0 DISASSEMBLY

(12) Jump forward to process the next bit.
(7) Set RS232 'RXD' transmit line to 0. (Keep KEYPAD 'CTS' output line low to
prevent the keypad resetting)
(11)
(12) Jump forward to process the next bit.
(7) Introduce delays such that the next data bit is output 113 T-states from now.
(4)
(12/7)
(4)
(7)
(4) Retrieve the remaining bits to send.
(4) Decrement the bit counter.
(12/7) Jump back if there are further bits to send.
(4) Introduce delays such that the stop bit is output 113 T-states from now.
(4)
(7)
(4)
(4)
(7) Set RS232 'RXD' transmit line to 0. (Keep KEYPAD 'CTS' output line low to
prevent the keypad resetting)
(11) Send out the STOP bit.
(7) Delay for 101 T-states (28.5us).
(4)
(12/7)
(10)

CASSETTE / RAM DISK COMMAND ROUTINES — PART 1

SAVE Routine

L11EB:

LD HL,FLAGS3
SET 5,(HL)
JR L1205

$5B66.
Indicate SAVE.

LOAD Routine

L11F2:

LD HL,FLAGS3
SET 4,(HL)
JR L1205

$5B66.
Indicate LOAD.

VERIFY Routine

L11F9:

LD HL,FLAGS3
SET 7,(HL)
JR L1205

MERGE Routine

L1200:

L1205:

LD HL,FLAGS3
SET 6,(HL)
LD HL,FLAGS3
RES 3,(HL)
RST 18H
CP '!'
JP NZ,L13BE

$5B66.
Indicate VERIFY.

$5B66.
Indicate MERGE.
$5B66.
Indicate using cassette.
Get current character.
$21. '!'
Jump ahead to handle cassette command.

75

RAM disk operation

LD HL,FLAGS3
SET 3,(HL)
RST 20H
JP L13BE
CALL L05AC
DEFB $0B

L1219:

SPECTRUM 128 ROM 0 DISASSEMBLY

$5B66.
Indicate using RAM disk.
Move on to next character.
Jump ahead to handle RAM disk command.
Produce error report.
"C Nonsense in BASIC"

RAM Disk Command Handling
The information relating to the file is copied into memory in $5B66 (FLAGS3) to ensure that it is available once other RAM banks are switched in.
This code is very similar to that in the ZX Interface 1 ROM at $08F6.
Entry:

HL=Start address.
IX=File header descriptor.

L121D:

LD (HD_0D),HL
LD A,(IX+$00)
LD (HD_00),A
LD L,(IX+$0B)
LD H,(IX+$0C)
LD (HD_0B),HL
LD L,(IX+$0D)
LD H,(IX+$0E)
LD (HD_11),HL
LD L,(IX+$0F)
LD H,(IX+$10)
LD (HD_0F),HL

$5B74. Save start address.
Transfer header file information
$5B71. from IX to HD_00 onwards.

$5B72.

$5B78.

$5B76.

A copy of the header information has now been copied from IX+$00 onwards to HD_00 onwards

An array type

L124E:

OR A
JR Z,L124E
CP $03
JR Z,L124E

LD A,(IX+$0E)
LD (HD_0F),A
PUSH IX
POP HL
INC HL
LD DE,N_STR1
LD BC,$000A
LDIR
LD HL,FLAGS3
BIT 5,(HL)
JP NZ,L1BAD

Load / Verify or Merge

LD HL,HD_00
LD DE,SC_00
LD BC,$0007
LDIR
CALL L1C2E

Test file type.
Jump ahead for a program file.

Jump ahead for a CODE/SCREEN$ file.

$5B76. Store array name.
IX points to file header.
Retrieve into HL.
HL points to filename.
$5B67.

Copy the filename.
$5B66.
SAVE operation?
Jump ahead if SAVE.

$5B71.
$5B7A.

Transfer requested details from HD_00 onwards into SC_00 onwards.
Find and load requested file header into HD_00 ($5B71).

The file exists else the call above would have produced an error "h file does not exist"

LD A,(SC_00)
LD B,A
LD A,(HD_00)

$5B7A. Requested file type.

$5B71. Loaded file type.

76

L1280:

L1284:

CP B
JR NZ,L1280
CP $03
JR Z,L1290
JR C,L1284
CALL L05AC
DEFB $1D
LD A,(FLAGS3)
BIT 6,A
JR NZ,L12C5
BIT 7,A
JP Z,L12DB

SPECTRUM 128 ROM 0 DISASSEMBLY

Error 'b' if file types do not match.
Is it a CODE file type?
Jump ahead to avoid MERGE program/array check.
Only file types 0, 1 and 2 are OK.
Produce error report.
"b Wrong file type"
$5B66.
Is it a MERGE program/array operation?
Jump ahead if so.
Is it a VERIFY program/array operation?
Jump ahead if LOAD.

Either a verify program/array or a load/verify CODE/SCREEN$ type file

L1290:

LD A,(FLAGS3)
BIT 6,A
JR Z,L129B

Cannot merge CODE/SCREEN$

$5B66.
MERGE operation?
Jump ahead if VERIFY.

CALL L05AC
DEFB $1C

Produce error report.
"a MERGE error"

RAM Disk VERIFY! Routine

L129B:

LD HL,(SC_0B)
LD DE,(HD_0B)
LD A,H
OR L
JR Z,L12AE
SBC HL,DE
JR NC,L12AE

File was smaller than requested

L12AE:

L12B8:

L12C1:

CALL L05AC
DEFB $1E
LD HL,(SC_0D)
LD A,H
OR L
JR NZ,L12B8
LD HL,(HD_0D)
LD A,(HD_00)
AND A
JR NZ,L12C1
LD HL,($5C53)
CALL L137E

RET

$5B7B. Length requested.
$5B72. File length.

Jump ahead if requested length is 0, i.e. not specified.
Is file length <= requested length?
Jump ahead if so; requested length is OK.

Produce error report.
"c CODE error"
$5B7D. Fetch start address.

Is length 0, i.e. not provided?
Jump ahead if start address was provided.
$5B74. Not provided so use file's start address.
$5B71. File type.
Is it a program?
Jump ahead if not.
PROG. Set start address as start of program area.
Load DE bytes at address pointed to by HL. [The Spectrum 128 manual states
that the VERIFY keyword is not used with the RAM disk yet it clearly is, although
verifying a RAM disk file simply loads it in just as LOAD would do. To support
verifying, the routine at $1E37 (ROM 0) which loads blocks of data would need to be
able to load or verify a block. The success status would then need to be propagated
back to here via routines at $137E (ROM 0), $1C4B (ROM 0) and $1E37 (ROM 0)]
[Could have saved 1 byte by using JP $137E (ROM 0), although could have saved a
lot more by not supporting the VERIFY keyword at all]

RAM Disk MERGE! Routine

L12C5:

LD BC,(HD_0B)
PUSH BC
INC BC

$5B72. File length.
Save the length.
Increment for terminator $80 (added later).

77

RST 28H
DEFW BC_SPACES
LD (HL),$80
EX DE,HL
POP DE
PUSH HL
CALL L137E
POP HL
RST 28H
DEFW ME_CONTRL+$0018
RET

SPECTRUM 128 ROM 0 DISASSEMBLY

$0030. Create room in the workspace for the file.
Insert terminator.
HL=Start address.
DE=File length.
Save start address.
Load DE bytes to address pointed to by HL.
Retrieve start address.

$08CE. Delegate actual merge handling to ROM 1.

RAM Disk LOAD! Routine

L12DB:

LD DE,(HD_0B)
LD HL,(SC_0D)
PUSH HL
LD A,H
OR L
JR NZ,L12ED

Start address was not specified

$5B72. File length.
$5B7D. Requested start address.
Save requested start address.

Was start address specified? (0 if not).
Jump ahead if start address specified.

INC DE
INC DE
INC DE
EX DE,HL
JR L12F6

Allow for variable overhead.

HL=File Length+3.
Jump ahead to test if there is room.

A start address was specified

L12ED:

LD HL,(SC_0B)
EX DE,HL
SCF
SBC HL,DE
JR C,L12FF

$5B7B. Requested length.
DE=Requested length. HL=File length.

File length-Requested Length-1
Jump if file is smaller than requested.

Test if there is room since file is bigger than requested

L12F6:

Test file type

L12FF:

L1303:

Array type

LD DE,$0005
ADD HL,DE
LD B,H
LD C,L
RST 28H
DEFW TEST_ROOM

POP HL
LD A,(HD_00)
AND A
JR Z,L1335

LD A,H
OR L
JR Z,L1315

Start address of existing array was specified

DEC HL

Space required in BC.

$1F05. Will automatically produce error '4' if out of memory.

Requested start address.
$5B71. Get requested file type.
Test file type.
Jump if program file type.

Was start address of existing array specified?
Jump ahead if not.

78

LD B,(HL)
DEC HL
LD C,(HL)
DEC HL
INC BC
INC BC
INC BC
RST 28H
DEFW RECLAIM_2

Insert new array entry into variables area

L1315:

L1331:

Program type

L1335:

L1370:

LD HL,($5C59)
DEC HL
LD BC,(HD_0B)
PUSH BC
INC BC
INC BC
INC BC
LD A,(SC_0F)
PUSH AF
RST 28H
DEFW MAKE_ROOM
INC HL
POP AF
LD (HL),A
POP DE
INC HL
LD (HL),E
INC HL
LD (HL),D
INC HL
CALL L137E
RET

LD HL,FLAGS3
RES 1,(HL)
LD DE,($5C53)
LD HL,($5C59)
DEC HL
RST 28H
DEFW RECLAIM
LD BC,(HD_0B)
LD HL,($5C53)
RST 28H
DEFW MAKE_ROOM
INC HL
LD BC,(HD_0F)
ADD HL,BC
LD ($5C4B),HL
LD A,(HD_11+1)
LD H,A
AND $C0
JR NZ,L1370
LD A,(HD_11)
LD L,A
LD ($5C42),HL
LD (IY+$0A),$00
LD HL,FLAGS3
SET 1,(HL)
LD HL,($5C53)
LD DE,(HD_0B)
DEC HL
LD ($5C57),HL

SPECTRUM 128 ROM 0 DISASSEMBLY

Fetch array length.

Allow for variable header.

$19E8. Delete old array.

E_LINE.
Point to end
$5B72. Array length.
Save array length.
Allow for variable header.

$5B7F. Get array name.
Save array name.

$1655. Create room for new array.

Store array name.

Store array length.

Load DE bytes to address pointed to by HL.
[Could have saved 1 byte by using JP $137E (ROM 0)]

$5B66.
Signal do not auto-run BASIC program.
PROG. Address of start of BASIC program.
E_LINE. Address of end of program area.
Point before terminator.

$19E5. Delete current BASIC program.
$5B72. Fetch file length.
PROG. Address of start of BASIC program.

$1655. Create room for the file.
Allow for terminator.
$5B76. Length of variables.
Determine new address of variables.
VARS.
$5B79. Fetch high byte of auto-run line number.

If holds $80 then no auto-run line number specified.
$5B78. Low byte of auto-run line number.

NEWPPC. Set line number to run.
NSPPC. Statement 0.
$5B66.
Signal auto-run BASIC program.
PROG. Address of start of BASIC program.
$5B72. Program length.

NXTLIN. Set the address of next line to the end of the program.

79

SPECTRUM 128 ROM 0 DISASSEMBLY

INC HL
JR L1331

Jump back to load program bytes.

RAM Disk Load Bytes
Make a check that the requested length is not zero before proceeding to perform the LOAD, MERGE or VERIFY. Note that VERIFY simply performs
a LOAD.
Entry:

HL=Destination address.
DE=Length.
IX=Address of catalogue entry.
HD_00-HD_11 holds file header information.

L137E:

LD A,D
OR E
RET Z
CALL L1C4B
RET

Return if length is zero.
Load bytes
[Could have used JP $1C4B (ROM 0) to save 1 byte]

Get Expression from BASIC Line
Returns in BC.

L1385:

RST 28H
DEFW EXPT_EXP
BIT 7,(IY+$01)
RET Z
PUSH AF
RST 28H
DEFW STK_FETCH
POP AF
RET

Expect an expression on the BASIC line.
$1C8C.
Return early if syntax checking.

Get the item off the calculator stack

$2BF1.

Check Filename and Copy
Called to check a filename for validity and to copy it into N_STR1 ($5B67).

L1393:

L13AD:

L13BA:

RST 20H
CALL L1385
RET Z
PUSH AF
LD A,C
OR B
JR Z,L13BA
LD HL,$000A
SBC HL,BC
JR C,L13BA
PUSH DE
PUSH BC
LD HL,N_STR1
LD B,$0A
LD A,$20
LD (HL),A
INC HL
DJNZ L13AD
POP BC
POP HL
LD DE,N_STR1
LDIR
POP AF
RET
CALL L05AC
DEFB $21

Advance the pointer into the BASIC line.
Get expression from BASIC line.
Return if syntax checking.
[No need to save AF - see comment below]
Check for zero length.

Jump if so to produce error report "f Invalid name".
Check for length greater than 10.

Jump if so to produce error report "f Invalid name".
Save the filename start address.
Save the filename length.
$5B67. HL points to filename buffer.

Fill it with 10 spaces.

Restore filename length.
Restore filename start address.
$5B67. DE points to where to store the filename.
Perform the copy.
[No need to have saved AF as not subsequently used]

Produce error report.
"f Invalid name"

80

SPECTRUM 128 ROM 0 DISASSEMBLY

Cassette / RAM Disk Command Handling
Handle SAVE, LOAD, MERGE, VERIFY commands.
Bit 3 of FLAGS3 indicates whether a cassette or RAM disk command.
This code is very similar to that in ROM 1 at $0605.

L13BE:

L13D2:

L13DC:

RST 28H
DEFW EXPT_EXP
BIT 7,(IY+$01)
JR Z,L1407
LD BC,$0011
LD A,($5C74)
AND A
JR Z,L13D2
LD C,$22

RST 28H
DEFW BC_SPACES
PUSH DE
POP IX
LD B,$0B
LD A,$20
LD (DE),A
INC DE
DJNZ L13DC
LD (IX+$01),$FF
RST 28H
DEFW STK_FETCH
LD HL,$FFF6
DEC BC
ADD HL,BC
INC BC
JR NC,L1400
LD A,($5C74)
AND A
JR NZ,L13F9
CALL L05AC
DEFB $0E

$1C8C. Pass the parameters of the 'name' to the calculator stack.

Jump ahead if checking syntax.
Size of save header, 17 bytes.
T_ADDR. Indicates which BASIC command.
Is it SAVE?
Jump ahead if so.
Otherwise need 34d bytes for LOAD, MERGE and VERIFY commands. 17 bytes for
the header of the requested file, and 17 bytes for the files tested from tape.

$0030. Create space in workspace.
Get start of the created space into IX.

Clear the filename.

Set all characters to spaces.

Indicate a null name.
The parameters of the name are fetched.
$2BF1.
= -10.

Jump ahead if filename length within 10 characters.
T_ADDR. Indicates which BASIC command.
Is it SAVE?
Jump ahead if not since LOAD, MERGE and VERIFY can have null filenames.
Produce error report.
"F Invalid file name"

Continue to handle the name of the program.

L13F9:

LD A,B
OR C
JR Z,L1407
LD BC,$000A

Jump forward if the name has a null length.
Truncate longer filenames.

The name is now transferred to the work space (second location onwards)

L1400:

PUSH IX
POP HL
INC HL
EX DE,HL
LDIR

Transfer address of the workspace to HL.
Step to the second location.

Copy the filename.

The many different parameters, if any, that follow the command are now considered.
Start by handling 'xxx "name" DATA'.

L1407:

RST 18H
CP $E4
JR NZ,L145F

'xxx "name" DATA'

Get character from BASIC line.
Is it 'DATA'?
Jump if not DATA.

LD A,($5C74)

T_ADDR. Check the BASIC command.

81

CP $03
JP Z,L1219
RST 20H
RST 28H
DEFW LOOK_VARS
JR NC,L142F
LD HL,$0000
BIT 6,(IY+$01)
JR Z,L1425
SET 7,C
LD A,($5C74)
DEC A
JR Z,L1444
CALL L05AC
DEFB $01

L1425:

SPECTRUM 128 ROM 0 DISASSEMBLY

Is it MERGE?
"C Nonsense in BASIC" if so.
Get next character from BASIC line.

$28B2. Look in the variables area for the array.
Jump if handling an existing array.
Signal 'using a new array'.
FLAGS. Is it a string Variable?
Jump forward if so.
Set bit 7 of the array's name.
T_ADDR.
Give an error if trying to
SAVE or VERIFY a new array.
Produce error report.
"2 Variable not found"

Continue with the handling of an existing array

L142F:

JP NZ,L1219
BIT 7,(IY+$01)
JR Z,L1451
LD C,(HL)
INC HL
LD A,(HL)
LD (IX+$0B),A
INC HL
LD A,(HL)
LD (IX+$0C),A
INC HL

Jump if not an array to produce "C Nonsense in BASIC".
FLAGS.
Jump forward if checking syntax.

Point to the 'low length' of the variable.
The low length byte goes into
the work space.

The high length byte goes into
the work space.
Step past the length bytes.

The next part is common to both 'old' and 'new' arrays

L1444:

L144E:

LD (IX+$0E),C
LD A,$01
BIT 6,C
JR Z,L144E
INC A
LD (IX+$00),A

Copy the array's name.
Assume an array of numbers - Code $01.

Jump if it is so.
Indicate it is an array of characters - Code $02.
Save the 'type' in the first location of the header area.

The last part of the statement is examined before joining the other pathways

L1451:

EX DE,HL
RST 20H
CP ')'
JR NZ,L142F
RST 20H
CALL L18A1
EX DE,HL

JP L1519

Now Consider 'SCREEN$'

Save the pointer in DE.

$29. Is the next character a ')'?
Give report C if it is not.
Advance to next character.
Move on to the next statement if checking syntax.
Return the pointer to the HL. (The pointer indicates the start of an existing array's
contents).
Jump forward.

L145F:

CP $AA
JR NZ,L1482

Is the present code the token 'SCREEN$'?
Jump ahead if not.

'xxx "name" SCREEN$'

LD A,($5C74)
CP $03
JP Z,L1219

RST 20H
CALL L18A1
LD (IX+$0B),$00

T_ADDR_lo. Check the BASIC command.
Is it MERGE?
Jump to "C Nonsense in BASIC" if so since it is not possible to have 'MERGE name
SCREEN$'.
Advance pointer into BASIC line.
Move on to the next statement if checking syntax.
Length of the block.

82

LD (IX+$0C),$1B
LD HL,$4000
LD (IX+$0D),L
LD (IX+$0E),H
JR L14CF

Now consider 'CODE'

SPECTRUM 128 ROM 0 DISASSEMBLY

The display area and the attribute area occupy $1800 locations.
Start of the block, beginning of the display file $4000.

Store in the workspace.
Jump forward.

L1482:

CP $AF
JR NZ,L14D5

Is the present code the token 'CODE'?
Jump ahead if not.

'xxx "name" CODE'

LD A,($5C74)
CP $03
JP Z,L1219

RST 20H
RST 28H
DEFW PR_ST_END
JR NZ,L14A0
LD A,($5C74)
AND A
JP Z,L1219
RST 28H
DEFW USE_ZERO
JR L14AF

Look for a 'starting address'

L14A0:

L14AF:

RST 28H
DEFW EXPT_1NUM
RST 18H
CP ','
JR Z,L14B4
LD A,($5C74)
AND A
JP Z,L1219
RST 28H
DEFW USE_ZERO
JR L14B8

Fetch the 'length' as it was specified

T_ADDR_lo. Check the BASIC command.
Is it MERGE?
Jump to "C Nonsense in BASIC" if so since it is not possible to have 'MERGE name
CODE'.
Advance pointer into BASIC line.

$2048.
Jump forward if the statement has not finished
T_ADDR_lo.
It is not possible to have 'SAVE name CODE' by itself.
Jump if so to produce "C Nonsense in BASIC".

$1CE6. Put a zero on the calculator stack - for the 'start'.
Jump forward.

$1C82. Fetch the first number.

$2C. Is the present character a ','?
Jump if it is - the number was a 'starting address'
T_ADDR_lo.
Refuse 'SAVE name CODE' that does not have a 'start' and a 'length'.
Jump if so to produce "C Nonsense in BASIC".

$1CE6. Put a zero on the calculator stack - for the 'length'.
Jump forward.

L14B4:

RST 20H
RST 28H
DEFW EXPT_1NUM

Advance to next character.

$1C82. Fetch the 'length'.

The parameters are now stored in the header area of the work space

L14B8:

CALL L18A1
RST 28H
DEFW FIND_INT2
LD (IX+$0B),C
LD (IX+$0C),B
RST 28H
DEFW FIND_INT2
LD (IX+$0D),C
LD (IX+$0E),B
LD H,B
LD L,C

'SCREEN$' and 'CODE' are both of type 3

But move on to the next statement now if checking syntax.

$1E99. Compress the 'length' into BC.
Store the length of the CODE block.

$1E99. Compress the 'starting address' into BC.
Store the start address of the CODE block.

Transfer start address pointer to HL.

83

SPECTRUM 128 ROM 0 DISASSEMBLY

L14CF:

LD (IX+$00),$03
JR L1519

Store file type = $03 (CODE).
Rejoin the other pathways.

'xxx "name"' / 'SAVE "name" LINE'
Now consider 'LINE' and 'no further parameters'

L14D5:

CP $CA
JR Z,L14E2
CALL L18A1
LD (IX+$0E),$80
JR L14F9

Is the present code the token 'LINE'?
Jump ahead if so.
Move on to the next statement if checking syntax.
Indicate no LINE number.
Jump forward.

Fetch the 'line number' that must follow 'LINE'

L14E2:

LD A,($5C74)
AND A
JP NZ,L1219
RST 20H
RST 28H
DEFW EXPT_1NUM
CALL L18A1
RST 28H
DEFW FIND_INT2
LD (IX+$0D),C
LD (IX+$0E),B

T_ADDR_lo. Only allow 'SAVE name LINE number'.
Is it SAVE?
Produce "C Nonsense in BASIC" if not.
Advance pointer into BASIC line.
Get LINE number onto calculator stack
$1C82. Pass the number to the calculator stack.
Move on to the next statement if checking syntax.
Retrieve LINE number from calculator stack
$1E99. Compress the 'line number' into BC.
Store the LINE number.

'LINE' and 'no further parameters' are both of type 0

L14F9:

LD (IX+$00),$00
LD HL,($5C59)
LD DE,($5C53)
SCF
SBC HL,DE
LD (IX+$0B),L
LD (IX+$0C),H
LD HL,($5C4B)
SBC HL,DE
LD (IX+$0F),L
LD (IX+$10),H
EX DE,HL

Store file type = $00 (program).
E_LINE. The pointer to the end of the variables area.
PROG. The pointer to the start of the BASIC program.

Perform the subtraction to find the length of the 'program + variables'.

Store the length.
VARS. Repeat the operation but this
time storing the length of the
'program' only.

Transfer pointer to HL.

In all cases the header information has now been prepared:
- The location 'IX+00' holds the type number.
- Locations 'IX+01 to IX+0A' holds the name ($FF in 'IX+01' if null).
- Locations 'IX+0B & IX+0C' hold the number of bytes that are to be found in the 'data block'.
- Locations 'IX+0D to IX+10' hold a variety of parameters whose exact interpretation depends on the 'type'.
The routine continues with the first task being to separate SAVE from LOAD, VERIFY and MERGE.

L1519:

LD A,(FLAGS3)
BIT 3,A
JP NZ,L121D
LD A,($5C74)
AND A
JR NZ,L152B
RST 28H
DEFW SA_CONTROL
RET

$5B66.
Using RAM disk?
Jump if the operation is on the RAM disk.
T_ADDR_lo. Get the BASIC command.
Is it SAVE?
Jump ahead if not.

$0970. Run the save routine in ROM 1.

In the case of a LOAD, VERIFY or MERGE command the first seventeen bytes of the 'header area' in the work space hold the prepared information, as
detailed above and it is now time to fetch a 'header' from the tape.

L152B:

RST 28H
DEFW SA_ALL+$0007
RET

$0761. Run the load/merge/verify routine in ROM 1.

84

SPECTRUM 128 ROM 0 DISASSEMBLY

EDITOR ROUTINES — PART 1

Relist the BASIC Program from the Current Line
This routine lists the BASIC program from the current line number. It initially shows the last line displayed but rows may subsequently be scrolled up
until the required BASIC line has been found. The structure of the ROM program only supports listing BASIC lines that are 20 rows or less; larger lines
are shown truncated to 20 rows.

L152F:

LD HL,$EEF5
RES 0,(HL)
SET 1,(HL)

Flags.
Signal this is not the current line.
Signal not yet located the current line.

A loop is entered to display a screenful of program listing. If the current line number is not found in the lines displayed then all lines are scrolled up and
the listing reproduced. This procedure repeats until the current line number has been found and displayed.

L1536:

L1540:

L1554:

LD HL,($5C49)
LD A,H
OR L
JR NZ,L1540
LD ($EC06),HL
LD A,($F9DB)

PUSH AF
LD HL,($FC9A)
CALL L334A
LD ($F9D7),HL
CALL L3222
CALL L30D6
POP AF
OR A
JR Z,L1563

E_PPC. Fetch current line number.

Is there a currently selected line?
Jump ahead if so.
Set to $0000 to indicate no editable characters before the cursor.
Fetch the number of rows of the BASIC line that are in the Above-Screen Line Edit
Buffer,
i.e. that are off the top of the screen.
Line number of the BASIC line at the top of the screen (or 0 for the first line).
Find closest line number (or $0000 if no subsequent line exists).
Store the line number of the BASIC line being edited in the buffer.
Set default Above-Screen Line Edit Buffer settings.
Set default Below-Screen Line Edit Buffer settings.
A=Number of rows of the BASIC line that are in the Above-Screen Line Edit Buffer.
Are there any rows off the top of the screen?
Jump ahead if not.

The current settings indicate that the top BASIC line straggles into the Above-Screen Line Edit Buffer. It is therefore necessary to insert the current BASIC
line into the Below-Screen Line Edit Buffer and then shift the appropriate number of rows into the Above-Screen Line Edit Buffer.

PUSH AF
CALL L30DF
EX DE,HL
CALL L326A
POP AF
DEC A
JR L1554

Save the number of rows off the top of the screen.
Copy a BASIC line from the program area into the Below-Screen Line Edit Buffer.
DE=Address of the Below-Screen Line Edit Buffer.
Shift up a row into the Above-Screen Line Edit Buffer.
Retrieve the number of rows off the top of the screen.
Decrement the number of rows.
Jump back to shift up another row if required.

Either there the top BASI Cline does not straggle off the top of the the screen or the appropriate number of rows have been copied into the Above-
Screen Line Edit Buffer. In the latter case, the Below-Screen Line Edit Buffer contains the remaining rows of the BASIC line and which be copied into
the top of the Screen Line Edit Buffer.

L1563:

LD C,$00
CALL L30B4
LD B,C
LD A,($EC15)
LD C,A
PUSH BC
PUSH DE

C=Row 0.
DE=Start address in Screen Line Edit Buffer of the first row, as specified in C.
B=Row 0.
The number of editing rows on screen.
C=Number of editing rows on screen.
B=Row number, C=Number of editing rows on screen.
DE=Start address in Screen Line Edit Buffer of the first row.

Enter a loop to copy BASIC line rows into the Screen Line Edit Buffer. The Below-Screen Line Edit Buffer is used as a temporary store for holding each
BASIC line as it is copied into the Screen Line Edit Buffer. If the top BASIC line straggles above the screen then this loop is entered with the remains
of the line already in the Below-Screen Line Edit Buffer.

L156F:

CALL L30DF

LD A,($EEF5)

Shift up all rows of the BASIC line in the Below-Screen Line Edit Buffer, or if empty
then copy a BASIC line from the program area into it. If no BASIC line available then
empty the first row of the Below-Screen Line Edit Buffer.
Listing flags.

85

SPECTRUM 128 ROM 0 DISASSEMBLY

BIT 1,A
JR Z,L1596

Has the current line been previously found?
Jump if so.

The current line has not yet been found so examine the current row in case it is the current line

PUSH DE
PUSH HL
LD DE,$0020
ADD HL,DE
BIT 0,(HL)
JR Z,L1594

DE=Start address in Screen Line Edit Buffer of the current row.
HL=Address of the first row in the Below-Screen Line Edit Buffer.

Point to the flag byte for the first row.
Is it the first row of a BASIC line?
Jump if not.

The Below-Screen Line Edit Buffer contains a complete BASIC line so determine whether this is the current line

INC HL
LD D,(HL)
INC HL
LD E,(HL)
OR A
LD HL,($5C49)
SBC HL,DE
JR NZ,L1594
LD HL,$EEF5
SET 0,(HL)
POP HL
POP DE

L1594:

Get line number into DE.

E_PPC. Current line number.

Jump ahead unless this is the current line.

Signal this is the current line.
HL=Address of the current row in the Below-Screen Line Edit Buffer.
DE=Start address in Screen Line Edit Buffer of the current row.

Copy the row of the BASIC line from the Below-Screen Line Edit Buffer into the Screen Line Edit Buffer

L1596:

PUSH BC
PUSH HL
LD BC,$0023
LDIR

POP HL
POP BC
PUSH DE
PUSH BC
EX DE,HL
LD HL,$EEF5
BIT 0,(HL)
JR Z,L15D3

B=Row number, C=Number of editing rows on screen.
HL=Address of the current row in the Below-Screen Line Edit Buffer.

Copy the first row of the BASIC line in the Below-Screen Line Edit Buffer into the
next row of the Screen Line Edit Buffer.
HL=Address of the current row in the Below-Screen Line Edit Buffer.
B=Row number, C=Number of editing rows on screen.
DE=Start address in Screen Line Edit Buffer of the next row.
B=Row number, C=Number of editing rows on screen.
DE=Address of the current row in the Below-Screen Line Edit Buffer.
Flags.
Is this the current line?
Jump if not.

This is the current line so scan across the BASIC line to locate the cursor column position

L15AB:

LD B,$00
LD HL,($EC06)

Column 0.
HL=Count of the number of editable characters in the BASIC line up to the cursor
within the Screen Line Edit Buffer.

LD A,H
OR L
JR Z,L15C0

Are there any editable characters in this row prior to the cursor?
Jump if there are none, i.e. cursor at start of the row.

There are editable characters on this row prior to the cursor [BUG - Entering ' 10 REM' or '0010 REM' will insert the line into the program area but instead
of placing the cursor on the following row it is placed after the following BASIC line, or if the line inserted was the last in the program then the cursor is
placed on row 20. The bug occurs due to the leading spaces or zeros, and hence will apply to every BASIC command. When the line is inserted into the
Screen Line Edit Buffer, the leading spaces are discarded and hence the line length is shorter than that typed in. However, it is the typed in line length
that is used when parsing the BASIC line in the Screen Line Edit Buffer and as a result this causes an attempt to find the remaining characters on the
following row of the Screen Line Edit Buffer. If another BASIC line is on the following Screen Line Edit Buffer row then the search completes and the
cursor is placed on the row after this BASIC line. If there is not a BASIC line on the following row then the search continues on the next row. Since this will
also be empty, the search advances onto the next row, and then the next, and so on until row 20 is reached. To fix the bug, the typed in character count
until the cursor (held in $EC06) ideally needs to be adjusted to match the actual number of characters stored in the Screen Line Edit Buffer. However,
this is not a trivial change to implement. A simpler solution to fix the bug is to intercept when a move to the next row is made and to determine whether
the BASIC line actually continues on this row. Credit: Paul Farrow] [To fix the bug, the POP HL and JR NC,$15CB (ROM 0) instructions following the
call to $2E41 (ROM 0) should be replaced with the following. Credit: Paul Farrow.

86

PUSH DE
PUSH AF
LD HL,$0020
ADD HL,DE
EX DE,HL
POP AF
JR C,CHAR_FOUND
LD A,(DE)
BIT 1,A
JR NZ,SPANS_ROW
POP DE
POP HL
LD HL,$0000
LD ($EC06),HL
JP $15C0 (ROM 0)

POP DE
POP HL
JP $15CB (ROM 0)

POP DE
POP HL

PUSH HL
CALL L2E41

POP HL
JR NC,L15CB

SPANS_ROW

CHAR_FOUND

SPECTRUM 128 ROM 0 DISASSEMBLY

DE=Address of the start of the row of the BASIC line in the Screen Line Edit Buffer.
Save the flags.

DE=Address of the flag byte for the row in the Screen Line Edit Buffer.
Restore the flags.
Jump if editable column found.
Fetch the flag byte.
Does the BASIC line span onto the next row?
Jump if it does.
DE=Address of the start of the BASIC row in the Screen Line Edit Buffer.

Signal no editable characters left on the row.

Jump since all characters on the row have been scanned through.

DE=Address of the start of the BASIC row in the Screen Line Edit Buffer.

Jump if no editable columns left on the row.

DE=Address of the start of the BASIC row in the Screen Line Edit Buffer.
]

Find editable position on this row from the previous column to the right, returning
column number in B.

Jump if no editable character found on this row, i.e. there must be more characters
on the next row.

An editable character was found to the right on the current row

DEC HL
INC B
LD ($EC06),HL
JR L15AB

Decrement the count of characters prior to the cursor.
Advance to next column.
Update the count of the number of editable characters up to the cursor.
Jump back to test next column.

Column position of cursor located, find the closest editable character

L15C0:

CALL L2E41

CALL NC,L2E63

LD HL,$EEF5
LD (HL),$00

Store the current cursor position

L15CB:

LD A,B
POP BC
PUSH BC
LD C,B
LD B,A
CALL L2A11

Move to next row

L15D3:

POP BC
POP DE
LD A,C
INC B
CP B
JR NC,L156F

Find editable position on this row from the previous column to the right, returning
column number in B.
If no editable character found then find editable position to the left, returning column
number in B.
Flags.
Signal 'not the current line', 'current line has previously been found' and 'update
display file enabled'.

A=Column number. This will be the preferred column number.
B=Row number, C=Number of editing rows on screen.

C=Row number.
B=Column number.
Store this as the current cursor editing position.

B=Row number, C=Number of editing rows on screen.
DE=Start address in Screen Line Edit Buffer of the next row.
A=Number of editing rows on screen.
Next row.
Reached the bottom screen row?
Jump back if not to display the next row.

87

SPECTRUM 128 ROM 0 DISASSEMBLY

The bottom screen row has been exceeded

LD A,($EEF5)
BIT 1,A
JR Z,L1602

Listing flags.
Has the current line been previously found?
Jump if so.

Current line has not yet been found

BIT 0,A
JR NZ,L1602

Is this the current line?
Jump if so.

This is not the current line

LD HL,($5C49)
LD A,H
OR L
JR Z,L15F4
LD ($FC9A),HL
CALL L3222

JR L15FD

There is no current line number

L15F4:

L15FD:

LD ($FC9A),HL
CALL L3352

LD ($5C49),HL
POP DE
POP BC
JP L1536

The bottom line is the current line

L1602:

POP DE
POP BC
CP A

E_PPC. Current line number.

Jump if there is no current line number.
Store it as the line number at top of the screen.
Set default Above-Screen Line Edit Buffer settings to clear the count of the number
of rows it contains.
Jump forward.

Set the line number at top of the screen to $0000, i.e. first available.
Create line number representation in the Keyword Construction Buffer of the next
BASIC line.
E_PPC. Current line number is the first in the BASIC program.
DE=Start address in Screen Line Edit Buffer of the first row.
B=Row number, C=Number of editing rows on screen.
Jump back to continue listing the program until the current line is found.

DE=Start address in Screen Line Edit Buffer of the first row.
B=Row number, C=Number of editing rows on screen.
Set the zero flag if current line has yet to be found, hence signal do not update
cursor position settings.

Print All Screen Line Edit Buffer Rows to the Display File
Print all rows of the edit buffer to the display file, and updating the cursor position settings if required.
Entry:

Zero flag reset if update of cursor position settings required.
B=Row number.
C=Number of editing rows on screen.

L1605:

L160C:

L1615:

PUSH AF
LD A,C
LD C,B
CALL L30B4
EX DE,HL
PUSH AF
CALL L3604
POP AF
LD DE,$0023
ADD HL,DE
INC C
CP C
JR NC,L160C

All rows printed

Save the zero flag.
Save the number of editing rows on screen.
C=Row number.
DE=Start address in Screen Line Edit Buffer of row held in C
and transfer into HL.
A=Number of editing rows on screen.
Print a row of the edit buffer to the screen.

Point to the start of the next row.
Advance to the next row.
All rows printed?
Jump back if not to print next row.

POP AF

Retrieve the zero flag.

88

SPECTRUM 128 ROM 0 DISASSEMBLY

RET Z

Return if 'not the current line' and 'current line has previously been found'.

Find the new cursor column position

L161E:

CALL L2A07
CALL L2B78

LD HL,($EC06)
DEC HL
LD A,H
OR L
LD ($EC06),HL
JR NZ,L161E
JP L2A11
RET

Clear Editing Display

L1630:

LD B,$00
LD A,($EC15)
LD D,A
JP L3B5E

Get current cursor position (C=row, B=column, A=preferred column).
Find next Screen Line Edit Buffer editable position to right, moving to next row if
necessary. Returns column number in B.
Fetch the number of editable characters on this row prior to the cursor.
Decrement the count.
Are there any characters?

Store the new count.
Jump if there are some characters prior to the cursor.
Store cursor editing position, with preferred column of 0.
[Redundant byte]

Top row of editing area.
The number of editing rows on screen.
D=Number of rows in editing area.
Clear specified display rows.

Shift All Edit Buffer Rows Up and Update Display File if Required
This routine shifts all edit buffer rows up, updating the display file if required.
Entry:
Exit :

HL=Address of the 'Bottom Row Scroll Threshold' within the editing area information.
Carry flag set if edit buffer rows were shifted.

L1639:

LD B,$00
PUSH HL

Row number to start shifting from.
Save the address of the 'Bottom Row Scroll Threshold' within the editing area
information.

Attempt to shift a row into the Above-Screen Line Edit Buffer

LD C,B
CALL L30B4
CALL L326A

POP HL

RET NC

Find the address of row 0.
DE=Start address in Screen Line Edit Buffer of the row specified in C.
Attempt to shift the top row of the Screen Line Edit Buffer into the Above-Screen
Line Edit Buffer.
Retrieve the address of the 'Bottom Row Scroll Threshold' within the editing area
information.
Return if the Above-Screen Line Edit Buffer is full, i.e. no edit buffer rows shifted.

A change to the number of rows in the Above-Screen Line Edit Buffer occurred

CALL L30DF

Shift up rows of the BASIC line in Below-Screen Line Edit Buffer, inserting the next
line BASIC line if the buffer becomes empty. Returns with HL holding the address of
the first row in the Below-Screen Line Edit Buffer.

Shift All Screen Line Edit Buffer Rows Up and Update Display File if Required

L1648:

PUSH BC
PUSH HL
LD HL,$0023
ADD HL,DE
LD A,($EC15)
LD C,A
CP B
JR Z,L1663

Shift all Screen Line Edit Buffer rows up

B=Row counter.
HL=Address of first row in the Below-Screen Line Edit Buffer.
DE=Address of the current row in the Screen Line Edit Buffer.
HL=Address of the next row in the Screen Line Edit Buffer.

C=Number of editing rows on screen.
Any rows to shift?
Jump if not.

89

SPECTRUM 128 ROM 0 DISASSEMBLY

L1656:

PUSH BC
PUSH BC
LD BC,$0023
LDIR
POP BC
LD A,C
INC B
CP B
JR NZ,L1656

C=Number of editing rows on screen.
C=Number of editing rows on screen.
DE=Current Screen Line Edit Buffer row, HL=Next Screen Line Edit Buffer row.
Shift one row of the Screen Line Edit Buffer up.
C=Number of editing rows on screen.
Fetch the number of editing rows on screen.
Next row.
All rows shifted?
Repeat for all edit buffer rows to shift.

All Screen Line Edit Buffer rows have been shifted up

L1663:
L1664:

POP BC
POP HL
CALL L3618
LD BC,$0023

LDIR

SCF
POP BC
RET

C=Number of editing rows on screen, B=Row number, i.e. 0.
HL=Address of the first row in the Below-Screen Line Edit Buffer.
Shift up all edit rows in the display file if updating required.
HL=Address of the first row in the Below-Screen Line Edit Buffer, DE=Address of
last row in Screen Line Edit Buffer.
Copy the first row of the Below-Screen Line Edit Buffer into the last row of the
Screen Line Edit Buffer.
Signal that edit buffer rows were shifted.
B=Row counter.

Shift All Edit Buffer Rows Down and Update Display File if Required
This routine shifts all edit buffer rows down, updating the display file if required.
Exit : Carry flag set if edit buffer rows were shifted.
B=Last row number to shift.
Shift all rows in the Above-Screen Line Edit Buffer, shifting in a new BASIC line if applicable

L166F:

LD B,$00
CALL L322B

RET NC

Last row number to shift.
Attempt to shift down the Above-Screen Line Edit Buffer, loading in a new BASIC
line if it is empty.
Return if Above-Screen Line Edit Buffer is empty, i.e. no edit buffer rows were
shifted.

Entry point from routine at $2ED3 (ROM 0) to insert a blank row

L1675:

PUSH BC
PUSH HL

B=Last row number to shift.
HL=Address of next row to use within the Above-Screen Line Edit Buffer.

Shift all rows in the Below-Screen Line Edit Buffer down, shifting in a new BASIC line if applicable

LD A,($EC15)
LD C,A
CALL L30B4
CALL L311E

JR NC,L16A9
DEC DE

LD HL,$0023
ADD HL,DE
EX DE,HL

PUSH BC
LD A,B
CP C
JR Z,L169A
PUSH BC
LD BC,$0023
LDDR
POP BC
LD A,B

L168E:

L1695:

A=Number of editing rows on screen.
C=Number of editing rows on screen.
DE=Start address in Screen Line Edit Buffer of the last editing row.
Shift down all rows in the Below-Screen Line Edit Buffer, or empty the buffer a row
does not straggle off the bottom of the screen.
Jump if the Below-Screen Line Edit Buffer is full.
DE=Address of the last flag byte of the penultimate editing row in the Screen Line
Edit Buffer.
Length of an edit buffer row.
HL=Address of the last flag byte of the last editing row in the Screen Line Edit Buffer.
DE=Address of last flag byte of last editing row in Screen Line Edit Buffer,
HL=Address of last flag byte of penultimate editing row in Screen Line Edit Buffer.
C=Number of editing rows on screen, B=Last row number to shift.

Any rows to shift?
Jump if not.
C=Row number to shift, B=Last row number to shift.

Copy one row of the Screen Line Edit Buffer down.
C=Number of editing rows on screen, B=Row shift counter.
A=Row shift counter.

90

SPECTRUM 128 ROM 0 DISASSEMBLY

DEC C
CP C
JR C,L168E

Repeat for all edit buffer rows to shift.

All Screen Line Edit Buffer rows have been shifted down

L169A:

EX DE,HL

INC DE
POP BC
POP HL
CALL L362C
LD BC,$0023
LDIR

SCF
POP BC
RET

HL=Address of last flag byte of first editing row in Screen Line Edit Buffer,
DE=Address of byte before start of first editing row in Screen Line Edit Buffer.
DE=Start of first row in Screen Line Edit Buffer.
C=Number of editing rows on screen, B=Last row number to shift.
HL=Address of next row to use within the Above-Screen Line Edit Buffer.
Shift down all edit rows in the display file if updating required.

Copy the next row of the Above-Screen Line Edit Buffer into the first row of the
Screen Line Edit Buffer.
Signal Below-Screen Line Edit Buffer is not full.
B=Last row number to shift.

The Below-Screen Line Edit Buffer is full

L16A9:

POP HL
POP BC
RET

Restore registers.
B=Last row number to shift.

Insert Character into Edit Buffer Row, Shifting Row Right
This routine shifts a byte into an edit buffer row, shifting all existing characters right until either the end of the row is reached or the specified end column
is reached.
Entry:

Exit :

L16AC:

L16B0:

DE=Start address of an edit buffer row.
A=Character to shift into left of row.
B=Column to start shifting at.
A=Byte shifted out from last column.
HL=Points byte after row (i.e. flag byte).
Zero flag set if the character shifted out was a null ($00).

PUSH DE
LD H,$00
LD L,B
ADD HL,DE
LD D,A
LD A,B

Save DE.

HL=Start column number.
HL=Address of the starting column.
Store the character to shift in.
A=Start column number.

Shift all bytes in the row to the right.

L16B3:

LD E,(HL)
LD (HL),D
LD D,E
INC HL
INC A
CP $20
JR C,L16B3
LD A,E
CP $00
POP DE
RET

Fetch a character from the row.
Replace it with the character to shift in.
Store the old character for use next time.
Point to the next column.

End of row reached?
Jump if not to shift the next character.
A=Character that was shifted out.
Return with zero flag set if the character was $00.
Restore DE

Insert Character into Edit Buffer Row, Shifting Row Left
This routine shifts a byte into an edit buffer row, shifting all existing characters left until either the beginning of the row is reached or the specified end
column is reached.
Entry:

DE=Start address of an edit buffer row.

91

Exit :

L16C1:

L16C5:

L16CC:

L16D3:

L16D6:

SPECTRUM 128 ROM 0 DISASSEMBLY

A=Character to shift into right of row.
B=Column to stop shifting at.
A=Byte shifted out.
HL=Points byte before row.
Zero flag set if the character shifted out was a null ($00).

PUSH DE
LD HL,$0020
ADD HL,DE
PUSH HL
LD D,A
LD A,$1F
JR L16D3
LD E,(HL)
LD (HL),D
LD D,E
CP B
JR Z,L16D6
DEC A
DEC HL
JR L16CC
LD A,E
CP $00
POP HL
POP DE
RET

Save DE.
32 columns.
Point to the flag byte for this row.
Save it.
Store the character to shift in.
Maximum of 31 shifts.
Jump ahead to start shifting.
Fetch a character from the row.
Replace it with the character to shift in.
Store the old character for use next time.
End column reached?
Jump if so to exit.
Decrement column counter.
Point back a column.
Loop back to shift the next character.
A=Character that was shifted out.
Return with zero flag set if the character was $00.
Fetch address of next flag byte for the row.
Restore DE.

BASIC LINE AND COMMAND INTERPRETATION ROUTINES — PART 1

The Syntax Offset Table
Similar in construction to the table in ROM 1 at $1A48.
[No instruction fetch at $1708 hence ZX Interface 1 will not be paged in by this ROM. Credit: Paul Farrow].

L16DC:

DEFB $B1
DEFB $C9
DEFB $BC
DEFB $BE
DEFB $C3
DEFB $AF
DEFB $B4
DEFB $93
DEFB $91
DEFB $92
DEFB $95
DEFB $98
DEFB $98
DEFB $98
DEFB $98
DEFB $98
DEFB $98
DEFB $98
DEFB $7F
DEFB $81
DEFB $2E
DEFB $6C
DEFB $6E
DEFB $70
DEFB $48
DEFB $94
DEFB $56
DEFB $3F
DEFB $41

DEF FN -> $178D (ROM 0)
CAT -> $17A6 (ROM 0)
FORMAT -> $179A (ROM 0)
MOVE -> $179D (ROM 0)
ERASE -> $17A3 (ROM 0)
OPEN # -> $1790 (ROM 0)
CLOSE # -> $1796 (ROM 0)
MERGE -> $1776 (ROM 0)
VERIFY -> $1775 (ROM 0)
BEEP -> $1777 (ROM 0)
CIRCLE -> $177B (ROM 0)
INK -> $177F (ROM 0)
PAPER -> $1780 (ROM 0)
FLASH -> $1781 (ROM 0)
BRIGHT -> $1782 (ROM 0)
INVERSE -> $1783 (ROM 0)
OVER -> $1784 (ROM 0)
OUT -> $1785 (ROM 0)
LPRINT -> $176D (ROM 0)
LLIST -> $1770 (ROM 0)
STOP -> $171E (ROM 0)
READ -> $175D (ROM 0)
DATA -> $1760 (ROM 0)
RESTORE -> $1763 (ROM 0)
NEW -> $173C (ROM 0)
BORDER -> $1789 (ROM 0)
CONTINUE -> $174C (ROM 0)
DIM -> $1736 (ROM 0)
REM -> $1739 (ROM 0)

92

SPECTRUM 128 ROM 0 DISASSEMBLY

DEFB $2B
DEFB $17
DEFB $1F
DEFB $37
DEFB $77
DEFB $44
DEFB $0F
DEFB $59
DEFB $2B
DEFB $43
DEFB $2D
DEFB $51
DEFB $3A
DEFB $6D
DEFB $42
DEFB $0D
DEFB $49
DEFB $5C
DEFB $44
DEFB $15
DEFB $5D

The Syntax Parameter Table
Similar to the parameter table in ROM 1 at $1A7A.

L170E:

L1711:

L1715:

L171A:

L171E:

L1721:

L1724:

L172C:

L1730:

L1733:

L1736:

L1739:

L173C:

L173F:

DEFB $01
DEFB '='
DEFB $02
DEFB $06
DEFB $00
DEFW GO_TO
DEFB $06
DEFB $CB
DEFB $0E
DEFW L1967
DEFB $06
DEFB $0C
DEFW L1A53
DEFB $00
DEFW STOP
DEFB $0C
DEFW L1A6F
DEFB $04
DEFB '='
DEFB $06
DEFB $CC
DEFB $06
DEFB $0E
DEFW L1981
DEFB $04
DEFB $00
DEFW NEXT
DEFB $0E
DEFW L2178
DEFB $0E
DEFW L218C
DEFB $0E
DEFW L21D5
DEFB $0E
DEFW L1862
DEFB $0C
DEFW L21AA
DEFB $0D
DEFW L1A02

FOR -> $1724 (ROM 0)
GO TO -> $1711 (ROM 0)
GO SUB -> $171A (ROM 0)
INPUT -> $1733 (ROM 0)
LOAD -> $1774 (ROM 0)
LIST -> $1742 (ROM 0)
LET -> $170E (ROM 0)
PAUSE -> $1759 (ROM 0)
NEXT -> $172C (ROM 0)
POKE -> $1745 (ROM 0)
PRINT -> $1730 (ROM 0)
PLOT -> $1755 (ROM 0)
RUN -> $173F (ROM 0)
SAVE -> $1773 (ROM 0)
RANDOMIZE -> $1749 (ROM 0)
IF -> $1715 (ROM 0)
CLS -> $1752 (ROM 0)
DRAW -> $1766 (ROM 0)
CLEAR -> $174F (ROM 0)
RETURN -> $1721 (ROM 0)
COPY -> $176A (ROM 0)

CLASS-01 LET
$3D. '='
CLASS-02
CLASS-06 GO TO
CLASS-00
$1E67. GO TO routine in ROM 1.
CLASS-06 IF
'THEN'
CLASS-0E
New IF routine in ROM 0.
CLASS-06 GO SUB
CLASS-0C
New GO SUB routine in ROM 0.
CLASS-00 STOP
$1CEE. STOP routine in ROM 1.
CLASS-0C RETURN
New RETURN routine in ROM 0.
CLASS-04 FOR
$3D. '='
CLASS-06
'TO'
CLASS-06
CLASS-0E
New FOR routine in ROM 0.
CLASS-04 NEXT
CLASS-00
$1DAB. NEXT routine in ROM 1.
CLASS-0E PRINT
New PRINT routine in ROM 0.
CLASS-0E INPUT
New INPUT routine in ROM 0.
CLASS-0E DIM
New DIM routine in ROM 0.
CLASS-0E REM
New REM routine in ROM 0.
CLASS-0C NEW
New NEW routine in ROM 0.
CLASS-0D RUN
New RUN routine in ROM 0.

93

L1742:

L1745:

L1749:

L174C:

L174F:

L1752:

L1755:

L1759:

L175D:

L1760:

L1763:

L1766:

L176A:

L176D:

L1770:

L1773:
L1774:
L1775:
L1776:
L1777:

L177B:

L177F:
L1780:
L1781:
L1782:
L1783:
L1784:
L1785:

L1789:

L178D:

L1790:

L1796:

L179A:

DEFB $0E
DEFW L1B75
DEFB $08
DEFB $00
DEFW POKE
DEFB $03
DEFW RANDOMIZE
DEFB $00
DEFW CONTINUE
DEFB $0D
DEFW L1A0D
DEFB $00
DEFW CLS
DEFB $09
DEFB $00
DEFW PLOT
DEFB $06
DEFB $00
DEFW PAUSE
DEFB $0E
DEFW L19AB
DEFB $0E
DEFW L19EB
DEFB $03
DEFW RESTORE
DEFB $09
DEFB $0E
DEFW L21BE
DEFB $0C
DEFW L21A7
DEFB $0E
DEFW L2174
DEFB $0E
DEFW L1B71
DEFB $0B
DEFB $0B
DEFB $0B
DEFB $0B
DEFB $08
DEFB $00
DEFW BEEP
DEFB $09
DEFB $0E
DEFW L21AE
DEFB $07
DEFB $07
DEFB $07
DEFB $07
DEFB $07
DEFB $07
DEFB $08
DEFB $00
DEFW COUT
DEFB $06
DEFB $00
DEFW BORDER
DEFB $0E
DEFW L1A8C
DEFB $06
DEFB ','
DEFB $0A
DEFB $00
DEFW OPEN
DEFB $06
DEFB $00
DEFW CLOSE
DEFB $0E

SPECTRUM 128 ROM 0 DISASSEMBLY

CLASS-0E LIST
New LIST routine in ROM 0.
CLASS-08 POKE
CLASS-00
$1E80. POKE routine in ROM 1.
CLASS-03 RANDOMIZE
$1E4F. RANDOMIZE routine in ROM 1.
CLASS-00 CONTINUE
$1E5F. CONTINUE routine in ROM 1.
CLASS-0D CLEAR
New CLEAR routine in ROM 0.
CLASS-00 CLS
$0D6B. CLS routine in ROM 1.
CLASS-09 PLOT
CLASS-00
$22DC. PLOT routine in ROM 1
CLASS-06 PAUSE
CLASS-00
$1F3A. PAUSE routine in ROM 1.
CLASS-0E READ
New READ routine in ROM 0.
CLASS-0E DATA
New DATA routine in ROM 0.
CLASS-03 RESTORE
$1E42. RESTORE routine in ROM 1.
CLASS-09 DRAW
CLASS-0E
New DRAW routine in ROM 0.
CLASS-0C COPY
New COPY routine in ROM 0.
CLASS-0E LPRINT
New LPRINT routine in ROM 0.
CLASS-0E LLIST
New LLIST routine in ROM 0.
CLASS-0B SAVE
CLASS-0B LOAD
CLASS-0B VERIFY
CLASS-0B MERGE
CLASS-08 BEEP
CLASS-00
$03F8. BEEP routine in ROM 1.
CLASS-09 CIRCLE
CLASS-0E
New CIRCLE routine in ROM 0.
CLASS-07 INK
CLASS-07 PAPER
CLASS-07 FLASH
CLASS-07 BRIGHT
CLASS-07 INVERSE
CLASS-07 OVER
CLASS-08 OUT
CLASS-00
$1E7A. OUT routine in ROM 1.
CLASS-06 BORDER
CLASS-00
$2294. BORDER routine in ROM 1.
CLASS-0E DEF FN
New DEF FN routine in ROM 0.
CLASS-06 OPEN #
$2C. ','
CLASS-0A
CLASS-00
$1736. OPEN # routine in ROM 1.
CLASS-06 CLOSE #
CLASS-00
$16E5. CLOSE # routine in ROM 1.
CLASS-0E FORMAT

94

SPECTRUM 128 ROM 0 DISASSEMBLY

L179D:

L17A3:

L17A6:

L17A9:

L17AC:

DEFW L0641
DEFB $0A
DEFB ','
DEFB $0A
DEFB $0C
DEFW L1AF0
DEFB $0E
DEFW L1C0C
DEFB $0E
DEFW L1BE5
DEFB $0C
DEFW L1B2B
DEFB $0E
DEFW L2317

FORMAT routine in ROM 0.
CLASS-0A MOVE
$2C. ','
CLASS-0A
CLASS-0C
Just execute a RET.
CLASS-0E ERASE
New ERASE routine in ROM 0.
CLASS-0E CAT
New CAT routine in ROM 0.
CLASS-0C SPECTRUM
SPECTRUM routine in ROM 0.
CLASS-0E PLAY
PLAY routine in ROM 0.

(From Logan & O'Hara's 48K ROM disassembly):
The requirements for the different command classes are as follows: CLASS-00 - No further operands.
CLASS-01 - Used in LET. A variable is required.
CLASS-02 - Used in LET. An expression, numeric or string, must follow.
CLASS-03 - A numeric expression may follow. Zero to be used in case of default.
CLASS-04 - A single character variable must follow.
CLASS-05 - A set of items may be given.
CLASS-06 - A numeric expression must follow.
CLASS-07 - Handles colour items.
CLASS-08 - Two numeric expressions, separated by a comma, must follow.
CLASS-09 - As for CLASS-08 but colour items may precede the expressions.
CLASS-0A - A string expression must follow.
CLASS-0B - Handles cassette/RAM disk routines.
In addition the 128 adds the following classes:
CLASS-0C - Like class 00 but calling ROM 0. (Used by SPECTRUM, MOVE, COPY, NEW, GO SUB, RETURN)
CLASS-0D - Like class 06 but calling ROM 0. (Used by CLEAR, RUN)
CLASS-0E - Handled in ROM 0. (Used by PLAY, ERASE, CAT, FORMAT, CIRCLE, LPRINT, LLIST, DRAW, DATA, READ, LIST, DIM, INPUT, PRINT,
FOR, IF)

The 'Main Parser' Of the BASIC Interpreter
The parsing routine of the BASIC interpreter is entered at $17AF (ROM 0) when syntax is being checked, and at $1838 (ROM 0) when a BASIC program
of one or more statements is to be executed.
This code is similar to that in ROM 1 at $1B17.

L17AF:

RES 7,(IY+$01)
RST 28H
DEFW E_LINE_NO
XOR A
LD ($5C47),A
DEC A
LD ($5C3A),A
JR L17C1

FLAGS. Signal 'syntax checking'.

$19FB. CH-ADD is made to point to the first code after any line number

SUBPPC. Set to $00.

ERR_NR. Set to $FF.
Jump forward to consider the first statement of the line.

The Statement Loop
Each statement is considered in turn until the end of the line is reached.

L17C0:
L17C1:

RST 20H
RST 28H
DEFW SET_WORK
INC (IY+$0D)
JP M,L1912

RST 18H
LD B,$00
CP $0D
JP Z,L1863
CP ':'
JR Z,L17C0

Advance CH-ADD along the line.

$16BF. The work space is cleared.
SUBPPC. Increase SUBPPC on each passage around the loop.
Only '127' statements are allowed in a single line. Jump to report "C Nonsense in
BASIC".
Fetch a character.
Clear the register for later.
Is the character a 'carriage return'?
jump if it is.
$3A. Go around the loop again if it is a ':'.

95

A statement has been identified so, first, its initial command is considered

SPECTRUM 128 ROM 0 DISASSEMBLY

LD HL,L1821
PUSH HL
LD C,A
RST 20H
LD A,C
SUB $CE
JR NC,L17F4
ADD A,$CE
LD HL,L17A9
CP $A3
JR Z,L1800
LD HL,L17AC
CP $A4
JR Z,L1800
JP L1912
LD C,A
LD HL,L16DC
ADD HL,BC
LD C,(HL)
ADD HL,BC
JR L1800

L17F4:

Pre-load the machine stack with the return address.

Save the command temporarily
in the C register whilst CH-ADD is advanced again.

Reduce the command's code by $CE giving the range indexed from $00.
Jump for DEF FN and above.

Is it 'SPECTRUM'?
Jump if so into the scanning loop with this address.

Is it 'PLAY'?
Jump if so into the scanning loop with this address.
Produce error report "C Nonsense in BASIC".
Move the command code to BC (B holds $00).
The base address of the syntax offset table.

Find address for the command's entries in the parameter table.
Jump forward into the scanning loop with this address.

Each of the command class routines applicable to the present command are executed in turn.
Any required separators are also considered.

L17FD:
L1800:

LD HL,($5C74)
LD A,(HL)
INC HL
LD ($5C74),HL
LD BC,L17FD
PUSH BC
LD C,A
CP $20
JR NC,L181A
LD HL,L18B5
LD B,$00
ADD HL,BC
LD C,(HL)
ADD HL,BC
PUSH HL
RST 18H

DEC B
RET

T_ADDR. The temporary pointer to the entries in the parameter table.
Fetch each entry in turn.
Update the pointer to the entries for the next pass.
T_ADDR.
Pre-load the machine stack with the return address.

Copy the entry to the C register for later.

Jump forward if the entry is a 'separator'.
The base address of the 'command class' table.

Index into the table.

HL=base + code + (base + code).
HL=The starting address of the required command class routine.
Before making an indirect jump to the command class routine pass the command
code
to the A register and set the B register to $FF.
Return to the stacked address.

The 'Separator' Subroutine
The report 'Nonsense in BASIC is given if the required separator is not present.
But note that when syntax is being checked the actual report does not appear on the screen - only the 'error marker'.
This code is similar to that in ROM 1 at $1B6F.

L181A:

RST 18H
CP C
JP NZ,L1912
RST 20H
RET

The current character is
fetched and compared to the entry in the parameter table.
Give the error report if there is not a match.
Step past a correct character
and return.

The 'Statement Return' Subroutine
After the correct interpretation of a statement, a return is made to this entry point.
This code is similar to that in ROM 1 at $1B76.

96

L1821:

L182A:

CALL L05D6
JR C,L182A
CALL L05AC
DEFB $14
BIT 7,(IY+$0A)
JP NZ,L18A8
LD HL,($5C42)
BIT 7,H
JR Z,L184C

SPECTRUM 128 ROM 0 DISASSEMBLY

Check for BREAK
Jump if pressed.
Produce error report.
"L Break into program"
NSPPC - statement number in line to be jumped to
Jump forward if there is not a 'jump' to be made.
NEWPPC, line number to be jumped to.

Jump forward unless dealing with a further statement in the editing area.

The 'Line Run' Entry Point
This entry point is used wherever a line in the editing area is to be 'run'.
In such a case the syntax/run flag (bit 7 of FLAGS) will be set.
The entry point is also used in the syntax checking of a line in the editing area that has more than one statement (bit 7 of FLAGS will be reset).
This code is similar to that in ROM 1 at $1B8A.

L1838:

LD HL,$FFFE
LD ($5C45),HL
LD HL,($5C61)
DEC HL
LD DE,($5C59)
DEC DE
LD A,($5C44)
JR L1882

A line in the editing area is considered as line '-2'.
PPC.
WORKSP. Make HL point to the end marker of the editing area.

E_LINE. Make DE point to the location before the end marker of the editing area.

NSPPC. Fetch the number of the next statement to be handled.
Jump forward.

The 'Line New' Subroutine
There has been a jump in the program and the starting address of the new line has to be found.
This code is similar to that in ROM 1 at 1B9E.

L184C:

RST 28H
DEFW LINE_ADDR
LD A,($5C44)
JR Z,L1870
AND A
JR NZ,L189D
LD B,A
LD A,(HL)
AND $C0
LD A,B
JR Z,L1870
CALL L05AC
DEFB $FF

$196E. The starting address of the line, or the 'first line after' is found.
NSPPC. Collect the statement number.
Jump forward if the required line was found.
Check the validity of the statement number - must be zero.
Jump if not to produce error report "N Statement lost".
Also check that the 'first
line after' is not after the
actual 'end of program'.

Jump forward with valid addresses; otherwise signal the error 'OK'.
Produce error report.
"0 OK"

REM Routine
The return address to STMT-RET is dropped which has the effect of forcing the rest of the line to be ignored.
This code is similar to that in ROM 1 at $1BB2.

L1862:

POP BC

Drop the statement return address.

The 'Line End' Routine
If checking syntax a simple return is made but when 'running' the address held by NXTLIN has to be checked before it can be used.
This code is similar to that in ROM 1 at $1BB3.

L1863:

BIT 7,(IY+$01)
RET Z
LD HL,($5C55)
LD A,$C0
AND (HL)

Return if syntax is being checked.
NXTLIN.
Return if the address is after the end of the program - the 'run' is finished.

97

SPECTRUM 128 ROM 0 DISASSEMBLY

RET NZ
XOR A

Signal 'statement zero' before proceeding.

The 'Line Use' Routine
This routine has three functions:
i. Change statement zero to statement '1'.
ii. Find the number of the new line and enter it into PPC.
iii. Form the address of the start of the line after.
This code is similar to that in ROM 1 at $1BBF.

L1870:

CP $01
ADC A,$00
LD D,(HL)
INC HL
LD E,(HL)
LD ($5C45),DE
INC HL
LD E,(HL)
INC HL
LD D,(HL)
EX DE,HL
ADD HL,DE
INC HL

Statement zero becomes statement 1.

The line number of the line to be used is collected and
passed to PPC.

PPC.

Now find the 'length' of the line.

Switch over the values.
Form the address of the start of the line after in HL and the
location before the 'next' line's first character in DE.

The 'Next Line' Routine
On entry the HL register pair points to the location after the end of the 'next' line to be handled and the DE register pair to the location before the first
character of the line.
This applies to lines in the program area and also to a line in the editing area - where the next line will be the same line again whilst there are still
statements to be interpreted.
This code is similar to that in ROM 1 at $1BD1.

L1882:

L189D:

LD ($5C55),HL
EX DE,HL
LD ($5C5D),HL
LD D,A
LD E,$00
LD (IY+$0A),$FF
DEC D
LD (IY+$0D),D
JP Z,L17C0
INC D
RST 28H
DEFW EACH_STMT
JR Z,L18A8
CALL L05AC
DEFB $16

NXTLIN. Set NXTLIN for use once the current line has been completed.

CH_ADD. CH_ADD points to the location before the first character to be considered.
The statement number is fetched.
The E register is cleared in case the 'Each Statement' routine is used.
NSPPC. Signal 'no jump'.

SUB_PPC. Statement number-1.
Jump if the first statement.
For later statements the 'starting address' has to be found.

$198B.
Jump forward unless the statement does not exist.
Produce error report.
"N Statement lost"

The 'CHECK-END' Subroutine
This is called when the syntax of the edit-line is being checked. The purpose of the routine is to give an error report if the end of a statement has not
been reached and to move on to the next statement if the syntax is correct.
The routine is the equivalent of routine CHECK_END in ROM 1 at $1BEE.

L18A1:

BIT 7,(IY+$01)
RET NZ
POP BC
POP BC

Very like CHECK-END at 1BEE in ROM 1
Return unless checking syntax.
Drop scan loop and statement return addresses.

98

SPECTRUM 128 ROM 0 DISASSEMBLY

The 'STMT-NEXT' Routine
If the present character is a 'carriage return' then the 'next statement' is on the 'next line', if ':' it is on the same line; but if any other character is found
then there is an error in syntax.
The routine is the equivalent of routine STMT_NEXT in ROM 1 at $1BF4.

L18A8:

RST 18H
CP $0D
JR Z,L1863
CP ':'
JP Z,L17C0
JP L1912

Fetch the present character.
Consider the 'next line' if
it is a 'carriage return'.
$3A. Consider the 'next statement'
if it is a ':'.
Otherwise there has been a syntax error so produce "C Nonsense in BASIC".

The 'Command Class' Table

L18B5:

DEFB L18D9-$
DEFB L18F9-$
DEFB L18FD-$
DEFB L18D6-$
DEFB L1905-$
DEFB L18DA-$
DEFB L190E-$
DEFB L191A-$
DEFB L190A-$
DEFB L1944-$
DEFB L1916-$
DEFB L1948-$
DEFB L18C7-$
DEFB L18C4-$
DEFB L18C8-$

CLASS-00 -> L18D9 = $24
CLASS-01 -> L18F9 = $43
CLASS-02 -> L18FD = $46
CLASS-03 -> L18D6 = $1E
CLASS-04 -> L1905 = $4C
CLASS-05 -> L18DA = $20
CLASS-06 -> L190E = $53
CLASS-07 -> L191A = $5E
CLASS-08 -> L190A = $4D
CLASS-09 -> L1944 = $86
CLASS-0A -> L1916 = $57
CLASS-0B -> L1948 = $88
CLASS-0C -> L18C7 = $06
CLASS-0D -> L18C4 = $02
CLASS-0E -> L18C8 = $05

The 'Command Classes — 0C, 0D & 0E'
For commands of class-0D a numeric expression must follow.

L18C4:

RST 28H
DEFW FETCH_NUM

Code 0D enters here.
$1CDE.

The commands of class-0C must not have any operands. e.g. SPECTRUM.

L18C7:

CP A

Code 0C enters here. Set zero flag.

The commands of class-0E may be followed by a set of items. e.g. PLAY.

L18C8:

POP BC
CALL Z,L18A1

EX DE,HL

Code 0E enters here. Retrieve return address.
If handling commands of classes 0C & 0D and syntax is being checked move on
now to consider the next statement.
Save the line pointer in DE.

After the command class entries and the separator entries in the parameter table have been considered the jump to the appropriate command routine
is made.
The routine is similar to JUMP-C-R in ROM 1 at $1C16.

LD HL,($5C74)
LD C,(HL)
INC HL
LD B,(HL)
EX DE,HL
PUSH BC
RET

T_ADDR.
Fetch the pointer to the entries in the parameter table
and fetch the address of the
required command routine.
Exchange the pointers back.
Make an indirect jump to the command routine.

99

SPECTRUM 128 ROM 0 DISASSEMBLY

The 'Command Classes — 00, 03 & 05'
These routines are the equivalent of the routines in ROM 1 starting at $1C0D.
The commands of class-03 may, or may not, be followed by a number. e.g. RUN & RUN 200.

L18D6:

RST 28H
DEFW FETCH_NUM

Code 03 enters here.
$1CDE. A number is fetched but zero is used in cases of default.

The commands of class-00 must not have any operands. e.g. COPY & CONTINUE.

L18D9:

CP A

Code 00 enters here. Set the zero flag.

The commands of class-05 may be followed by a set of items. e.g. PRINT & PRINT "222".

L18DA:

POP BC
CALL Z,L18A1

EX DE,HL
LD HL,($5C74)
LD C,(HL)
INC HL
LD B,(HL)
EX DE,HL
PUSH HL
LD HL,L18F8
LD (RETADDR),HL
LD HL,YOUNGER
EX (SP),HL
PUSH HL
LD H,B
LD L,C
EX (SP),HL
JP SWAP

Code 05 enters here. Drop return address.
If handling commands of classes 00 & 03 and syntax is being checked move on now
to consider the next statement.
Save the line pointer in DE.
T_ADDR. Fetch the pointer to the entries in the parameter table.

Fetch the address of the required command routine.
Exchange the pointers back.
Save command routine address.
The address to return to (the RET below).
$5B5A. Store the return address.
$5B14. Paging subroutine.
Replace the return address with the address of the YOUNGER routine.
Save the original top stack item.

HL=Address of command routine.
Put onto the stack so that an indirect jump will be made to it.
$5B00. Switch to other ROM and 'return' to the command routine.

Comes here after ROM 1 has been paged in, the command routine called, ROM 0 paged back in.

L18F8:

RET

Simply make a return.

The 'Command Class — 01'
Command class 01 is concerned with the identification of the variable in a LET, READ or INPUT statement.

L18F9:

RST 28H
DEFW CLASS_01
RET

Delegate handling to ROM 1.
$1C1F.

The 'Command Class — 02'
Command class 02 is concerned with the actual calculation of the value to be assigned in a LET statement.

L18FD:

POP BC
RST 28H
DEFW VAL_FET_1

CALL L18A1
RET

Code 02 enters here. Delegate handling to ROM 1.

$1C56. "... used by LET, READ and INPUT statements to first evaluate and then
assign values to the previously designated variable" (Logan/O'Hara)
Move on to the next statement if checking syntax
else return here.

The 'Command Class — 04'
The command class 04 entry point is used by FOR & NEXT statements.

100

SPECTRUM 128 ROM 0 DISASSEMBLY

L1905:

RST 28H
DEFW CLASS_04
RET

Code 04 enters here. Delegate handling to ROM 1.
$1C6C.

The 'Command Class — 08'
Command class 08 allows for two numeric expressions, separated by a comma, to be evaluated.

L1909:
L190A:

RST 20H
RST 28H
DEFW EXPT_2NUM
RET

[Redundant byte]
Delegate handling to ROM 1.
$1C7A.

The 'Command Class — 06'
Command class 06 allows for a single numeric expression to be evaluated.

L190E:

RST 28H
DEFW EXPT_1NUM
RET

Code 06 enters here. Delegate handling to ROM 1.
$1C82.

Report C — Nonsense in BASIC

L1912:

CALL L05AC

DEFB $0B

Produce error report. [Could have saved 4 bytes by using the identical routine at
$1219 (ROM 0) instead]
"C Nonsense in BASIC"

The 'Command Class — 0A'
Command class 0A allows for a single string expression to be evaluated.

L1916:

RST 28H
DEFW EXPT_EXP
RET

Code 0A enters here. Delegate handling to ROM 1.
$1C8C.

The 'Command Class — 07'
Command class 07 is the command routine for the six colour item commands.
Makes the current temporary colours permanent.

L191A:

L1927:

BIT 7,(IY+$01)
RES 0,(IY+$02)
JR Z,L1927
RST 28H
DEFW TEMPS
POP AF
LD A,($5C74)
SUB (L177F & $00FF)+$28
RST 28H
DEFW CO_TEMP_4
CALL L18A1
LD HL,($5C8F)
LD ($5C8D),HL
LD HL,$5C91
LD A,(HL)

The syntax/run flag is read.
TV_FLAG. Signal 'main screen'.
Jump ahead if syntax checking.
Only during a 'run' call TEMPS to ensure the temporary
$0D4D. colours are the main screen colours.
Drop the return address.
T_ADDR.
Reduce to range $D9-$DE which are the token codes for INK to OVER.

$21FC. Change the temporary colours as directed by the BASIC statement.
Move on to the next statement if checking syntax.
ATTR_T. Now the temporary colour
ATTR_P. values are made permanent
P_FLAG.
Value of P_FLAG also has to be considered.

The following instructions cleverly copy the even bits of the supplied byte to the odd bits.
In effect making the permanent bits the same as the temporary ones.

101

SPECTRUM 128 ROM 0 DISASSEMBLY

RLCA
XOR (HL)
AND $AA
XOR (HL)
LD (HL),A
RET

Move the mask leftwards.
Impress onto the mask
only the even bits of the
other byte.
Restore the result.

The 'Command Class — 09'
This routine is used by PLOT, DRAW & CIRCLE statements in order to specify the default conditions of 'FLASH 8; BRIGHT 8; PAPER 8;' that are set
up before any embedded colour items are considered.

L1944:

RST 28H
DEFW CLASS_09
RET

Code 09 enters here. Delegate handling to ROM 1.
$1CBE.

The 'Command Class — 0B'
This routine is used by SAVE, LOAD, VERIFY & MERGE statements.

L1948:

POP AF
LD A,(FLAGS3)
AND $0F
LD (FLAGS3),A
LD A,($5C74)
SUB 1+(L1773 & $00FF)
LD ($5C74),A
JP Z,L11EB
DEC A
JP Z,L11F2
DEC A
JP Z,L11F9
JP L1200

Drop the return address.
$5B66.
Clear LOAD/SAVE/VERIFY/MERGE indication bits.
$5B66.
T_ADDR-lo.
Correct by $74 so that SAVE = $00, LOAD = $01, VERIFY = $02, MERGE = $03.
T_ADDR-lo.
Jump to handle SAVE.

Jump to handle LOAD.

Jump to handle VERIFY.
Jump to handle MERGE.

IF Routine
On entry the value of the expression between the IF and the THEN is the 'last value' on the calculator stack. If this is logically true then the next statement
is considered; otherwise the line is considered to have been finished.

L1967:

POP BC
BIT 7,(IY+$01)
JR Z,L197E

Drop the return address.

Jump forward if checking syntax.

Now 'delete' the last value on the calculator stack

L196E:

L197E:

LD HL,($5C65)
LD DE,$FFFB
ADD HL,DE
LD ($5C65),HL
RST 28H
DEFW TEST_ZERO
JP C,L1863
JP L17C1

STKEND.
-5
The present 'last value' is deleted.
STKEND. HL point to the first byte of the value.

$34E9. Is the value zero?
If the value was 'FALSE' jump to the next line.
But if 'TRUE' jump to the next statement (after the THEN).

FOR Routine
This command routine is entered with the VALUE and the LIMIT of the FOR statement already on the top of the calculator stack.

L1981:

CP $CD
JR NZ,L198E
RST 20H

Jump forward unless a 'STEP' is given.

Advance pointer

102

SPECTRUM 128 ROM 0 DISASSEMBLY

CALL L190E
CALL L18A1
JR L19A6

Indirectly call EXPT_1NUM in ROM 1 to get the value of the STEP.
Move on to the next statement if checking syntax.
Otherwise jump forward.

There has not been a STEP supplied so the value '1' is to be used.

L198E:

CALL L18A1
LD HL,($5C65)
LD (HL),$00
INC HL
LD (HL),$00
INC HL
LD (HL),$01
INC HL
LD (HL),$00
INC HL
LD (HL),$00
INC HL
LD ($5C65),HL

Move on to the next statement if checking syntax.
STKEND.

Place a value of 1 on the calculator stack.

STKEND.

The three values on the calculator stack are the VALUE (v), the LIMIT (l) and the STEP (s).
These values now have to be manipulated. Delegate handling to ROM 1.

L19A6:

RST 28H
DEFW F_REORDER
RET

$1D16.

READ Routine

L19AA:
L19AB:

RST 20H
CALL L18F9

BIT 7,(IY+$01)
JR Z,L19E2
RST 18H
LD ($5C5F),HL
LD HL,($5C57)
LD A,(HL)
CP $2C
JR Z,L19CB
LD E,$E4
RST 28H
DEFW LOOK_PROG
JR NC,L19CB
CALL L05AC
DEFB $0D

Pick up a value from the DATA list.

L19CB:

L19E2:

L19E5:

INC HL
LD ($5C5D),HL
LD A,(HL)
RST 28H
DEFW VAL_FET_1
RST 18H
LD ($5C57),HL
LD HL,($5C5F)
LD (IY+$26),$00
LD ($5C5D),HL
LD A,(HL)
RST 18H
CP ','
JR Z,L19AA

Come here on each pass, after the first, to move along the READ statement.
Indirectly call CLASS_01 in ROM 1 to consider whether the variable has been used
before, and find the existing entry if it has.

Jump forward if checking syntax.
Save the current pointer CH_ADD in X_PTR.
X_PTR.
DATADD.
Fetch the current DATA list pointer
and jump forward unless a new
DATA statement has to be found.
The search is for 'DATA'.

$1D86.
Jump forward if the search is successful.
Produce error report.
"E Out of Data"

Advance the pointer along the DATA list.
CH_ADD.

$1C56. Fetch the value and assign it to the variable.

DATADD.
X_PTR. Fetch the current value of CH_ADD and store it in DATADD.
X_PTR_hi. Clear the address of the character after the '?' marker.
CH_ADD. Make CH-ADD once again point to the READ statement.

GET the present character
$2C. Check if it is a ','.
If it is then jump back as there are further items.

103

SPECTRUM 128 ROM 0 DISASSEMBLY

CALL L18A1
RET

Return if checking syntax
or here if not checking syntax.

DATA Routine
During syntax checking a DATA statement is checked to ensure that it contains a series of valid expressions, separated by commas. But in 'run-time'
the statement is passed by.

L19EB:

BIT 7,(IY+$01)
JR NZ,L19FC

Jump forward unless checking syntax.

A loop is now entered to deal with each expression in the DATA statement.

L19F1:

RST 28H
DEFW SCANNING
CP ','
CALL NZ,L18A1
RST 20H
JR L19F1

$24FB. Scan the next expression.
$2C. Check for the correct separator ','.
but move on to the next statement if not matched.
Whilst there are still expressions to be checked
go around again.

The DATA statement has to be passed-by in 'run-time'.

L19FC:

LD A,$E4

It is a 'DATA' statement that is to be passed-by.

On entry the A register will hold either the token 'DATA' or the token 'DEF FN' depending on the type of statement that is being 'passed-by'.

L19FE:

RST 28H
DEFW PASS_BY
RET

$1E39. Delegate handling to ROM 1.

RUN Routine
The parameter of the RUN command is passed to NEWPPC by calling the GO TO command routine.
The operations of 'RESTORE 0' and 'CLEAR 0' are then performed before a return is made.

L1A02:

RST 28H
DEFW GO_TO
LD BC,$0000
RST 28H
DEFW REST_RUN
JR L1A10

$1E67.
Now perform a 'RESTORE 0'.

$1E45.
Exit via the CLEAR command routine.

CLEAR Routine
This routine allows for the variables area to be cleared, the display area cleared and RAMTOP moved. In consequence of the last operation the machine
stack is rebuilt thereby having the effect of also clearing the GO SUB stack.

L1A0D:

L1A10:

L1A18:

RST 28H
DEFW FIND_INT2
LD A,B
OR C
JR NZ,L1A18
LD BC,($5CB2)
PUSH BC
LD DE,($5C4B)
LD HL,($5C59)
DEC HL
RST 28H
DEFW RECLAIM
RST 28H
DEFW CLS

$1E99. Fetch the operand - using zero by default.
Jump forward if the operand is
other than zero. When called
from RUN there is no jump.
RAMTOP. Use RAMTOP if the parameter is 0.
BC = Address to clear to. Save it.
VARS.
E LINE.

Delete the variables area.
$19E5.
Clear the screen
$0D6B.

104

The value in the BC register pair which will be used as RAMTOP is tested to ensure it is neither too low nor too high.

SPECTRUM 128 ROM 0 DISASSEMBLY

L1A3B:

L1A3F:

LD HL,($5C65)
LD DE,$0032
ADD HL,DE
POP DE
SBC HL,DE
JR NC,L1A3B
LD HL,($5CB4)
AND A
SBC HL,DE
JR NC,L1A3F
CALL L05AC
DEFB $15
LD ($5CB2),DE
POP DE
POP HL
POP BC

LD SP,($5CB2)
INC SP
PUSH BC
PUSH HL
LD ($5C3D),SP
PUSH DE
RET

STKEND. The current value of STKEND
is increased by 50 before
being tested. This forms the
ADE = address to clear to lower limit.

Ramtop no good.
P_RAMT. For the upper test the value
for RAMTOP is tested against P_RAMT.

Jump forward if acceptable.
Produce error report.
"M Ramtop no good"
RAMTOP.
Retrieve interpreter return address from stack
Retrieve 'error address' from stack
Retrieve the GO SUB stack end marker. [BUG - It is assumed that the top of the
GO SUB stack will be empty and hence only contain the end marker. This will not
be the case if CLEAR is used within a subroutine, in which case BC will now hold
the calling line number and this will be stacked in place of the end marker. When a
RETURN command is encountered, the GO SUB stack appears to contain an entry
since the end marker was not the top item. An attempt to return is therefore made.
The CLEAR command handler within the 48K Spectrum ROM does not make any
assumption about the contents of the GO SUB stack and instead always re-inserts
the end marker. The bug could be fixed by inserting the line LD BC,$3E00 after the
POP BC. Credit: Ian Collier (+3), Paul Farrow (128)]
RAMTOP.

Stack the GO SUB stack end marker.
Stack 'error address'.
ERR_SP.
Stack the interpreter return address.

GO SUB Routine
The present value of PPC and the incremented value of SUBPPC are stored on the GO SUB stack.

L1A53:

POP DE
LD H,(IY+$0D)
INC H
EX (SP),HL
INC SP
LD BC,($5C45)
PUSH BC
PUSH HL
LD ($5C3D),SP
PUSH DE
RST 28H
DEFW GO_TO
LD BC,$0014
RST 28H
DEFW TEST_ROOM
RET

Save the return address.
SUBPPC. Fetch the statement number and increment it.

Exchange the 'error address' with the statement number.
Reclaim the use of a location.
PPC.
Next save the present line number.
Return the 'error address' to the machine stack
ERR-SP. and reset ERR-SP to point to it.
Stack the return address.

$1E67. Now set NEWPPC & NSPPC to the required values.
But before making the jump make a test for room.

$1F05. Will automatically produce error '4' if out of memory.

RETURN Routine
The line number and the statement number that are to be made the object of a 'return' are fetched from the GO SUB stack.

L1A6F:

POP BC
POP HL
POP DE
LD A,D

Fetch the return address.
Fetch the 'error address'.
Fetch the last entry on the GO SUB stack.
The entry is tested to see if

105

CP $3E
JR Z,L1A86
DEC SP
EX (SP),HL
EX DE,HL
LD ($5C3D),SP
PUSH BC
LD ($5C42),HL
LD (IY+$0A),D
RET
PUSH DE
PUSH HL
CALL L05AC
DEFB $06

L1A86:

SPECTRUM 128 ROM 0 DISASSEMBLY

it is the GO SUB stack end marker.
Jump if it is.
The full entry uses three locations only.
Exchange the statement number with the 'error address'.
Move the statement number.
ERR_SP. Reset the error pointer.
Replace the return address.
NEWPPC. Enter the line number.
NSPPC. Enter the statement number.

Replace the end marker and
the 'error address'.
Produce error report.
"7 RETURN without GO SUB"

DEF FN Routine
During syntax checking a DEF FN statement is checked to ensure that it has the correct form.
Space is also made available for the result of evaluating the function.
But in 'run-time' a DEF FN statement is passed-by.

L1A8C:

BIT 7,(IY+$01)
JR Z,L1A97
LD A,$CE
JP L19FE

First consider the variable of the function.

Jump forward if checking syntax.
Otherwise bass-by the
'DEF FN' statement.

L1A97:

L1AAA:

SET 6,(IY+$01)
RST 28H
DEFW ALPHA
JR NC,L1AB6
RST 20H
CP '$'
JR NZ,L1AAA
RES 6,(IY+$01)
RST 20H
CP '('
JR NZ,L1AEA
RST 20H
CP ')'
JR Z,L1AD3

Signal 'a numeric variable'.

$2C8D. Check that the present code is a letter.
Jump forward if not.
Fetch the next character.
$24.
Jump forward unless it is a '$'.
Change bit 6 as it is a string variable.
Fetch the next character.
$28. A '(' must follow the variable's name.
Jump forward if not.
Fetch the next character
$29. Jump forward if it is a ')'
as there are no parameters of the function.

A loop is now entered to deal with each parameter in turn.

L1AB3:

L1AB6:

L1AC1:

RST 28H
DEFW ALPHA
JP NC,L1912
EX DE,HL
RST 20H
CP '$'
JR NZ,L1AC1
EX DE,HL
RST 20H
EX DE,HL
LD BC,$0006
RST 28H
DEFW MAKE_ROOM
INC HL
INC HL
LD (HL),$0E
CP ','
JR NZ,L1AD3
RST 20H
JR L1AB3

$2C8D.
The present code must be a letter.
Save the pointer in DE.
Fetch the next character.
$24.
Jump forward unless it is a '$'.
Otherwise save the new pointer in DE instead.
Fetch the next character.
Move the pointer to the last character of the name to HL.
Now make six locations after that last character.

$1655.

Enter a 'number marker' into the first of the new locations.
$2C. If the present character is a ',' then jump back as
there should be a further parameter.

Otherwise jump out of the loop.

106

SPECTRUM 128 ROM 0 DISASSEMBLY

$29. Check that the ')' does exist.
Jump if not.
The next character is fetched.
$3D. It must be an '='.
Jump if not.
Fetch the next character.
FLAGS.
Save the nature (numeric or string) of the variable

$24FB. Now consider the definition as an expression.
Fetch the nature of the variable.
FLAGS. Check that it is of the same type
as found for the definition.
Give an error report if required.
Move on to consider the next statement in the line.

Next the definition of the function is considered.

L1AD3:

L1AEA:

CP ')'
JR NZ,L1AEA
RST 20H
CP '='
JR NZ,L1AEA
RST 20H
LD A,($5C3B)
PUSH AF
RST 28H
DEFW SCANNING
POP AF
XOR (IY+$01)
AND $40
JP NZ,L1912
CALL L18A1

MOVE Routine

L1AF0:

RET

Simply return.

MENU ROUTINES — PART 1

Run Tape Loader
Used by Main Menu - Tape Loader option.

L1AF1:

LD HL,$EC0E
LD (HL),$FF
CALL L1F20
RST 28H
DEFW SET_MIN
LD HL,($5C59)
LD BC,$0003
RST 28H
DEFW MAKE_ROOM
LD HL,L1B6E
LD DE,($5C59)
LD BC,$0003
LDIR
CALL L026B

List Program to Printer
Used by Edit Menu - Print option.

L1B14:

CALL L1F20
RST 28H
DEFW SET_MIN
LD HL,($5C59)
LD BC,$0001
RST 28H
DEFW MAKE_ROOM
LD HL,($5C59)
LD (HL),$E1
CALL L026B

Fetch mode.
Set Tape Loader mode.
Use Normal RAM Configuration (physical RAM bank 0).

$16B0. Clear out editing area.
E_LINE.
Create 3 bytes of space for the LOAD "" command.

$1655.
Address of command bytes for LOAD "".
E_LINE.

Copy LOAD "" into the line editing area.
Parse and execute the BASIC line. [Will not return here but will exit via the error
handler routine]

Use Normal RAM Configuration (physical RAM bank 0).

$16B0. Clear out editing area.
E_LINE.
Create 1 byte of space.

$1655.
E_LINE.
Copy LLIST into the line editing area.
Parse and execute the BASIC line. [Will not return here but will exit via the error
handler routine]

107

SPECTRUM 128 ROM 0 DISASSEMBLY

BASIC LINE AND COMMAND INTERPRETATION ROUTINES — PART 2

SPECTRUM Routine
Return to 48K BASIC Mode. This routine will force caps lock is off.

L1B2B:

CALL L1B53
LD SP,($5C3D)
POP HL
LD HL,MAIN_4
PUSH HL
LD HL,PRINT_A_1+$0003
PUSH HL
LD HL,ERROR_1
PUSH HL

Overwrite 'P' channel data to use the ZX Printer.
ERR_SP. Purge the stack.
Remove error handler address.
$1303. The main execution loop within ROM 1.

$0013. Address of a $FF byte within ROM 1, used to generate error report "0 OK".

$0008. The address of the error handler within ROM 1.

[BUG - Although the channel 'P' information has been reconfigured to use the ZX Printer, the ZX printer buffer and associated system variables still need
to be cleared. Failure to do so means that the first use of the ZX Printer will cause garbage to the printed, i.e. the paging routines and new system variables
still present in the ZX Printer buffer. Subsequently printer output will then be ok since the ZX Printer buffer and system variables will be cleared. Worse
still, there is the possibility that new data to be printed will be inserted beyond the ZX Printer buffer since ROM 1 does not trap whether the ZX Printer
system variable PR_POSN and PR_CC hold invalid values. The bug can be fixed by inserting the following instructions, which cause the ZX Printer buffer
to be cleared immediately after switching to ROM 1 and before the error report "0 OK" is produced. Credit: Paul Farrow and Andrew Owen.]

LD HL,CLEAR_PRB

Address of the routine in ROM 1 to clear the ZX Printer buffer and associated
system variables.

PUSH HL
SET 1,(IY+$01)

LD A,$20
LD (BANK_M),A
JP SWAP

FLAGS. Signal the printer is in use.]

Force 48K mode.
$5B5C.
$5B00. Swap to ROM 1 and return via a RST $08 / DEFB $FF.

MENU ROUTINES — PART 2

Main Menu — 48 BASIC Option

L1B47:

LD HL,$0000
PUSH HL
LD A,$20
LD (BANK_M),A
JP SWAP

Stack a $0000 address to return to.

Force 48 mode.
$5B5C
$5B00. Swap to ROM 1, return to $0000.

Set 'P' Channel Data
This routine overwrites the 'P' channel data with the 'S' channel data, i.e. the default values when using the ZX Printer.

L1B53:

LD HL,($5C4F)
LD DE,$0005
ADD HL,DE
LD DE,$000A
EX DE,HL
ADD HL,DE
EX DE,HL
LD BC,$0004
LDIR
RES 3,(IY+$30)

RES 4,(IY+$01)
RET

CHANS.

HL=Address 'S' channel data.

HL=$000A, DE=Address 'S' channel data.
HL=Address 'P' channel data.
DE=Address 'P' channel data, HL=Address 'S' channel data.

Copy the 'S' channel data over the 'P' channel data.
FLAGS2. Signal caps lock unset. [Not really necessary for switching back to 48
BASIC mode]
FLAGS. Signal not 128K mode.

108

SPECTRUM 128 ROM 0 DISASSEMBLY

LOAD "" Command Bytes
Used by the Tape Loader routine.

L1B6E:

DEFB $EF, $22, $22

LOAD ""

BASIC LINE AND COMMAND INTERPRETATION ROUTINES — PART 3

LLIST Routine

L1B71:

LD A,$03
JR L1B77

Printer channel.
Jump ahead to join LIST.

LIST Routine

L1B75:
L1B77:

L1B83:

L1B96:

L1B9E:

LD A,$02
LD (IY+$02),$00
RST 28H
DEFW SYNTAX_Z
JR Z,L1B83
RST 28H
DEFW CHAN_OPEN
RST 28H
DEFW GET_CHAR
RST 28H
DEFW STR_ALTER
JR C,L1BA3
RST 28H
DEFW GET_CHAR
CP $3B
JR Z,L1B96
CP ','
JR NZ,L1B9E
RST 28H
DEFW NEXT_CHAR
CALL L190E

JR L1BA6
RST 28H
DEFW USE_ZERO
JR L1BA6

Come here if the stream was unaltered.

L1BA3:

L1BA6:

RST 28H
DEFW FETCH_NUM
CALL L18A1
RST 28H
DEFW LIST_5+3
RET

RAM Disk SAVE! Routine

Main screen channel.
TV_FLAG. Signal 'an ordinary listing in the main part of the screen'.

$2530.
Do not open the channel if checking syntax.

$1601. Open the channel.

$0018. [Could just do RST $18]

$2070. See if the stream is to be changed.
Jump forward if unchanged.

$0018. Get current character.
Is it a ';'?
Jump if it is.
$2C. Is it a ','?
Jump if it is not.

$0020. Get the next character.
Indirectly call EXPT-1NUM in ROM 1 to check that a numeric expression follows,
e.g. LIST #5,20.
Jump forward with it.

$1CE6. Otherwise use zero and
jump forward.

$1CDE. Fetch any line or use zero if none supplied.
If checking the syntax of the edit-line move on to the next statement.

$1825. Delegate handling to ROM 1.

L1BAD:

LD (OLDSP),SP
LD SP,TSTACK
CALL L1C97
LD BC,(HD_0B)

$5B81. Save SP.
$5BFF. Use temporary stack.
Create new catalogue entry.
$5B72. get the length of the file.

109

LD HL,$FFF7
OR $FF
SBC HL,BC
CALL L1CF3
LD BC,$0009
LD HL,HD_00
CALL L1DAC
LD HL,(HD_0D)
LD BC,(HD_0B)
CALL L1DAC
CALL L1D56
LD A,$05
CALL L1C64
LD SP,(OLDSP)
RET

SPECTRUM 128 ROM 0 DISASSEMBLY

-9 (9 is the length of the file header).
Extend the negative number into the high byte.
AHL=-(length of file + 9).
Check for space in RAM disk (produce "4 Out of memory" if no room).
File header length.
$5B71. Address of file header.
Store file header to RAM disk.
$5B74. Start address of file data.
$5B72. Length of file data.
Store bytes to RAM disk.
Update catalogue entry (leaves logical RAM bank 4 paged in).
Page in logical RAM bank 5 (physical RAM bank 0).

$5B81. Use original stack.

CAT! Routine

L1BE5:

RST 28H
DEFW GET_CHAR
CP '!'
JP NZ,L1912
RST 28H
DEFW NEXT_CHAR
CALL L18A1
LD A,$02
RST 28H
DEFW CHAN_OPEN
LD (OLDSP),SP
LD SP,TSTACK
CALL L20D2
LD A,$05
CALL L1C64
LD SP,(OLDSP)
RET

Get the current character.
$0018. [Could just do RST $18 here]
$21. Is it '!'?
Jump to "C Nonsense in BASIC" if not.
Get the next character.
$0020. [Could just do RST $20 here]
Check for end of statement.
Select main screen.

$1601.
$5B81. Store SP.
$5BFF. Use temporary stack.
Print out the catalogue.
Page in logical RAM bank 5 (physical RAM bank 0).

$5B81. Use original stack.

ERASE! Routine

L1C0C:

RST 28H
DEFW GET_CHAR
CP '!'
JP NZ,L1912
CALL L1393
CALL L18A1
LD (OLDSP),SP
LD SP,TSTACK
CALL L1F5F
LD A,$05
CALL L1C64
LD SP,(OLDSP)
RET

Get character from BASIC line.
$0018.
$21. Is it '!'?
Jump to "C Nonsense in BASIC" if not.
Get the filename into N_STR1.
Make sure we've reached the end of the BASIC statement.
$5B81. Store SP.
$5BFF. Use temporary stack.
Do the actual erasing (leaves logical RAM bank 4 paged in).
Restore RAM configuration.
Page in logical RAM bank 5 (physical RAM bank 0).
$5B81. Use original stack.

RAM DISK COMMAND ROUTINES — PART 2

Load Header from RAM Disk

L1C2E:

LD (OLDSP),SP
LD SP,TSTACK
CALL L1D35

$5B81. Store SP.
$5BFF. Use temporary stack.
Find file (return details pointed to by IX). Leaves logical RAM bank 4 paged in.

110

The file exists else the call above would have produced an error "h file does not exist"

SPECTRUM 128 ROM 0 DISASSEMBLY

LD HL,HD_00
LD BC,$0009
CALL L1E37
LD A,$05
CALL L1C64
LD SP,(OLDSP)
RET

$5B71. Load 9 header bytes.

Load bytes from RAM disk.
Restore RAM configuration.
Page in logical RAM bank 5 (physical RAM bank 0).
$5B81. Use original stack.

Load from RAM Disk
Used by LOAD, VERIFY and MERGE. Note that VERIFY will simply perform a LOAD.
Entry:

HL=Destination address.
DE=Length (will be greater than zero).
IX=File descriptor.
IX=Address of catalogue entry (IX+$10-IX+$12 points to the address of the file's data, past its header).
HD_00-HD_11 holds file header information.

L1C4B:

LD (OLDSP),SP
LD SP,TSTACK
LD B,D
LD C,E
CALL L1E37
CALL L1D56
LD A,$05
CALL L1C64
LD SP,(OLDSP)
RET

$5B81. Store SP
$5BFF. Use temporary stack.

BC=Length.
Load bytes from RAM disk.
Update catalogue entry (leaves logical RAM bank 4 paged in).
Restore RAM configuration.
Page in logical RAM bank 5 (physical RAM bank 0).
$5B81. Use original stack.

PAGING ROUTINES — PART 1

Page Logical RAM Bank
This routine converts between logical and physical RAM banks and pages the selected bank in.
Entry:

A=Logical RAM bank.

L1C64:

PUSH HL
PUSH BC
LD HL,L1C81
LD B,$00
LD C,A
ADD HL,BC
LD C,(HL)
DI
LD A,(BANK_M)
AND $F8
OR C
LD (BANK_M),A
LD BC,$7FFD
OUT (C),A
EI
POP BC
POP HL
RET

Save BC and HL.

Physical banks used by RAM disk.

BC=Logical RAM bank.
Point to table entry.
Look up physical page.
Disable interrupts whilst paging.
$5B5C. Fetch the current configuration.
Mask off current RAM bank.
Include new RAM bank.
$5B5C. Store the new configuration.

Perform the page.
Re-enable interrupts.
Restore BC and HL.

Physical RAM Bank Mapping Table

L1C81:

DEFB $01

Logical bank $00.

111

SPECTRUM 128 ROM 0 DISASSEMBLY

DEFB $03
DEFB $04
DEFB $06
DEFB $07
DEFB $00

Logical bank $01.
Logical bank $02.
Logical bank $03.
Logical bank $04.
Logical bank $05.

RAM DISK COMMAND ROUTINES — PART 3

Compare Filenames
Compare filenames at N_STR1 and IX.
Exit: Zero flag set if filenames match.
Carry flag set if filename at DE is alphabetically lower than filename at IX.

L1C87:

LD DE,N_STR1

$5B67.

Compare filenames at DE and IX

L1C8A:

L1C8F:

PUSH IX
POP HL
LD B,$0A
LD A,(DE)
INC DE
CP (HL)
INC HL
RET NZ
DJNZ L1C8F
RET

Maximum of 10 characters.

compare each character.

Return if characters are different.
Repeat for all characters of the filename.

Create New Catalogue Entry
Add a catalogue entry with filename contained in N_STR1.
Exit: HL=Address of next free catalogue entry.
IX=Address of newly created catalogue entry.

L1C97:

CALL L1D12

L1CA0:

L1CBE:

JR Z,L1CA0
CALL L05AC
DEFB $20
PUSH IX
LD BC,$3FEC
ADD IX,BC

POP IX
JR NC,L1D0E
LD HL,$FFEC
LD A,$FF
CALL L1CF3
LD HL,FLAGS3
SET 2,(HL)
PUSH IX
POP DE
LD HL,N_STR1
LD BC,$000A
LDIR
SET 0,(IX+$13)
LD A,(IX+$0A)
LD (IX+$10),A
LD A,(IX+$0B)
LD (IX+$11),A

Find entry in RAM disk area, returning IX pointing to catalogue entry (leaves logical
RAM bank 4 paged in).
Jump ahead if does not exist.
Produce error report.
"e File already exists"

16384-20 (maximum size of RAM disk catalogue).
IX grows downwards as new RAM disk catalogue entries added. If adding the
maximum size to IX does not result in the carry flag being set then the catalogue is
full, so issue an error report "4 Out of Memory".

Jump if out of memory.
-20 (20 bytes is the size of a RAM disk catalogue entry).
Extend the negative number into the high byte.
Ensure space in RAM disk area.
$5B66.
Signal editing RAM disk catalogue.

DE=Address of new catalogue entry.
$5B67. Filename.
10 characters in the filename.
Copy the filename.
Indicate catalogue entry requires updating.
Set the file access address to be the
start address of the file.

112

LD A,(IX+$0C)
LD (IX+$12),A
XOR A
LD (IX+$0D),A
LD (IX+$0E),A
LD (IX+$0F),A
LD A,$05
CALL L1C64
PUSH IX
POP HL
LD BC,$FFEC
ADD HL,BC
LD (SFNEXT),HL
RET

SPECTRUM 128 ROM 0 DISASSEMBLY

Set the fill length to zero.

Logical RAM bank 5 (physical RAM bank 0).

HL=Address of new catalogue entry.
-20 (20 bytes is the size of a catalogue entry).

$5B83. Store address of next free catalogue entry.

Adjust RAM Disk Free Space
Adjust the count of free bytes within the RAM disk.
The routine can produce "4 Out of memory" when adding.
Entry:

AHL=Size adjustment (negative when a file added, positive when a file deleted).
A=Bit 7 set for adding data, else deleting data.

L1CF3:

Deleting data

L1D03:

Adding data

L1D0A:

L1D0E:

LD DE,(SFSPACE)
EX AF,AF'
LD A,(SFSPACE+2)
LD C,A
EX AF,AF'
BIT 7,A
JR NZ,L1D0A

ADD HL,DE
ADC A,C
LD (SFSPACE),HL
LD (SFSPACE+2),A
RET

ADD HL,DE
ADC A,C
JR C,L1D03
CALL L05AC
DEFB 03

$5B85.
A'HL=Requested space.
$5B87. ADE=Free space on RAM disk.
CDE=Free space.
AHL=Requested space.
A negative adjustment, i.e. adding data?
Jump ahead if so.

AHL=Free space left.
$5B85. Store free space.
$5B87.

Jump back to store free space if space left.
Produce error report.
"4 Out of memory"

Find Catalogue Entry for Filename

L1D12:

L1D1B:

L1D2E:

LD A,$04
CALL L1C64
LD IX,$EBEC
LD DE,(SFNEXT)
OR A
PUSH IX
POP HL
SBC HL,DE
RET Z
CALL L1C87
JR NZ,L1D2E
OR $FF
RET
LD BC,$FFEC

Page in logical RAM bank 4 (physical RAM bank 7).

Point to first catalogue entry.
$5B83. Pointer to last catalogue entry.
Clear carry flag.

HL=First catalogue entry.

Return with zero flag set if end of catalogue reached and hence filename not found.
Test filename match with N_STR1 ($5B67).
Jump ahead if names did not match.
Reset zero flag to indicate filename exists.

-20 bytes (20 bytes is the size of a catalogue entry).

113

SPECTRUM 128 ROM 0 DISASSEMBLY

ADD IX,BC
JR L1D1B

Point to the next directory entry.
Test the next name.

Find RAM Disk File
Find a file in the RAM disk matching name held in N_STR1,
and return with IX pointing to the catalogue entry.

L1D35:

CALL L1D12

L1D3E:

JR NZ,L1D3E
CALL L05AC
DEFB $23
LD A,(IX+$0A)
LD (IX+$10),A
LD A,(IX+$0B)
LD (IX+$11),A
LD A,(IX+$0C)
LD (IX+$12),A
LD A,$05
CALL L1C64
RET

Update Catalogue Entry

L1D56:

LD A,$04
CALL L1C64
BIT 0,(IX+$13)
RET Z
RES 0,(IX+$13)
LD HL,FLAGS3
RES 2,(HL)
LD L,(IX+$10)
LD H,(IX+$11)
LD A,(IX+$12)
LD E,(IX+$0A)
LD D,(IX+$0B)
LD B,(IX+$0C)
OR A
SBC HL,DE
SBC A,B
RL H
RL H
SRA A
RR H
SRA A
RR H
LD (IX+$0D),L
LD (IX+$0E),H
LD (IX+$0F),A

Find entry in RAM disk area, returning IX pointing to catalogue entry (leaves logical
RAM bank 4 paged in).
Jump ahead if it exists.
Produce error report.
"h File does not exist"
Take the current start address (bank + location)
and store it as the current working address.

Page in logical RAM bank 5 (physical RAM bank 0).

[Could have saved 1 byte by using JP $1C64 (ROM 0)]

Page in logical RAM bank 4 (physical RAM bank 7).

Ignore if catalogue entry does not require updating.
Indicate catalogue entry updated.
$5B66.
Signal not editing RAM disk catalogue.
Points to end address within logical RAM bank.

Points to end logical RAM bank.
Start address within logical RAM bank.

Start logical RAM bank.
Clear carry flag.
HL=End address-Start address. Maximum difference fits within 14 bits.
A=End logical RAM bank-Start logical RAM bank - 1 if addresses overlap.

Work out how many full banks of 16K are being used.
Place this in the upper two bits of H.

HL=Total length.
Length within logical RAM bank.

Copy the end address of the previous entry into the new entry

LD L,(IX+$10)
LD H,(IX+$11)
LD A,(IX+$12)
LD BC,$FFEC
ADD IX,BC
LD (IX+$0A),L
LD (IX+$0B),H
LD (IX+$0C),A
RET

End address within logical RAM bank.

End logical RAM bank.
-20 bytes (20 bytes is the size of a catalogue entry).
Address of next catalogue entry.
Start address within logical RAM bank.

Start logical RAM bank.

114

SPECTRUM 128 ROM 0 DISASSEMBLY

Check whether a data length of zero was requested.

Ignore if so since all bytes already saved.
Save the source address.
DE=The start of the upper RAM bank.
HL=The start of the RAM bank. DE=Source address.
HL=RAM bank start - Source address.
Jump ahead if saving bytes from $C000.
Jump ahead if saving bytes from an address above $C000.

Save Bytes to RAM Disk

L1DAC:

LD A,B
OR C
RET Z
PUSH HL
LD DE,$C000
EX DE,HL
SBC HL,DE
JR Z,L1DD5
JR C,L1DD5

Source is below $C000

PUSH HL
SBC HL,BC
JR NC,L1DCC

HL=Distance below $C000 (RAM bank start - Source address).

Jump if requested bytes are all below $C000.

Source spans across $C000

LD H,B
LD L,C
POP BC
OR A
SBC HL,BC
EX (SP),HL
LD DE,$C000
PUSH DE
JR L1DF4

HL=Requested length.
BC=Distance below $C000.

HL=Bytes occupying upper RAM bank.
Stack it. HL=Source address.
Start of upper RAM bank.

Jump forward.

Source fits completely below upper RAM bank (less than $C000)

L1DCC:

POP HL
POP HL
LD DE,$0000
PUSH DE
PUSH DE
JR L1DF4

Forget the 'distance below $C000' count.
HL=Source address.
Remaining bytes to transfer.

Stack dummy Start of upper RAM bank.
Jump forward.

Source fits completely within upper RAM bank (greater than or equal $C000)

L1DD5:

LD H,B
LD L,C
LD DE,$0020
OR A
SBC HL,DE
JR C,L1DE4

Source spans transfer buffer

HL=Requested length.
DE=Length of buffer.

HL=Requested length-Length of buffer = Buffer overspill.
Jump if requested length will fit within the buffer.

EX (SP),HL
LD B,D
LD C,E
JR L1DE9

Stack buffer overspill. HL=$0000.

BC=Buffer length.
Jump forward.

Source fits completely within transfer buffer

L1DE4:

POP HL
LD DE,$0000
PUSH DE

Transfer a block

HL=Destination address.
Remaining bytes to transfer.
Stack 'transfer buffer in use' flag.

115

L1DE9:

L1DF4:

L1E05:

L1E0B:

PUSH BC
LD DE,STRIP1
LDIR
POP BC
PUSH HL
LD HL,STRIP1
LD A,$04
CALL L1C64
LD E,(IX+$10)
LD D,(IX+$11)
LD A,(IX+$12)
CALL L1C64
LDI
LD A,D
OR E
JR Z,L1E24
LD A,B
OR C
JP NZ,L1E05
LD A,$04
CALL L1C64
LD (IX+$10),E
LD (IX+$11),D
LD A,$05
CALL L1C64
POP HL
POP BC
JR L1DAC

SPECTRUM 128 ROM 0 DISASSEMBLY

Stack the length.
$5B98. Transfer buffer.
Transfer bytes.
BC=Length.
HL=New source address.
$5B98. Transfer buffer.
Page in logical RAM bank 4 (physical RAM bank 7).

Fetch the address from the current logical RAM bank.
Logical RAM bank.
Page in appropriate logical RAM bank.
Transfer a byte from the file to the required RAM disk location or transfer buffer.

Has DE been incremented to $0000?
Jump if end of RAM bank reached.

Repeat until all bytes transferred.
Page in logical RAM bank 4 (physical RAM bank 7).

Store the next RAM bank source address.
Page in logical RAM bank 5 (physical RAM bank 0).

HL=Source address.
BC=Length.
Re-enter this routine to transfer another block.

The end of a RAM bank has been reached so switch to the next bank

L1E24:

LD A,$04
CALL L1C64
INC (IX+$12)
LD A,(IX+$12)
LD DE,$C000
CALL L1C64
JR L1E0B

Page in logical RAM bank 4 (physical RAM bank 7).

Increment to the new logical RAM bank.
Fetch the new logical RAM bank.
The start of the RAM disk
Page in next RAM bank.
Jump back to transfer another block.

Load Bytes from RAM Disk
Used for loading file header and data.
Entry:

IX=RAM disk catalogue entry address. IX+$10-IX+$12 points to the next address to fetch from the file.
HL=Destination address.
BC=Requested length.

L1E37:

LD A,B
OR C
RET Z
PUSH HL
LD DE,$C000
EX DE,HL
SBC HL,DE
JR Z,L1E67
JR C,L1E67

Destination is below $C000

L1E45:

PUSH HL
SBC HL,BC
JR NC,L1E5C

Code will span across $C000

Check whether a data length of zero was requested.

Ignore if so since all bytes already loaded.
Save the destination address.
DE=The start of the upper RAM bank.
HL=The start of the RAM bank. DE=Destination address.
HL=RAM bank start - Destination address.
Jump if destination is $C000.
Jump if destination is above $C000.

HL=Distance below $C000 (RAM bank start - Destination address).

Jump if requested bytes all fit below $C000.

116

LD H,B
LD L,C
POP BC
OR A
SBC HL,BC
EX (SP),HL
LD DE,$0000
PUSH DE
LD DE,$C000
PUSH DE
EX DE,HL
JR L1E80

SPECTRUM 128 ROM 0 DISASSEMBLY

HL=Requested length.
BC=Distance below $C000.

HL=Bytes destined for upper RAM bank.
Stack it. HL=Destination address.
Remaining bytes to transfer.

Start of upper RAM bank.

HL=Start of upper RAM bank.
Jump forward.

Code fits completely below upper RAM bank (less than $C000)

L1E5C:

POP HL
POP HL
LD DE,$0000
PUSH DE
PUSH DE
PUSH DE
EX DE,HL
JR L1E80

Forget the 'distance below $C000' count.
HL=Destination address.
Remaining bytes to transfer.

Stack dummy Start of upper RAM bank.

HL=$0000, DE=Destination address.
Jump forward.

Code destined for upper RAM bank (greater than or equal to $C000)

L1E67:

LD H,B
LD L,C
LD DE,$0020
OR A
SBC HL,DE
JR C,L1E76

Code will span transfer buffer

HL=Requested length.
DE=Length of buffer.

HL=Requested length-Length of buffer = Buffer overspill.
Jump if requested length will fit within the buffer.

EX (SP),HL
LD B,D
LD C,E
JR L1E7B

Stack buffer overspill. HL=$0000.

BC=Buffer length.
Jump forward.

Code will all fit within transfer buffer

L1E76:

L1E7B:

Transfer a block

L1E80:

POP HL
LD DE,$0000
PUSH DE
PUSH BC
PUSH HL
LD DE,STRIP1

LD A,$04
CALL L1C64
LD L,(IX+$10)
LD H,(IX+$11)
LD A,(IX+$12)
CALL L1C64

HL=Destination address.
Remaining bytes to transfer.
Stack 'transfer buffer in use' flag.
Stack the length.
Stack destination address.
$5B98. Transfer buffer.

Page in logical RAM bank 4 (physical RAM bank 7).

RAM bank address.

Logical RAM bank.
Page in appropriate logical RAM bank.

Enter a loop to transfer BC bytes, either to required destination or to the transfer buffer

L1E91:

LDI
LD A,H
OR L
JR Z,L1EBC

Transfer a byte from the file to the required location or transfer buffer.

Has HL been incremented to $0000?
Jump if end of RAM bank reached.

117

L1E97:

L1EB7:

LD A,B
OR C
JP NZ,L1E91
LD A,$04
CALL L1C64
LD (IX+$10),L
LD (IX+$11),H
LD A,$05
CALL L1C64
POP DE
POP BC
LD HL,STRIP1
LD A,B
OR C
JR Z,L1EB7
LDIR
EX DE,HL
POP BC
JP L1E37

SPECTRUM 128 ROM 0 DISASSEMBLY

Repeat until all bytes transferred.
Page in logical RAM bank 4 (physical RAM bank 7).

Store the next RAM bank destination address.
Page in logical RAM bank 5 (physical RAM bank 0).

DE=Destination address.
BC=Length.
$5B98. Transfer buffer.

All bytes transferred?
Jump forward if so.
Transfer code in buffer to the required address.
HL=New destination address.
BC=Remaining bytes to transfer.
Re-enter this routine to transfer another block.

The end of a RAM bank has been reached so switch to the next bank

L1EBC:

LD A,$04
CALL L1C64
INC (IX+$12)
LD A,(IX+$12)
LD HL,$C000
CALL L1C64
JR L1E97

Page in logical RAM bank 4 (physical RAM bank 7).

Increment to the new logical RAM bank.
Fetch the new logical RAM bank.
The start of the RAM disk.
Page in next logical RAM bank.
Jump back to transfer another block.

Transfer Bytes to RAM Bank 4 — Vector Table Entry
This routine can be used to transfer bytes from the current RAM bank into logical RAM bank 4.
It is not used in this ROM and is a remnant of the original Spanish Spectrum 128 ROM 0.
Entry:

HL=Source address in conventional RAM.
DE=Destination address in logical RAM bank 4 (physical RAM bank 7).
BC=Number of bytes to save.

L1ECF:

PUSH AF
LD A,(BANK_M)
PUSH AF
PUSH HL
PUSH DE
PUSH BC
LD IX,N_STR1+3
LD (IX+$10),E
LD (IX+$11),D
LD (IX+$12),$04
CALL L1DAC

Save AF.
$5B5C. Fetch current physical RAM bank configuration.
Save it.
Save source address.
Save destination address.
Save length.
$5B6A.
Store destination address as the current address pointer.

Destination is in logical RAM bank 4 (physical RAM bank 7).
Store bytes to RAM disk.

Entered here by load vector routine

L1EE8:

LD A,$05
CALL L1C64
POP BC
POP DE
POP HL
ADD HL,BC
EX DE,HL
ADD HL,BC
EX DE,HL
POP AF
LD BC,$7FFD
DI

Page in logical RAM bank 5 (physical RAM bank 0).

Get length.
Get destination address.
Get source address.
HL=Address after end of source.
DE=Address after end of source. HL=Destination address.
HL=Address after end of destination.
HL=Address after end of source. DE=Address after end of destination.
Get original RAM bank configuration.

Disable interrupts whilst paging.

118

SPECTRUM 128 ROM 0 DISASSEMBLY

OUT (C),A
LD (BANK_M),A
EI
LD BC,$0000
POP AF
RET

$5B5C.
Re-enable interrupts.
Signal all bytes loaded/saved.
Restore AF.

Transfer Bytes from RAM Bank 4 — Vector Table Entry
This routine can be used to transfer bytes from logical RAM bank 4 into the current RAM bank.
It is not used in this ROM and is a remnant of the original Spanish Spectrum 128 ROM 0.
Entry:

HL=Source address in logical RAM bank 4 (physical RAM bank 7).
DE=Destination address in current RAM bank.
BC=Number of bytes to load.

L1F04:

PUSH AF
LD A,(BANK_M)
PUSH AF
PUSH HL
PUSH DE
PUSH BC
LD IX,N_STR1+3
LD (IX+$10),L
LD (IX+$11),H
LD (IX+$12),$04
EX DE,HL
CALL L1E37
JR L1EE8

Save AF.
$5B5C. Fetch current physical RAM bank configuration.
Save it.
Save source address.
Save destination address.
Save length.
$5B6A.
Store source address as the current address pointer.

Source is in logical RAM bank 4 (physical RAM bank 7).
HL=Destination address.
Load bytes from RAM disk.
Join the save vector routine above.

PAGING ROUTINES — PART 2

Use Normal RAM Configuration
Page in physical RAM bank 0, use normal stack and stack TARGET address.
Entry:

HL=TARGET address.

L1F20:

EX AF,AF'
LD A,$00
DI
CALL L1F3A
POP AF
LD (TARGET),HL
LD HL,(OLDSP)
LD (OLDSP),SP
LD SP,HL
EI
LD HL,(TARGET)
PUSH AF
EX AF,AF'
RET

Save AF.
Physical RAM bank 0.
Disable interrupts whilst paging.
Page in physical RAM bank 0.
AF=Address on stack when CALLed.
$5B58. Store HL.
$5B81. Fetch the old stack.
$5B81. Save the current stack.
Use the old stack.
Re-enable interrupts.
$5B58. Restore HL.
Re-stack the return address.
Get AF back.

Select RAM Bank
Used twice by the ROM to select either physical RAM bank 0 or physical RAM bank 7.
However, it could in theory also be used to set other paging settings.
Entry:

A=RAM bank number.

L1F3A:

PUSH BC
LD BC,$7FFD
OUT (C),A

Save BC

Perform requested paging.

119

SPECTRUM 128 ROM 0 DISASSEMBLY

LD (BANK_M),A
POP BC
RET

$5B5C.
Restore BC.

Use Workspace RAM Configuration
Page in physical RAM bank 7, use workspace stack and stack TARGET address.
Entry:

HL=TARGET address.

L1F45:

EX AF,AF'
DI
POP AF
LD (TARGET),HL
LD HL,(OLDSP)
LD (OLDSP),SP
LD SP,HL
LD HL,(TARGET)
PUSH AF
LD A,$07
CALL L1F3A
EI
EX AF,AF'
RET

Save A.
Disable interrupts whilst paging.
Fetch return address.
$5B58. Store HL.
$5B81. Fetch the old stack.
$5B81. Save the current stack.
Use the old stack.
$5B58. Restore HL.
Stack return address.
RAM bank 7.
Page in RAM bank 7.
Re-enable interrupts.
Restore A.

RAM DISK COMMAND ROUTINES — PART 4

Erase a RAM Disk File
N_STR1 contains the name of the file to erase.

L1F5F:

CALL L1D12

L1F68:

JR NZ,L1F68

CALL L05AC
DEFB $23
LD L,(IX+$0D)
LD H,(IX+$0E)
LD A,(IX+$0F)
CALL L1CF3
PUSH IY
LD IY,(SFNEXT)
LD BC,$FFEC
ADD IX,BC
LD L,(IY+$0A)
LD H,(IY+$0B)
LD A,(IY+$0C)
POP IY
LD E,(IX+$0A)
LD D,(IX+$0B)
LD B,(IX+$0C)
OR A
SBC HL,DE
SBC A,B
RL H
RL H
SRA A
RR H
SRA A
RR H
LD BC,$0014
ADD IX,BC
LD (IX+$10),L

Find entry in RAM disk area, returning IX pointing to catalogue entry (leaves logical
RAM bank 4 paged in).
Jump ahead if it was found. [Could have saved 3 bytes by using JP Z,$1D3E (ROM
0)]
Produce error report.
"h File does not exist"
AHL=Length of file.

Bit 7 of A will be 0 indicating to delete rather than add.
Free up this amount of space.
Preserve current value of IY.
$5B83. IY points to next free catalogue entry.
BC=-20 (20 bytes is the size of a catalogue entry).
IX points to the next catalogue entry
AHL=First spare byte in RAM disk file area.

Restore IY to normal value.
BDE=Start of address of next RAM disk file entry.

HL=Length of all files to be moved.
20 bytes is the size of a catalogue entry.
IX=Catalogue entry to delete.
Store file length in the 'deleted' catalogue entry.

120

LD (IX+$11),H
LD (IX+$12),A
LD BC,$FFEC
ADD IX,BC
LD L,(IX+$0A)
LD H,(IX+$0B)
LD D,(IX+$0C)
LD BC,$0014
ADD IX,BC
LD A,D
CALL L1C64
LD A,(BANK_M)
LD E,A
LD BC,$7FFD
LD A,$07
DI
OUT (C),A
EXX
LD L,(IX+$0A)
LD H,(IX+$0B)
LD D,(IX+$0C)
LD A,D
CALL L1C64
LD A,(BANK_M)
LD E,A
LD BC,$7FFD
EXX

SPECTRUM 128 ROM 0 DISASSEMBLY

-20 (20 bytes is the size of a catalogue entry).
IX=Next catalogue entry.
DHL=Start address of next RAM disk file entry.

20 bytes is the size of a catalogue entry.
IX points to catalogue entry to delete.
Page in logical RAM bank for start address of entry to delete.

$5B5C.
Save current RAM bank configuration in E.
Select physical RAM bank 7.

Disable interrupts whilst performing paging operations.
Page in selected RAM bank.
DHL'=Start address of next RAM disk file entry.
DHL=Start of address of RAM disk file entry to delete.

Page in logical RAM bank for file entry (will update BANK_M).
$5B5C.
Get RAM bank configuration for the file in E.

DHL=Start address of next RAM disk file entry.

At this point we have the registers and alternate registers pointing to the actual bytes in the RAM disk for the file to be deleted and the next file, with
length bytes of the catalogue entry for the file to be deleted containing the length of bytes for all subsequent files that need to be moved down in memory.
A loop is entered to move all of these bytes where the delete file began.
DHL holds the address of the byte to be moved.
E contains the value which should be OUTed to $5B5C to page in the relevant RAM page.

L1FEA:

L200D:

L2024:

LD A,$07
DI
OUT (C),A
LD A,(IX+$10)
SUB $01
LD (IX+$10),A
JR NC,L200D
LD A,(IX+$11)
SUB $01
LD (IX+$11),A
JR NC,L200D
LD A,(IX+$12)
SUB $01
LD (IX+$12),A
JR C,L203E
OUT (C),E
LD A,(HL)
INC L
JR NZ,L2024
INC H
JR NZ,L2024
EX AF,AF'
INC D
LD A,D
CALL L1C64
LD A,(BANK_M)
LD E,A
LD HL,$C000
EX AF,AF'
EXX
DI
OUT (C),E

Select physical RAM bank 7.
Disable interrupts whilst performing paging operations.
Page in selected RAM bank.
Decrement end address.

If no carry then the decrement is finished.
Otherwise decrement the middle byte.

If no carry then the decrement is finished.
Otherwise decrement the highest byte.

Jump forward if finished moving the file.
Page in RAM bank containing the next file.
Get the byte from the next file.
Increment DHL.
If not zero then the increment is finished.
Otherwise increment the middle byte.
If not zero then the increment is finished.
Save the byte read from the next file.
Advance to next logical RAM bank for the next file.

Page in next logical RAM bank for next file entry (will update BANK_M).
$5B5C.
Get RAM bank configuration for the next file in E.
The next file continues at the beginning of the next RAM bank.
Retrieve the byte read from the next file.
DHL=Address of file being deleted.
Disable interrupts whilst performing paging operations.
Page in next RAM bank containing the next file.

121

LD (HL),A
INC L
JR NZ,L203B
INC H
JR NZ,L203B
INC D
LD A,D
CALL L1C64
LD A,(BANK_M)
LD E,A
LD HL,$C000
EXX
JR L1FEA

L203B:

The file has been moved

L203E:

L2048:

L2061:

L207C:

L2099:

LD A,$04
CALL L1C64
LD A,$00
LD HL,$0014
CALL L1CF3
LD E,(IX+$0D)
LD D,(IX+$0E)
LD C,(IX+$0F)
LD A,D
RLCA
RL C
RLCA
RL C
LD A,D
AND $3F
LD D,A
PUSH IX
PUSH DE
LD DE,$FFEC
ADD IX,DE
POP DE
LD L,(IX+$0A)
LD H,(IX+$0B)
LD A,(IX+$0C)
OR A
SBC HL,DE
SUB C
BIT 6,H
JR NZ,L207C
SET 6,H
DEC A
LD (IX+$0A),L
LD (IX+$0B),H
LD (IX+$0C),A
LD L,(IX+$10)
LD H,(IX+$11)
LD A,(IX+$12)
OR A
SBC HL,DE
SUB C
BIT 6,H
JR NZ,L2099
SET 6,H
DEC A
LD (IX+$10),L
LD (IX+$11),H
LD (IX+$12),A
PUSH IX
POP HL
PUSH DE

SPECTRUM 128 ROM 0 DISASSEMBLY

Store the byte taken from the next file.
Increment DHL.
If not zero then the increment is finished.
Otherwise increment the middle byte.
If not zero then the increment is finished.
Advance to next logical RAM bank for the file being deleted.

Page in next logical RAM bank for file being deleted entry (will update BANK_M).
$5B5C.
Get RAM bank configuration for the file being deleted in E.
The file being deleted continues at the beginning of the next RAM bank.
DHL=Address of byte in next file. DHL'=Address of byte in file being deleted.

Page in logical RAM bank 4 (physical RAM bank 7).

AHL=20 bytes is the size of a catalogue entry.
Delete a catalogue entry.

CDE=File length of file entry to delete.

C=RAM bank.

Mask off upper bits to leave length in this bank (range 0-16383).
DE=Length in this bank.
Save address of catalogue entry to delete.

-20 (20 bytes is the size of a catalogue entry).
Point to next catalogue entry.
DE=Length in this bank.

AHL=File start address.

Will move into next RAM bank?

Jump if same RAM bank.
New address in next RAM bank.
Next RAM bank.

Save new start address of file.

Fetch end address of file.

Will move into next RAM bank?

Jump if same RAM bank.
New address in next RAM bank.
Next RAM bank.

Save new end address of file.

HL=Address of next catalogue entry.

122

LD DE,(SFNEXT)
OR A
SBC HL,DE
POP DE
JR NZ,L2061
LD DE,(SFNEXT)
POP HL
PUSH HL
OR A
SBC HL,DE
LD B,H
LD C,L
POP HL
PUSH HL
LD DE,$0014
ADD HL,DE
EX DE,HL
POP HL
DEC DE
DEC HL
LDDR
LD HL,(SFNEXT)
LD DE,$0014
ADD HL,DE
LD (SFNEXT),HL
RET

SPECTRUM 128 ROM 0 DISASSEMBLY

$5B83.

End of catalogue reached?
DE=Length in this bank.
Jump if not to move next entry.
$5B83. Start address of the next available catalogue entry.

HL=Start address of catalogue entry to delete.

BC=Length of catalogue entries to move.

HL=Start address of catalogue entry to delete.
20 bytes is the size of a catalogue entry.
HL=Start address of previous catalogue entry.
DE=Start address of previous catalogue entry.
HL=Start address of catalogue entry to delete.
DE=End address of catalogue entry to delete.
HL=End address of next catalogue entry.
Move all catalogue entries.
$5B83. Start address of the next available catalogue entry.
20 bytes is the size of a catalogue entry.

$5B83. Store the new location of the next available catalogue entry.

Print RAM Disk Catalogue
This routine prints catalogue filenames in alphabetically order.
It does this by repeatedly looping through the catalogue to find the next 'highest' name.

L20D2:

L20DA:

L20E1:

L210A:

LD A,$04
CALL L1C64
LD HL,L2121
LD BC,L212B
LD IX,$EBEC
CALL L05D6
PUSH IX
EX (SP),HL
LD DE,(SFNEXT)
OR A
SBC HL,DE
POP HL
JR Z,L2111
LD D,H
LD E,L
PUSH HL
PUSH BC
CALL L1C8A
POP BC
POP HL
JR NC,L210A
LD D,B
LD E,C
PUSH HL
PUSH BC
CALL L1C8A
POP BC
POP HL
JR C,L210A
PUSH IX
POP BC
LD DE,$FFEC
ADD IX,DE

Page in logical RAM bank 4
(physical RAM bank 7)
HL points to ten $00 bytes, the initial comparison filename.
BC point to ten $FF bytes.
IX points to first catalogue entry.
Check for BREAK.
Save address of catalogue entry.
HL points to current catalogue entry. Top of stack points to ten $00 data.
$5B83. Find address of next free catalogue entry.

Have we reached end of catalogue?
Fetch address of catalogue entry.
Jump ahead if end of catalogue reached.

DE=Current catalogue entry.

Compare current filename (initially ten $00 bytes).

Jump if current catalogue name is 'above' the previous.

DE=Last filename

Compare current filename (initially ten $FF bytes).

Jump if current catalogue name is 'below' the previous.

BC=Address of current catalogue entry name.
-20 (20 bytes is the size of a catalogue entry).
Point to next catalogue entry.

123

L2111:

JR L20E1
PUSH HL
LD HL,L212B
OR A
SBC HL,BC
POP HL
RET Z
LD H,B
LD L,C
CALL L2135
JR L20DA

SPECTRUM 128 ROM 0 DISASSEMBLY

Check next filename.
HL points to current catalogue entry.
Address of highest theoretical filename data.

Was a new filename to print found?

Return if all filenames printed.

HL=Address of current catalogue entry name.
Print the catalogue entry.
Repeat for next filename.

Print Catalogue Filename Data

L2121:

L212B:

DEFB $00, $00, $00, $00, $00
DEFB $00, $00, $00, $00, $00
DEFB $FF, $FF, $FF, $FF, $FF Highest theoretical filename.
DEFB $FF, $FF, $FF, $FF, $FF

Lowest theoretical filename.

Print Single Catalogue Entry

L2135:

L2152:

PUSH HL
PUSH BC
POP HL
LD DE,N_STR1
LD BC,$000A
LDIR
LD A,$05
CALL L1C64
LD HL,(OLDSP)
LD (OLDSP),SP
LD SP,HL
LD HL,N_STR1
LD B,$0A
LD A,(HL)
PUSH HL
PUSH BC
RST 28H
DEFW PRINT_A_1
POP BC
POP HL
INC HL
DJNZ L2152
LD A,$0D
RST 28H
DEFW PRINT_A_1
RST 28H
DEFW TEMPS
LD HL,(OLDSP)
LD (OLDSP),SP
LD SP,HL
LD A,$04
CALL L1C64
POP HL
RET

Save address of filename.

[No need to transfer BC to HL since they already have the same value].
$5B67. Copy the filename to N_STR1 so that it
is visible when this RAM bank is paged out.

Page in logical RAM bank 5 (physical RAM bank 0).

$5B81.
$5B81. Save temporary stack.
Use original stack.
$5B67. HL points to filename.
10 characters to print.
Print each character of the filename.

$0010.

Print a newline character.

$0010.

$0D4D. Copy permanent colours to temporary colours.
$5B81.
$5B81. Save original stack.
Switch back to temporary stack.
Page in logical RAM bank 4 (physical RAM bank 7).

HL=Address of filename.

124

SPECTRUM 128 ROM 0 DISASSEMBLY

BASIC LINE AND COMMAND INTERPRETATION ROUTINES — PART 4

LPRINT Routine

L2174:

LD A,$03
JR L217A

Printer channel.
Jump ahead.

PRINT Routine

L2178:
L217A:

L2182:

LD A,$02
RST 28H
DEFW SYNTAX_Z
JR Z,L2182
RST 28H
DEFW CHAN_OPEN
RST 28H
DEFW TEMPS
RST 28H
DEFW PRINT_2
CALL L18A1
RET

Main screen channel.

$2530.
Jump forward if syntax is being checked.

$1601.

$0D4D.

$1FDF. Delegate handling to ROM 1.
"C Nonsense in BASIC" during syntax checking if not at end of line or statement.

INPUT Routine
This routine allows for values entered from the keyboard to be assigned to variables. It is also possible to have print items embedded in the INPUT
statement and these items are printed in the lower part of the display.

L218C:

RST 28H
DEFW SYNTAX_Z
JR Z,L2199
LD A,$01
RST 28H
DEFW CHAN_OPEN
RST 28H
DEFW CLS_LOWER

L2199:

LD (IY+$02),$01

$2530.
Jump forward if syntax is being checked.
Open channel 'K'.

$1601.
Clear the lower part of the display.
$0D6E. [BUG - This call will re-select channel 'S' and so should have been called
prior to opening channel 'K'. It is a direct copy of the code that appears in the
standard Spectrum ROM (and ROM 1). It is debatable whether it is better to
reproduce the bug so as to ensure that the INPUT routine operates the same in
128K mode as it does in 48K mode. Credit: Geoff Wearmouth]
TV_FLAG. Signal that the lower screen is being handled. [Not a bug as has been
reported elsewhere. The confusion seems to have arisen due to the incorrect system
variable being originally mentioned in the Spectrum ROM Disassembly by Logan
and O'Hara]

RST 28H
DEFW IN_ITEM_1
CALL L18A1
RST 28H
DEFW INPUT_1+$000A
RET

$20C1. Call the subroutine to deal with the INPUT items.
Move on to the next statement if checking syntax.

$20A0. Delegate handling to ROM 1.

COPY Routine

L21A7:

JP L08F0

Jump to new COPY routine.

125

SPECTRUM 128 ROM 0 DISASSEMBLY

NEW Routine

L21AA:

DI
JP L019D

Re-initialise the machine.

CIRCLE Routine
This routine draws an approximation to the circle with centre co-ordinates X and Y and radius Z. These numbers are rounded to the nearest integer
before use.
Thus Z must be less than 87.5, even when (X,Y) is in the centre of the screen.
The method used is to draw a series of arcs approximated by straight lines.

L21AE:

RST 18H
CP ','
JR NZ,L21EB
RST 20H
RST 28H
DEFW EXPT_1NUM
CALL L18A1
RST 28H
DEFW CIRCLE+$000D
RET

Get character from BASIC line.
$2C. Check for second parameter.
Jump ahead (for error C) if not.
Advance pointer into BASIC line.
Get parameter.
$1C82. Radius to calculator stack.
Move to consider next statement if checking syntax.

$232D. Delegate handling to ROM 1.

DRAW Routine
This routine is entered with the co-ordinates of a point X0, Y0, say, in COORDS. If only two parameters X, Y are given with the DRAW command, it draws
an approximation to a straight line from the point X0, Y0 to X0+X, Y0+Y.
If a third parameter G is given, it draws an approximation to a circular arc from X0, Y0 to X0+X, Y0+Y turning anti-clockwise through an angle G radians.

L21BE:

L21CA:

RST 18H
CP ','
JR Z,L21CA
CALL L18A1
RST 28H
DEFW LINE_DRAW
RET
RST 20H
RST 28H
DEFW EXPT_1NUM
CALL L18A1
RST 28H
DEFW DR_3_PRMS+$0007
RET

Get current character.
$2C.
Jump if there is a third parameter.
Error C during syntax checking if not at end of line/statement.

$2477. Delegate handling to ROM 1.

Get the next character.

$1C82. Angle to calculator stack.
Error C during syntax checking if not at end of line/statement.

$2394. Delegate handling to ROM 1.

DIM Routine
This routine establishes new arrays in the variables area. The routine starts by searching the existing variables area to determine whether there is an
existing array with the same name. If such an array is found then it is 'reclaimed' before the new array is established. A new array will have all its elements
set to zero if it is a numeric array, or to 'spaces' if it is an array of strings.

L21D5:

RST 28H
DEFW LOOK_VARS
JR NZ,L21EB
RST 28H
DEFW SYNTAX_Z
JR NZ,L21E7
RES 6,C
RST 28H
DEFW STK_VAR
CALL L18A1

Search to see if the array already exists.
$28B2.
Jump if array variable not found.

$2530.
Jump ahead during syntax checking.
Test the syntax for string arrays as if they were numeric.

$2996. Check the syntax of the parenthesised expression.
Error when checking syntax unless at end of line/statement.

126

SPECTRUM 128 ROM 0 DISASSEMBLY

An 'existing array' is reclaimed.

L21E7:

RST 28H
DEFW D_RUN
RET

$2C15. Delegate handling to ROM 1.

Error Report C — Nonsense in BASIC

L21EB:

CALL L05AC
DEFB $0B

Produce error report.
"C Nonsense in BASIC"

Clear Screen Routine
Clear screen if it is not already clear.

L21EF:

BIT 0,(IY+$30)
RET Z
RST 28H
DEFW CL_ALL
RET

FLAGS2. Is the screen clear?
Return if it is.

$0DAF. Otherwise clear the whole display.

Evaluate Numeric Expression
This routine is called when a numerical expression is typed directly into the editor or calculator.
A numeric expression is any that begins with '(', '-' or '+', or is one of the function keywords, e.g. ABS, SIN, etc, or is the name of a numeric variable.

L21F8:

LD HL,$FFFE
LD ($5C45),HL

A line in the editing area is considered as line '-2'.
PPC. Signal no current line number.

Check the syntax of the BASIC line

RES 7,(IY+$01)
CALL L228E
RST 28H
DEFW SCANNING
BIT 6,(IY+$01)
JR Z,L223A
RST 18H
CP $0D
JR NZ,L223A

Indicate 'syntax checking' mode.
Point to start of the BASIC command line.

$24FB. Evaluate the command line.
Is it a numeric value?
Jump to produce an error if a string result.
Get current character.
Is it the end of the line?
Jump if not to produce an error if not.

The BASIC line has passed syntax checking so now execute it

SET 7,(IY+$01)
CALL L228E
LD HL,L0321
LD (SYNRET),HL
RST 28H
DEFW SCANNING
BIT 6,(IY+$01)
JR Z,L223A
LD DE,LASTV
LD HL,($5C65)
LD BC,$0005
OR A
SBC HL,BC
LDIR
JP L223E
CALL L05AC
DEFB $19
LD A,$0D

L223A:

L223E:

If so, indicate 'execution' mode.
Point to start of the BASIC command line.
Set up the error handler routine address.
$5B8B.

$24FB. Evaluate the command line.
Is it a numeric value?
Jump to produce an error if a string result.
$5B8D. DE points to last calculator value.
STKEND.
The length of the floating point value.

HL points to value on top of calculator stack.
Copy the value in the workspace to the top of the calculator stack.
[Could have saved 1 byte by using a JR instruction]
Produce error report.
"Q Parameter error"
Make it appear that 'Enter' has been pressed.

127

CALL L226F
LD BC,$0001
RST 28H
DEFW BC_SPACES
LD ($5C5B),HL
PUSH HL
LD HL,($5C51)
PUSH HL
LD A,$FF
RST 28H
DEFW CHAN_OPEN
RST 28H
DEFW PRINT_FP
POP HL
RST 28H
DEFW CHAN_FLAG
POP DE
LD HL,($5C5B)
AND A
SBC HL,DE
LD A,(DE)
CALL L226F
INC DE
DEC HL
LD A,H
OR L
JR NZ,L2264
RET

L2264:

Process Key Press

L226F:

PUSH HL
PUSH DE
CALL L1F45
LD HL,$EC0D
RES 3,(HL)
PUSH AF
LD A,$02
RST 28H
DEFW CHAN_OPEN
POP AF
CALL L2669
LD HL,$EC0D
RES 3,(HL)
CALL L1F20
POP DE
POP HL
RET

Find Start of BASIC Command
Point to the start of a typed in BASIC command
and return first character in A.

L228E:

LD HL,($5C59)
DEC HL
LD ($5C5D),HL
RST 20H
RET

SPECTRUM 128 ROM 0 DISASSEMBLY

Process key press.

$0030. Create a byte in the workspace.
K_CUR. Address of the cursor.
Save it.
CURCHL. Current channel information.
Save it.
Channel 'R', the workspace.

$1601.

$2DE3. Print a floating point number to the workspace.
Get the current channel information address.

$1615. Set appropriate flags back for the old channel.
DE=Address of the old cursor position.
K_CUR. Address of the cursor.

HL=Length of floating point number.
Fetch the character and make it appear to have been typed.
Process the key press.

Decrement floating point number character count.

Repeat for all characters.

Save registers.

Use Workspace RAM configuration (physical RAM bank 7).
Editor flags.
Reset 'line altered' flag

Main screen

$1601.

Process key press.
Editor flags.
Reset 'line altered' flag
Use Normal RAM Configuration (physical RAM bank 0).
Restore registers.

E_LINE. Get the address of command being typed in.

CH_ADD. Store it as the address of next character to be interpreted.
Get the next character.

128

SPECTRUM 128 ROM 0 DISASSEMBLY

Is LET Command?
A typed in command resides in the editing workspace.
This function tests whether the text is a single LET command.
Exit: Zero flag set if a single LET command.

L2297:

L22A0:

CALL L228E
CP $F1
RET NZ
LD HL,($5C5D)
LD A,(HL)
INC HL
CP $0D
RET Z
CP ':'
JR NZ,L22A0
OR A
RET

Point to start of typed in command.
Is it 'LET'?
Return if not with zero flag reset.
CH_ADD. HL points to next character.
Fetch next character.

Has end of line been found?
Return if so with zero flag set.
$3A. Has start of new statement been found?
Loop back if not.
Return zero flag reset indicating a multi-statement
LET command.

Is Operator Character?
Exit: Zero flag set if character is an operator.

L22AB:

L22AF:

Found

Not found

L22B9:

LD B,A
LD HL,L22BD
LD A,(HL)
INC HL
OR A
JR Z,L22B9
CP B
JR NZ,L22AF

LD A,B
RET

OR $FF
LD A,B
RET

Save B.
Start of operator token table.
Fetch character from the table.
Advance to next entry.
End of table?
Jump if end of table reached.
Found required character?
Jump if not to try next character in table.

Restore character to A.
Return with zero flag set to indicate an operator.

Reset zero flag to indicate not an operator.
Restore character to A.

Operator Tokens Table

L22BD:

DEFB $2B, $2D, $2A
DEFB $2F, $5E, $3D
DEFB $3E, $3C, $C7
DEFB $C8, $C9, $C5
DEFB $C6
DEFB $00

'+', '-', '*'
'/', '^', '='
'>', '<', '<='
'>=', '<>', 'OR'
'AND'
End marker.

Is Function Character?
Exit: Zero set if a function token.

L22CB:

CP $A5
JR C,L22DD
CP $C4
JR NC,L22DD

'RND'. (first 48K token)
Jump ahead if not a token with zero flag reset.
'BIN'.
Jump ahead if not a function token.

129

CP $AC
JR Z,L22DD
CP $AD
JR Z,L22DD
CP A
RET
CP $A5
RET

L22DD:

SPECTRUM 128 ROM 0 DISASSEMBLY

'AT'.
Jump ahead if not a function token.
'TAB'.
Jump ahead if not a function token.
Return zero flag set if a function token.

Return zero flag set if a function token.

Is Numeric or Function Expression?
Exit: Zero flag set if a numeric or function expression.

L22E0:

L22E9:

L22ED:

L22F6:

L2307:

LD B,A
OR $20
CP 'a'
JR C,L22ED
CP '{'
JR NC,L22ED
CP A
RET
LD A,B
CP '.'
RET Z
CALL L230A
JR NZ,L2307
RST 20H
CALL L230A
JR Z,L22F6
CP '.'
RET Z
CP 'E'
RET Z
CP 'e'
RET Z
JR L22AB
OR $FF
RET

Is Numeric Character?
Exit: Zero flag set if numeric character.

L230A:

L2314:

CP '0'
JR C,L2314
CP ':'
JR NC,L2314
CP A
RET
CP '0'
RET

PLAY Routine

L2317:

L231A:

LD B,$00
RST 18H
PUSH BC
RST 28H
DEFW EXPT_EXP
POP BC
INC B
CP ','

Fetch character code.
Make lowercase.
$61. Is it 'a' or above?
Jump ahead if not a letter.
$7B. Is it below '{'?
Jump ahead if not.
Character is a letter so return
with zero flag set.
Fetch character code.
$2E. Is it '.'?
Return zero flag set indicating numeric.
Is character a number?
Jump ahead if not a number.
Get next character.
Is character a number?
Repeat for next character if numeric.
$2E. Is it '.'?
Return zero flag set indicating numeric.
$45. Is it 'E'?
Return zero flag set indicating numeric.
$65. Is it 'e'?
Return zero flag set indicating numeric.
Jump to test for operator tokens.
Reset the zero flag to indicate non-alphanumeric.

$30. Is it below '0'?
Jump below '0'.
$3A. Is it below ':'?
Jump above '9'

Set zero flag if numeric.
$30. This will cause zero flag to be reset.

String index.

Get string expression.

$2C. A ',' indicates another string.

130

L2327:

JR NZ,L2327
RST 20H
JR L231A
LD A,B
CP $09
JR C,L2330
CALL L05AC
DEFB $2B

L2330:

CALL L18A1
JP L0985

SPECTRUM 128 ROM 0 DISASSEMBLY

Jump ahead if no more.
Advance to the next character.
Loop back.
Check the index.
Maximum of 8 strings (to support synthesisers, drum machines or sequencers).

Produce error report.
"p (c) 1986 Sinclair Research Ltd" [BUG - This should be "Parameter error". The
Spanish 128 produces "p Bad parameter" but to save memory perhaps the UK 128
was intended to use the existing "Q Parameter error" and the change of the error
code byte here was overlooked. In that case it would have had a value of $19. Note
that generation of this error when using the main screen editor will result in a crash.
Credit: Andrew Owen]
Ensure end-of-statement or end-of-line.
Continue with PLAY code.

UNUSED ROUTINES — PART 1
There now follows 513 bytes of routines that are not used by the ROM, from $2336 (ROM 0) to $2536 (ROM 0).
They are remnants of the original Spanish 128's ROM code, although surprisingly they appear in a different order within that ROM.

Return to Editor
[Never called by this ROM]

L2336:

LD HL,TSTACK
LD (OLDSP),HL
CALL L1F45
JP L25CB

BC=HL-DE, Swap HL and DE
Exit: BC=HL-DE.
DE=HL, HL=DE.
[Never called by this ROM]

L2342:

AND A
SBC HL,DE
LD B,H
LD C,L
ADD HL,DE
EX DE,HL
RET

$5BFF.
$5B81.
Use Workspace RAM configuration (physical RAM bank 7).
Jump ahead to the Editor.

BC=HL-DE.

HL=DE, DE=HL.

Create Room for 1 Byte
Creates a single byte in the workspace, or automatically produces an error '4' if not.
[Never called by this ROM]

L234A:

LD BC,$0001
PUSH HL
PUSH DE
CALL L2358
POP DE
POP HL
RST 28H
DEFW MAKE_ROOM
RET

Request 1 byte.

Test whether there is space. If it fails this will cause the error
handler in ROM 0 to be called. If MAKE_ROOM were called directly and
and out of memory condition detected then the ROM 1 error handler would
be called instead.
$1655. The memory check passed so safely make the room.

131

SPECTRUM 128 ROM 0 DISASSEMBLY

Room for BC Bytes?
Test whether there is room for the specified number of bytes in the spare memory, producing error "4 Out of memory" if not. This routine is very similar
to that at $3F66 with the exception that this routine assumes IY points at the system variables.
Entry:
Exit :

BC=Number of bytes required.
Returns if the room requested is available else an error '4' is produced.

[Called by the routine at $234A (ROM 0), which is itself never called by this ROM]

L2358:

L2368:

LD HL,($5C65)
ADD HL,BC
JR C,L2368
EX DE,HL
LD HL,$0082
ADD HL,DE
JR C,L2368
SBC HL,SP
RET C
LD (IY+$00),$03
JP L0321

STKEND.
Would adding the specified number of bytes overflow the RAM area?
Jump to produce an error if so.
DE=New end address.
Would there be at least 130 bytes at the top of RAM?

Jump to produce an error if not.
If the stack is lower in memory, would there still be enough room?
Return if there would.
Signal error "4 Out of Memory".
Jump to error handler routine.

HL = A*32
[Called by routines at $2383 (ROM 0) and $23B8 (ROM 0), which are themselves never called by this ROM]

L236F:

ADD A,A
ADD A,A

A*2.
A*4. Then multiply by 8 in following routine.

HL = A*8
[Called by the routine at $23E1 (ROM 0), which ultimately is itself never called by this ROM]

L2371:

LD L,A
LD H,$00
ADD HL,HL
ADD HL,HL
ADD HL,HL
RET

A*2.
A*4.
A*8.
Return HL=A*8.

Find Amount of Free Space
Exit: Carry flag set if no more space, else HL holds the amount of free space.
[Never called by this ROM]

HL=SP.
STKEND.

Effectively SP-STKEND, i.e. the amount of available space.

L2378:

LD HL,$0000
ADD HL,SP
LD DE,($5C65)
OR A
SBC HL,DE
RET

Print Screen Buffer Row
Prints row from the screen buffer to the screen.
Entry:

A=Row number.

[Never called by this ROM]

L2384:

RES 0,(IY-$39)
CALL L236F
PUSH HL
LD DE,($FF24)

KSTATE+1. Signal do not invert attribute value. [IY+$3B on the Spanish 128]
HL=A*32. Number of bytes prior to the requested row.
Save offset to requested row to print.
Fetch address of screen buffer.

132

ADD HL,DE
LD D,H
LD E,L
EX (SP),HL
PUSH HL
PUSH DE
LD DE,$5800
ADD HL,DE
EX DE,HL
POP HL
LD BC,$0020
LD A,($5C8F)
CALL L249B

POP HL
LD A,H
LD H,$00
ADD A,A
ADD A,A
ADD A,A
ADD A,$40
LD D,A
LD E,H
ADD HL,DE
EX DE,HL
POP HL
LD B,$20
JP L23E1

SPECTRUM 128 ROM 0 DISASSEMBLY

Point to row entry.

DE=Address of row entry.
Stack address of row entry. HL=Offset to requested row to print.
Save offset to requested row to print.
Save address of row entry.
Attributes file.
Point to start of corresponding row in attributes file.
DE=Start address of corresponding row in attributes file.
HL=Address of row entry.
32 columns.
ATTR_T. Fetch the temporary colours.
Set the colours for the 32 columns in this row, processing any colour control codes
from the print string.
HL=Offset to requested row to print.

Calculate corresponding display file address.

DE=Display file address.
HL=Offset to requested row to print.
32 columns.
Print one row to the display file.

Blank Screen Buffer Content
Sets the specified number of screen buffer positions from the specified row to $FF.
Entry:

A=Row number.
BC=Number of bytes to set.

[Never called by this ROM]

L23B8:

LD D,$FF
CALL L236F
LD A,D
LD DE,($FF24)
ADD HL,DE
LD E,L
LD D,H
INC DE
LD (HL),A
DEC BC
LDIR
RET

The character to set the screen buffer contents to.
HL=A*32. Offset to the specified row.

Fetch the address of the screen buffer.
HL=Address of first column in the requested row.

DE=Address of second column in the requested row.
Store the character.

Repeat for all remaining bytes required.

Print Screen Buffer to Display File
[Never called by this ROM]

L23CB:

CALL L2488
LD DE,$4000
LD HL,($FF24)
LD B,E
CALL L23E1
LD D,$48
CALL L23E1
LD D,$50
LD B,$C0

Set attributes file from screen buffer.
DE=First third of display file.
Fetch address of screen buffer.
Display 256 characters.
Display string.
Middle third of display file.
Display string.
Last third of display file.
Display 192 characters.

133

SPECTRUM 128 ROM 0 DISASSEMBLY

Print Screen Buffer Characters to Display File
Displays ASCII characters, UDGs, graphic characters or two special symbols in the display file, but does not alter the attributes file. Character code $FE
is used to represent the error marker bug symbol and the character code $FF is used to represent a null, which is displayed as a space.
Entry:

DE=Display file address.
HL=Points to string to print.
B=Number of characters to print.

[Used by routine at $23CB (ROM 0) and called by the routine at $2383 (ROM 0), both of which are themselves never called by this ROM]

L23E1:

LD A,(HL)
PUSH HL
PUSH DE
CP $FE
JR C,L23EC
SUB $FE
JR L2422

Fetch the character.
Save string pointer.
Save display file address.
Was if $FE (bug) or $FF (null)?
Jump ahead if not.
Reduce range to $00-$01.
Jump ahead to show symbol.

Comes here if character code if below $FE

L23EC:

CP $20
JR NC,L23F7

Is it a control character?
Jump ahead if not.

Comes here if a control character

LD HL,L2527

AND A
EX AF,AF'
JR L242B
CP $80
JR NC,L2409

L23F7:

Comes here if an ASCII character

Graphic for a 'G' (not a normal G though). Used to indicate embedded colour control
codes.
Clear the carry flag to indicate no need to switch back to RAM bank 7.
Save the flag.
Jump ahead to display the symbol.
Is it a graphic character or UDG?
Jump ahead if so.

CALL L2371
LD DE,($5C36)
ADD HL,DE
POP DE
CALL $FF28

JR L2450

HL=A*8.
CHARS.
Point to the character bit pattern.
Fetch the display file address.
Copy character into display file (via RAM Routine). Can't use routine at $242C (ROM
0) since it does not perform a simple return.
Continue with next character.

Comes here if a graphic character or UDG

L2409:

CP $90
JR NC,L2411

Is it a graphic character?
Jump ahead if not.

Comes here if a graphic character

SUB $7F
JR L2422

Reduce range to $01-$10.
Jump ahead to display the symbol.

Comes here if a UDG

L2411:

SUB $90
CALL L2371
POP DE
CALL L1F20

PUSH DE
LD DE,($5C7B)
SCF
JR L2429

Reduce range to $00-$6D.
HL=A*8.
Fetch display file address.
Use Normal RAM Configuration (RAM bank 0) to allow access to character bit
patterns.
Save display file address.
UDG. Fetch address of UDGs.
Set carry flag to indicate need to switch back to RAM bank 7.
Jump ahead to locate character bit pattern and display the symbol.

134

SPECTRUM 128 ROM 0 DISASSEMBLY

Come here if (HL) was $FE or $FF, or with a graphic character.
At this point A=$00 if (HL) was $FE indicating a bug symbol, or $01 if (HL) was $FF indicating a null, or A=$01-$10 if a graphic character.

L2422:

L2429:

L242B:

LD DE,L252F
CALL L2371
AND A
EX AF,AF'
ADD HL,DE
POP DE

Start address of the graphic character bitmap table.
HL=A*8 -> $0000 or $0008.
Clear carry flag to indicate no need to switch back to RAM bank 7.
Save switch bank indication flag.
Point to the symbol bit pattern data.
Fetch display file address. Drop through into routine below.

Copy A Character « RAM Routine »
Routine copied to RAM at $FF36-$FF55 by subroutine at $246F (ROM 0).
Also used in ROM from above routine.
This routine copies 8 bytes from HL to DE. It increments HL and D after each byte, restoring D afterwards.
It is used to copy a character into the display file.
Entry:

HL=Character data.
DE=Display file address.

[Called by a routine that is itself never called by this ROM]

L242C:

LD C,D
LD A,(HL)
LD (DE),A
INC HL
INC D
LD A,(HL)
LD (DE),A
INC HL
INC D
LD A,(HL)
LD (DE),A
INC HL
INC D
LD A,(HL)
LD (DE),A
INC HL
INC D
LD A,(HL)
LD (DE),A
INC HL
INC D
LD A,(HL)
LD (DE),A
INC HL
INC D
LD A,(HL)
LD (DE),A
INC HL
INC D
LD A,(HL)
LD (DE),A
LD D,C

Save D.

Copy byte 1.

Copy byte 2.

Copy byte 3.

Copy byte 4.

Copy byte 5.

Copy byte 6.

Copy byte 7.

Copy byte 8.
Restore D. « Last byte copied to RAM »

When the above routine is used in ROM, it drops through to here.

L244C:

L2450:

EX AF,AF'
CALL C,L1F45
POP HL
INC HL
INC DE
DJNZ L23E1
RET

Need to switch back to RAM bank 7?
If so then switch to use Workspace RAM configuration (physical RAM bank 7).
Fetch address of string data.
Move to next character.
Advance to next display file column.
Repeat for all requested characters.

135

SPECTRUM 128 ROM 0 DISASSEMBLY

Toggle ROMs 1 « RAM Routine »
Routine copied to RAM at $FF28-$FF35 by subroutine at $246F (ROM 0).
This routine toggles to the other ROM than the one held in BANK_M.
Entry:

A'= Current paging configuration.

[Called by a routine that is itself never called by this ROM]

L2456:

PUSH BC
DI
LD BC,$7FFD
LD A,(BANK_M)
XOR $10
OUT (C),A
EI
EX AF,AF'

Save BC
Disable interrupts whilst paging.

$5B5C. Fetch current paging configuration.
Toggle ROMs.
Perform paging.
Re-enable interrupts.
Save the new configuration in A'. « Last byte copied to RAM »

Toggle ROMs 2 « RAM Routine »
Routine copied to RAM at $FF56-$FF60 by subroutine at $246F (ROM 0).
This routine toggles to the other ROM than the one specified.
It is used to page back to the original configuration.
Entry:

A'= Current paging configuration.

[Called by a routine that is itself never called by this ROM]

L2464:

EX AF,AF'
DI
LD C,$FD
XOR $10
OUT (C),A
EI
POP BC
RET

Retrieve current paging configuration.
Disable interrupts whilst paging.
Restore Paging I/O port number.
Toggle ROMs.
Perform paging.
Re-enable interrupts.
Restore BC.
« Last byte copied to RAM »

Construct 'Copy Character' Routine in RAM
This routine copies 3 sections of code into RAM to construct a single routine that can be used to copy the bit pattern for a character into the display file.
Copy $2456-$2463 (ROM 0) to $FF28-$FF35 (14 bytes).
Copy $242C-$244B (ROM 0) to $FF36-$FF55 (32 bytes).
Copy $2464-$246E (ROM 0) to $FF56-$FF60 (11 bytes).
[Never called by this ROM]

L246F:

LD HL,L2456
LD DE,$FF28
LD BC,$000E
LDIR
PUSH HL
LD HL,L242C
LD C,$20
LDIR
POP HL
LD C,$0B
LDIR
RET

Point to the 'page in other ROM' routine.
Destination RAM address.

Copy the routine.

Copy a character routine.

Copy the routine.
HL=$2464 (ROM 0), which is the address of the 'page back to original ROM' routine.

Copy the routine.

Set Attributes File from Screen Buffer
This routine parses the screen buffer string contents looking for colour control codes and changing the attributes file contents correspondingly.
[Called by the routine at $23CB (ROM 0), which is itself never called by this ROM]

L2488:

RES 0,(IY-$39)
LD DE,$5800

KSTATE+1. Signal do not invert attribute value. [Spanish 128 uses IY-$3B]
The start of the attributes file.

136

SPECTRUM 128 ROM 0 DISASSEMBLY

LD BC,$02C0
LD HL,($FF24)
LD A,($5C8D)
LD ($5C8F),A

22 rows of 32 columns.
The address of the string to print.
ATTR_P.
ATTR_T. Use the permanent colours.

Set Attributes for a Screen Buffer Row

L249B:

EX AF,AF'

Save the colour byte.

The main loop returns here on each iteration

L249C:

PUSH BC
LD A,(HL)
CP $FF
JR NZ,L24AA
LD A,($5C8D)
LD (DE),A
INC HL
INC DE
JR L2507

Not a blank character

L24AA:

EX AF,AF'
LD (DE),A
INC DE
EX AF,AF'
INC HL
CP $15
JR NC,L2507
CP $10
JR C,L2507

Save the number of characters.
Fetch a character from the buffer.
Is it blank?
Jump ahead if not.
ATTR_P. Get the default colour byte.
Store it in the attributes file.
Point to next screen buffer position.
Point to next attributes file position.
Jump ahead to handle the next character.

Get the colour byte.
Store it in the attributes file.
Point to the next attributes file position.
Save the colour byte.
Point to the next screen buffer position.
Is the string character OVER or above?
Jump if it is to handle the next character.
Is the string character below INK?
Jump if it is to handle the next character.

Screen buffer character is INK, PAPER, FLASH, BRIGHT or INVERSE.

DEC HL
JR NZ,L24C2

Point back to the previous screen buffer position.
Jump if not INK.

Screen character was INK so insert the new ink into the attribute byte.

INC HL
LD A,(HL)
LD C,A
EX AF,AF'
AND $F8
JR L2505
CP $11
JR NZ,L24D1

L24C2:

Point to the next screen buffer position.
Fetch the ink colour from the next screen buffer position.
and store it in C.
Get the colour byte.
Mask off the ink bits.
Jump ahead to store the new attribute value and then to handle the next character.
Is the string character PAPER?
Jump ahead if not.

Screen character was PAPER so insert the new paper into the attribute byte.

INC HL
LD A,(HL)
ADD A,A
ADD A,A
ADD A,A
LD C,A
EX AF,AF'
AND $C7
JR L2505
CP $12
JR NZ,L24DE

L24D1:

Point to the next screen buffer position.
Fetch the paper colour from the next screen buffer position.

Multiple by 8 so that ink colour become paper colour.

Get the colour byte.
Mask off the paper bits.
Jump ahead to store the new attribute value and then to handle the next character.
Is the string character FLASH?
Jump ahead if not.

137

Screen character was FLASH

INC HL
LD A,(HL)
RRCA
LD C,A
EX AF,AF'
AND $7F
JR L2505
CP $13
JR NZ,L24EC

L24DE:

Screen character was BRIGHT

INC HL
LD A,(HL)
RRCA
RRCA
LD C,A
EX AF,AF'
AND $BF
JR L2505
CP $14
INC HL
JR NZ,L2507

L24EC:

Screen character was INVERSE

LD C,(HL)
LD A,($5C01)
XOR C
RRA
JR NC,L2507
LD A,$01
XOR (IY-$39)
LD ($5C01),A
EX AF,AF'
CALL L2513
OR C
EX AF,AF'
POP BC
DEC BC
LD A,B
OR C
JP NZ,L249C
EX AF,AF'
LD ($5C8F),A
RET

L2505:

L2507:

SPECTRUM 128 ROM 0 DISASSEMBLY

Point to the next screen buffer position.
Fetch the flash status from the next screen buffer position.
Shift the flash bit into bit 0.

Get the colour byte.
Mask off the flash bit.
Jump ahead to store the new attribute value and then to handle the next character.
Is the string character BRIGHT?
Jump ahead if not.

Point to the next screen buffer position.
Fetch the bright status from the next screen buffer position.

Shift the bright bit into bit 0.

Get the colour byte.
Mask off the bright bit.
Jump ahead to store the new attribute value and then to handle the next character.
Is the string character INVERSE?
Point to the next screen buffer position.
Jump ahead if not to handle the next character.

Fetch the inverse status from the next screen buffer position.
KSTATE+1. Fetch inverting status (Bit 0 is 0 for non-inverting, 1 for inverting).
Invert status.
Shift status into the carry flag.
Jump if not inverting to handle the next character.
Signal inverting is active.
KSTATE+1. Toggle the status.
KSTATE+1. Store the new status.
Get the colour byte.
Swap ink and paper in the colour byte.
Combine the old and new colour values.
Save the new colour byte.
Fetch the number of characters.

Repeat for all characters.
Get colour byte.
ATTR_T. Make it the new temporary colour.

Swap Ink and Paper Attribute Bits
Entry:
Exit :

A=Attribute byte value.
A=Attribute byte value with paper and ink bits swapped.

[Called by the routine at $2488 (ROM 0), which is itself never called by this ROM]

L2513:

LD B,A
AND $C0
LD C,A
LD A,B
ADD A,A
ADD A,A
ADD A,A
AND $38
OR C

Save the original colour byte.
Keep only the flash and bright bits.

Shift ink bits into paper bits.

Keep only the paper bits.
Combine with the flash and bright bits.

138

SPECTRUM 128 ROM 0 DISASSEMBLY

Get the original colour byte.

Shift the paper bits into the ink bits.
Keep only the ink bits.
Add with the paper, flash and bright bits.

0 0 0 0 0 0 0 0
0 0 1 1 1 1 0 0      XXXX
0 1 1 0 0 0 1 0     XX   X
0 1 1 0 0 0 0 0     XX
0 1 1 0 1 1 1 0     XX XXX
0 1 1 0 0 0 1 0     XX   X
0 0 1 1 1 1 1 0      XXXX
0 0 0 0 0 0 0 0

0 0 0 0 0 0 0 0
0 1 1 0 1 1 0 0     XX XX
0 0 0 1 0 0 0 0       X
0 1 0 1 0 1 0 0     X X X
1 0 1 1 1 0 1 0    X XXX X
0 0 1 1 1 0 0 0      XXX
0 1 0 1 0 1 0 0     X X X
1 0 0 0 0 0 1 0    X     X

LD C,A
LD A,B
RRA
RRA
RRA
AND $07
OR C
RET

Character Data
Graphic control code indicator

L2527:

Error marker

L252F:

DEFB $00
DEFB $3C
DEFB $62
DEFB $60
DEFB $6E
DEFB $62
DEFB $3E
DEFB $00

DEFB $00
DEFB $6C
DEFB $10
DEFB $54
DEFB $BA
DEFB $38
DEFB $54
DEFB $82

« End of Unused ROM Routines »

KEY ACTION TABLES

Editing Keys Action Table
Each editing key code maps to the appropriate handling routine.
This includes those keys which mirror the functionality of the add-on keypad; these are found by trapping the keyword produced by the keystrokes in
48K mode.
[Surprisingly there is no attempt to produce an intelligible layout instead the first 16 keywords have been used. Additionally the entries for DELETE and
ENTER should probably come in the first six entries for efficiency reasons.]

L2537:

DEFB $15
DEFB $0B
DEFW L2A94
DEFB $0A
DEFW L2AB5
DEFB $08
DEFW L2AD7
DEFB $09
DEFW L2AE3
DEFB $AD
DEFW L2A4F
DEFB $AC
DEFW L2A25
DEFB $AF
DEFW L29D4
DEFB $AE
DEFW L29E1
DEFB $A6

Number of table entries.
Key code: Cursor up.
CURSOR-UP handler routine.
Key code: Cursor Down.
CURSOR-DOWN handler routine.
Key code: Cursor Left.
CURSOR-LEFT handler routine.
Key code: Cursor Right.
CURSOR-RIGHT handler routine.
Key code: Extend Mode + P.
TEN-ROWS-UP handler routine.
Key code: Symbol Shift + I.
TEN-ROWS-DOWN handler routine.
Key code: Extend Mode + I.
WORD-LEFT handler routine.
Key code: Extend Mode + Shift + J.
WORD-RIGHT handler routine.
Key code: Extend Mode + N, or Graph + W.

139

DEFW L2983
DEFB $A5
DEFW L29AB
DEFB $A8
DEFW L2A87
DEFB $A7
DEFW L2A7A
DEFB $AA
DEFW L291B
DEFB $0C
DEFW L292B
DEFB $B3
DEFW L3017
DEFB $B4
DEFW L2FBC
DEFB $B0
DEFW L3072
DEFB $B1
DEFW L303E
DEFB $0D
DEFW L2944
DEFB $A9
DEFW L269B
DEFB $07
DEFW L2704

SPECTRUM 128 ROM 0 DISASSEMBLY

TOP-OF-PROGRAM handler routine.
Key code: Extend Mode + T, or Graph + V.
END-OF-PROGRAM handler routine.
Key code: Extend Mode Symbol Shift + 2, or Graph Y.
START-OF-LINE handler routine.
Key code: Extend Mode + M, or Graph + X.
END-OF-LINE handler routine.
Key code: Extend Mode + Shift + K.
DELETE-RIGHT handler routine.
Key code: Delete.
DELETE handler routine.
Key code: Extend Mode + W.
DELETE-WORD-RIGHT handler routine.
Key code: Extend Mode + E.
DELETE-WORD-LEFT handler routine.
Key code: Extend Mode + J.
DELETE-TO-END-OF-LINE handler routine.
Key code: Extend Mode + K.
DELETE-TO-START-OF-LINE handler routine.
Key code: Enter.
ENTER handler routine.
Key code: Extend Mode + Symbol Shift + 8, or Graph + Z.
TOGGLE handler routine.
Key code: Edit.
MENU handler routine.

Menu Keys Action Table
Each menu key code maps to the appropriate handling routine.

L2577:

DEFB $04
DEFB $0B
DEFW L272E
DEFB $0A
DEFW L2731
DEFB $07
DEFW L2717
DEFB $0D
DEFW L2717

Number of entries.
Key code: Cursor up.
MENU-UP handler routine.
Key code: Cursor down.
MENU-DOWN handler routine.
Key code: Edit.
MENU-SELECT handler routine.
Key code: Enter.
MENU-SELECT handler routine.

MENU ROUTINES — PART 3

Initialise Mode Settings
Called before Main menu displayed.

L2584:

CALL L28BE
LD HL,$0000
LD ($FC9A),HL
LD A,$82
LD ($EC0D),A
LD HL,$0000
LD ($5C49),HL
CALL L35BC
CALL L365E
RET

Reset Cursor Position.
No top line.
Line number at top of screen.
Signal waiting for key press, and menu is displayed.
Store the Editor flags.
No current line number.
E_PPC. Current line number.
Reset indentation settings.
Reset to 'L' Mode
[Could have saved one byte by using JP $365E (ROM 0)]

Show Main Menu

L259F:

LD HL,TSTACK
LD (OLDSP),HL

$5BFF.
$5B81.

140

L25AD:

CALL L1F45
LD A,$02
RST 28H
DEFW CHAN_OPEN
LD HL,L2744
LD ($F6EA),HL
LD HL,L2754
LD ($F6EC),HL
PUSH HL
LD HL,$EC0D
SET 1,(HL)
RES 4,(HL)
DEC HL
LD (HL),$00
POP HL
CALL L36A8
JP L2653

SPECTRUM 128 ROM 0 DISASSEMBLY

Use Workspace RAM configuration (physical RAM bank 7).
Select main screen.

$1601.
Jump table for Main Menu.
Store current menu jump table address.
The Main Menu text.
Store current menu text table address.
Store address of menu on stack.
Editor flags.
Indicate 'menu displayed'.
Signal return to main menu.
Current menu index.
Select top entry.
Retrieve address of menu.
Display menu and highlight first item.
Jump ahead to enter the main key waiting and processing loop.

EDITOR ROUTINES — PART 2

Return to Editor / Calculator / Menu from Error

L25CB:

L25E3:

LD IX,$FD6C
LD HL,TSTACK
LD (OLDSP),HL
CALL L1F45
LD A,$02
RST 28H
DEFW CHAN_OPEN
CALL L3668
LD HL,$5C3B
BIT 5,(HL)
JR Z,L25E3
LD HL,$EC0D
RES 3,(HL)
BIT 6,(HL)
JR NZ,L2604
LD A,($EC0E)
CP $04
JR Z,L2601
CP $00
JP NZ,L28C7

Point IX at editing settings information.
$5BFF.
$5B81.
Use Workspace RAM configuration (physical RAM bank 7).

$1601. Select main screen.
Reset 'L' mode.
FLAGS.
Has a key been pressed?
Wait for a key press.
Editor flags.
Signal line has not been altered.
Is editing area the lower screen?
If so then skip printing a banner and jump ahead to return to the Editor.
Fetch mode.
Calculator mode?
Jump ahead if so.
Edit Menu mode?
Jump if not to re-display Main menu.

Edit menu Print mode

CALL L3848
JR L2604

Clear screen and print "128 BASIC" in the banner line.
Jump ahead to return to the Editor.

Calculator mode

L2601:

CALL L384D

Clear screen and print "Calculator" in the banner line.

Return to the Editor
Either as the result of a re-listing, an error or from completing the Edit Menu Print option.
[BUG - Occurs only with ZX Interface 1 attached and a BASIC line such as 1000 OPEN #4, "X" (the line number must be greater than 999). This produces
the error message "Invalid device expression, 1000:1" but the message is too long to fit on a single line. When using the lower screen for editing, spurious
effects happen to the bottom lines. When using the full screen editor, a crash occurs. Credit: Toni Baker, ZX Computing Monthly] [The bug is caused
by system variable DF_SZ being increased to 3 as a result of the error message spilling onto an extra line. The error can be resolved by inserting a LD
(IY+$31),$02 instruction at $2604 (ROM 0). Credit: Paul Farrow]

141

L2604:

Calculator mode

CALL L30D6
CALL L3222
LD A,($EC0E)
CP $04
JR Z,L2653

LD HL,($5C49)
LD A,H
OR L
JR NZ,L262D
LD HL,($5C53)
LD BC,($5C4B)
AND A
SBC HL,BC
JR NZ,L262A

No program exists

L262A:
L262D:

LD HL,$0000
LD ($EC08),HL
LD HL,($EC08)
CALL L1F20
RST 28H
DEFW LINE_ADDR
RST 28H
DEFW LINE_NO
CALL L1F45
LD ($5C49),DE
LD HL,$EC0D
BIT 5,(HL)
JR NZ,L2653
LD HL,$0000
LD ($EC06),HL
CALL L152F
CALL L29F2
CALL L2944

SPECTRUM 128 ROM 0 DISASSEMBLY

Reset Below-Screen Line Edit Buffer settings to their default values.
Reset Above-Screen Line Edit Buffer settings to their default values.
Fetch the mode.
Calculator mode?
Jump ahead if not to wait for a key press.

E_PPC. Fetch current line number.

Is there a current line number?
Jump ahead if so.
PROG. Address of start of BASIC program.
VARS. Address of start of variables area.

HL=Length of program.
Jump if a program exists.

Set no line number last edited.
Fetch line number of last edited line.
Use Normal RAM Configuration (physical RAM bank 0).
Find address of line number held in HL, or the next line if it does not exist.
$196E. Return address in HL.
Find line number for specified address, and return in DE.
$1695. Fetch the line number for the line found.
Use Workspace RAM configuration (physical RAM bank 7).
E_PPC. Save the current line number.
Editor flags.
Process the BASIC line?
Jump ahead if calculator mode.

Signal no editable characters in the line prior to the cursor.
Relist the BASIC program.
Set attribute at editing position so as to show the cursor.
Call the ENTER handler routine.

Main Waiting Loop
Enter a loop to wait for a key press. Handles key presses for menus, the Calculator and the Editor.

L2653:

LD SP,TSTACK
CALL L3668
CALL L367F

PUSH AF
LD A,($5C39)
CALL L26EC
POP AF
CALL L2669
JR L2653

$5BFF. Use temporary stack.
Reset 'L' mode.
Wait for a key. [Note that it is possible to change CAPS LOCK mode whilst on a
menu]
Save key code.
PIP. Tone of keyboard click.
Produce a key click noise.
Retrieve key code.
Process the key press.
Wait for another key.

Process Key Press
Handle key presses for the menus and the Editor.
Entry:

A=Key code.
Zero flag set if a menu is being displayed.

L2669:

LD HL,$EC0D
BIT 1,(HL)
PUSH AF

Editor flags.
Is a menu is displayed?
Save key code and flags.

142

SPECTRUM 128 ROM 0 DISASSEMBLY

Use menu keys lookup table.
Jump if menu is being displayed.
Use editing keys lookup table.
Find and call the action handler for this key press.
Jump ahead if no match found.
If required then produce error beep.
Restore key code.

L2677:

LD HL,L2577
JR NZ,L2677
LD HL,L2537
CALL L3FCE
JR NZ,L2681
CALL NC,L26E7
POP AF
RET

No action defined for key code

L2681:

POP AF
JR Z,L2689

Restore key code and flags.
Jump if menu is not being displayed.

A menu is being displayed, so just ignore key press

XOR A
LD ($5C41),A
RET

Select 'L' mode.
MODE.

A menu is not being displayed

L2689:

LD HL,$EC0D
BIT 0,(HL)
JR Z,L2694

The buffer is full so ignore the key press

L2694:

CALL L26E7
RET
CP $A3
JR NC,L2653

JP L28F1

Editor flags.
Is the Screen Line Edit Buffer is full?
Jump if not to process the key code.

Produce error beep.
[Could have save a byte by using JP $26E7 (ROM 0)]
Was it a supported function key code?
Ignore by jumping back to wait for another key. [BUG - This should be RET NC
since it was called from the loop at $2653 (ROM 0). Repeatedly pressing an
unsupported key will result in a stack memory leak and eventual overflow. Credit:
John Steven (+3), Paul Farrow (128)]
Jump forward to handle the character key press.

TOGGLE Key Handler Routine
Toggle between editing in the lower and upper screen areas.
Also used by the editing menu SCREEN option.

L269B:

L26B6:
L26B9:

LD A,($EC0E)
CP $04
RET Z
CALL L1630
LD HL,$EC0D
RES 3,(HL)
LD A,(HL)
XOR $40
LD (HL),A
AND $40
JR Z,L26B6
CALL L26BB
JR L26B9
CALL L26CE
SCF
RET

Select Lower Screen
Set the lower screen as the editing area.

Fetch mode.
Calculator mode?
Return if so (TOGGLE has no effect in Calculator mode).
Clear Editing Display.
Editor flags.
Reset 'line altered' flag.

Toggle screen editing area flag.

Jump forward if the editing area is now the upper area.
Set the lower area as the current editing area.
Jump forward.
Set the upper area as the current editing area.
Signal do not produce an error beep.

143

L26BB:

CALL L3881
LD HL,$EC0D
SET 6,(HL)
CALL L2E2D
CALL L3A88
CALL L28DF
JR L26D9

Select Upper Screen
Set the upper screen as the editing area.

L26CE:

L26D9:

LD HL,$EC0D
RES 6,(HL)
CALL L28BE
CALL L3848
LD HL,($FC9A)
LD A,H
OR L
CALL NZ,L334A
CALL L152F
JP L29F2

SPECTRUM 128 ROM 0 DISASSEMBLY

Clear lower editing area display.
Editor flags.
Signal using lower screen.
Reset to lower screen.
Set default lower screen editing cursor settings.
Set default lower screen editing settings.
Jump ahead to continue.

Editor flags.
Signal using main screen.
Reset Cursor Position.
Clear screen and print the "128 BASIC" banner line.
Line number at top of screen.

Is there a line?
If there is then get the address of BASIC line for this line number.
Relist the BASIC program.
Set attribute at editing position so as to show the cursor, and return.

Produce Error Beep
This is the entry point to produce the error beep, e.g. when trying to cursor up or down past the BASIC program.
It produces a different tone and duration from the error beep of 48K mode. The change is pitch is due to the SRL A instruction at $26EA (ROM 0), and the
change in duration is due to the instruction at $26F1 (ROM 0) which loads HL with $0C80 as opposed to $1A90 which is used when in 48K mode. The key
click and key repeat sounds are produced by entering at $26EC (ROM 0) but with A holding the value of system variable PIP. This produces the same tone
as 48K mode but is of a much longer duration due to HL being loaded with $0C80 as opposed to the value of $00C8 used in 48K mode. The Spanish 128
uses the same key click tone and duration in 128K mode as it does in 48K mode, leading to speculation that the Spectrum 128 (and subsequent models)
should have done the same and hence suffer from a bug. However, there is no reason why this should be the case, and it can easily be imagined that the
error beep note duration of 48K mode would quickly become very irritating when in 128K mode where it is likely to occur far more often. Hence the reason
for its shorter duration. The reason for the longer key click is less clear, unless it was to save memory by using a single routine. However, it would only
have required an additional 3 bytes to set HL independently for key clicks, which is not a great deal considering there is 1/2K of unused routines at $2336
(ROM 0). Since the INPUT command is handled by ROM 1, it produces key clicks at the 48K mode duration even when executed from 128 BASIC mode.

L26E7:

LD A,($5C38)
SRL A

RASP.
Divide by 2.

This entry point is called to produce the key click tone. In 48K mode, the key click sound uses an HL value of $00C8 and so is 16 times shorter than
in 128K mode.

L26EC:

L26F4:

PUSH IX
LD D,$00
LD E,A
LD HL,$0C80
RST 28H
DEFW BEEPER
POP IX
RET

Produce Success Beep

L26FA:

PUSH IX
LD DE,$0030
LD HL,$0300
JR L26F4

Pitch.

Duration.

$03B5. Produce a tone.

Frequency*Time.
Duration.
Jump to produce the tone.

144

SPECTRUM 128 ROM 0 DISASSEMBLY

MENU ROUTINES — PART 4

Menu Key Press Handler Routines

Menu Key Press Handler — MENU
This is executed when the EDIT key is pressed, either from within a menu or from the BASIC editor.

L2704:

L270F:

CALL L29EC
LD HL,$EC0D
SET 1,(HL)
DEC HL
LD (HL),$00
LD HL,($F6EC)
CALL L36A8
SCF
RET

Remove cursor, restoring old attribute.
HL points to Editor flags.
Signal 'menu is being displayed'.
HL=$EC0C.
Set 'current menu item' as the top item.
Address of text for current menu.
Display menu and highlight first item.
Signal do not produce an error beep.

Menu Key Press Handler — SELECT

L2717:

LD HL,$EC0D
RES 1,(HL)
DEC HL
LD A,(HL)
LD HL,($F6EA)
PUSH HL
PUSH AF
CALL L373E
POP AF
POP HL
CALL L3FCE
JP L29F2

HL points to Editor flags.
Clear 'displaying menu' flag.
HL=$EC0C.
A=Current menu option index.
HL points to jump table for current menu.

Restore menu screen area.

Call the item in the jump table corresponding to the currently selected menu item.
Set attribute at editing position so as to show the cursor, and return.

Menu Key Press Handler — CURSOR UP

L272E:

SCF
JR L2732

Signal move up.
Jump ahead to continue.

Menu Key Press Handler — CURSOR DOWN

L2731:
L2732:

AND A
LD HL,$EC0C
LD A,(HL)
PUSH HL
LD HL,($F6EC)
CALL C,L37A7
CALL NC,L37B6
POP HL
LD (HL),A

Signal moving down.

Fetch current menu index.
Save it.
Address of text for current menu.
Call if moving up.
Call if moving down.
HL=Address of current menu index store.
Store the new menu index.

Comes here to complete handling of Menu cursor up and down. Also as the handler routines for Edit Menu return to 128 BASIC option and Calculator
menu return to Calculator option, which simply make a return.

L2742:

SCF
RET

145

SPECTRUM 128 ROM 0 DISASSEMBLY

Menu Tables

Main Menu
Jump table for the main 128K menu, referenced at $25AD (ROM 0).

L2744:

DEFB $05
DEFB $00
DEFW L2831
DEFB $01
DEFW L286C
DEFB $02
DEFW L2885
DEFB $03
DEFW L1B47
DEFB $04
DEFW L2816

Text for the main 128K menu

L2754:

L275E:

L2769:

L2772:

L2784:

DEFB $06
DEFM "128 "
DEFB $FF
DEFM "Tape Loade"
DEFB 'r'+$80
DEFM "128 BASI"
DEFB 'C'+$80
DEFM "Calculato"
DEFB 'r'+$80
DEFM "48 BASI"
DEFB 'C'+$80
DEFM "Tape Teste"
DEFB 'r'+$80
DEFB ' '+$80

Edit Menu
Jump table for the Edit menu

L2790:

DEFB $05
DEFB $00
DEFW L2742
DEFB $01
DEFW L2851
DEFB $02
DEFW L2811
DEFB $03
DEFW L2862
DEFB $04
DEFW L281C

Text for the Edit menu

L27A0:

DEFB $06
DEFM "Options "
DEFB $FF
DEFM "128 BASI"
DEFB 'C'+$80
DEFM "Renumbe"
DEFB 'r'+$80
DEFM "Scree"
DEFB 'n'+$80

Number of entries.

Tape Loader option handler.

128 BASIC option handler.

Calculator option handler.

48 BASIC option handler.

Tape Tester option handler.

Number of entries.
Menu title.

$A0. End marker.

Number of entries.

(Return to) 128 BASIC option handler.

Renumber option handler.

Screen option handler.

Print option handler.

Exit option handler.

Number of entries.

146

SPECTRUM 128 ROM 0 DISASSEMBLY

DEFM "Prin"
DEFB 't'+$80
DEFM "Exi"
DEFB 't'+$80
DEFB ' '+$80

$A0. End marker.

Calculator Menu
Jump table for the Calculator menu

L27CB:

DEFB $02
DEFB $00
DEFW L2742
DEFB $01
DEFW L281C

Text for the Calculator menu

Number of entries.

(Return to) Calculator option handler.

Exit option handler.

L27D2:

DEFB 03
DEFM "Options "
DEFB $FF
DEFM "Calculato"
DEFB 'r'+$80
DEFM "Exi"
DEFB 't'+$80
DEFB ' '+$80

Number of entries.

$A0. End marker.

Tape Loader Text

L27EB:

DEFB $16, $01, $00
DEFB $10, $00
DEFB $11, $07
DEFB $13, $00
DEFM "To cancel - press BREAK
twic"
DEFB 'e'+$80

AT 1,0
INK 0
PAPER 7
BRIGHT 1

Menu Handler Routines

Edit Menu — Screen Option

L2811:

CALL L269B
JR L2874

Toggle between editing in the lower and upper screen areas.
Jump ahead.

Main Menu — Tape Tester Option

L2816:

CALL L3857
CALL L3BE9

Clear screen and print the "Tape Tester" in the banner.
Run the tape tester, exiting via the 'Exit' option menu handler.

Edit Menu / Calculator Menu — Exit Option

L281C:

LD HL,$EC0D
RES 6,(HL)
CALL L28BE
LD B,$00

Editor flags.
Indicate main screen editing.
Reset Cursor Position.
Top row to clear.

147

SPECTRUM 128 ROM 0 DISASSEMBLY

LD D,$17
CALL L3B5E
CALL L1F20
JP L259F

Bottom row to clear.
Clear specified display rows.
Use Normal RAM Configuration (physical RAM bank 0).
Jump back to show the menu.

Main Menu — Tape Loader Option

L2831:

CALL L3852
LD HL,$5C3C
SET 0,(HL)
LD DE,L27EB
CALL L057D
RES 0,(HL)
SET 6,(HL)

LD A,$07
LD ($EC0E),A
LD BC,$0000
CALL L372B
JP L1AF1

Clear screen and print "Tape Loader" in the banner line.
TVFLAG.
Signal using lower screen area.
Point to message "To cancel - press BREAK twice".
Print the text.
Signal using main screen area.
[This bit is unused in the 48K Spectrum and only ever set in 128K mode via the
Tape Loader option. It is never subsequently tested or reset. It may have been the
intention to use this to indicate that the screen requires clearing after loading to
remove the "Tape Loader" banner and the lower screen message "To cancel - press
BREAK twice"]
Tape Loader mode.
[Redundant since call to $1AF1 (ROM 0) will set it to $FF]

Perform 'Print AT 0,0;'.
Run the tape loader.

Edit Menu — Renumber Option

L2851:

CALL L3888
CALL NC,L26E7
LD HL,$0000
LD ($5C49),HL
LD ($EC08),HL
JR L2865

Run the renumber routine.
If not successful then produce error beep if required.
There is no current line number.
E_PPC. Current line number.
Temporary E_PPC used by BASIC Editor.
Jump ahead to display the "128 BASIC" banner if required, set the menu mode and
return.

Edit Menu — Print Option

L2862:

CALL L1B14

Perform an LLIST.

Edit Menu - Renumber option joins here

L2865:

L286C:

LD HL,$EC0D
BIT 6,(HL)
JR NZ,L2874
LD HL,$5C3C
RES 0,(HL)
CALL L3848

Edit Menu - Screen option joins here

L2874:

LD HL,$EC0D
RES 5,(HL)
RES 4,(HL)
LD A,$00
LD HL,L2790
LD DE,L27A0
JR L28B1

Editor flags.
Using lower editing screen?
Jump ahead if so.
TVFLAG.
Allow leading space.
Clear screen and print the "128 BASIC" banner line.

Editor flags.
Signal not to process the BASIC line.
Signal return to main menu.
Select Edit menu mode. [Could have saved 1 byte by using XOR A]
Edit Menu jump table.
Edit Menu text table.
Store the new mode and menu details.

148

SPECTRUM 128 ROM 0 DISASSEMBLY

Main Menu — Calculator Option

L2885:

LD HL,$EC0D
SET 5,(HL)
SET 4,(HL)
RES 6,(HL)
CALL L28BE
CALL L384D
LD A,$04
LD ($EC0E),A
LD HL,$0000
LD ($5C49),HL
CALL L152F
LD BC,$0000
LD A,B
CALL L29F8
LD A,$04
LD HL,L27CB
LD DE,L27D2

Editor flags.
Signal to process the BASIC line.
Signal return to calculator.
Signal editing are is the main screen.
Reset cursor position.
Clear screen and print "Calculator" in the banner line.
Set calculator mode.
Store mode.
No current line number.
E_PPC. Store current line number.
Relist the BASIC program.
B=Row. C=Column. Top left of screen.
Preferred column.
Store editing position and print cursor.
Select calculator mode.
Calculator Menu jump table
Calculator Menu text table

Edit Menu - Print option joins here

L28B1:

LD ($EC0E),A
LD ($F6EA),HL
LD ($F6EC),DE
JP L2604

Store mode.
Store address of current menu jump table.
Store address of current menu text.
Return to the Editor.

EDITOR ROUTINES — PART 3

Reset Cursor Position

L28BE:

CALL L2E1F
CALL L3A7F
JP L28E8

Reset to main screen.
Set default main screen editing cursor details.
Set default main screen editing settings.

Return to Main Menu

L28C7:

LD B,$00
LD D,$17
CALL L3B5E
JP L25AD

Top row of editing area.
Bottom row of editing area.
Clear specified display rows.
Jump to show Main menu.

Main Screen Error Cursor Settings
Main screen editing cursor settings.
Gets copied to $F6EE.

L28D1:

DEFB $06
DEFB $00
DEFB $00
DEFB $00
DEFB $04
DEFB $10
DEFB $14

Number of bytes in table.
$F6EE = Cursor position - row 0.
$F6EF = Cursor position - column 0.
$F6F0 = Cursor position - column 0 preferred.
$F6F1 = Top row before scrolling up.
$F6F2 = Bottom row before scrolling down.
$F6F3 = Number of rows in the editing area.

149

SPECTRUM 128 ROM 0 DISASSEMBLY

Lower Screen Good Cursor Settings
Lower screen editing cursor settings.
Gets copied to $F6EE.

L28D8:

DEFB $06
DEFB $00
DEFB $00
DEFB $00
DEFB $00
DEFB $01
DEFB $01

Number of bytes in table.
$F6EE = Cursor position - row 0.
$F6EF = Cursor position - column 0.
$F6F0 = Cursor position - column 0 preferred.
$F6F1 = Top row before scrolling up.
$F6F2 = Bottom row before scrolling down.
$F6F3 = Number of rows in the editing area.

Initialise Lower Screen Editing Settings
Used when selecting lower screen. Copies 6 bytes from $28D9 (ROM 0) to $F6EE.

L28DF:

LD HL,L28D8
LD DE,$F6EE
JP L3FBA

Default lower screen editing information.
Editing information stores.
Copy bytes.

Initialise Main Screen Editing Settings
Used when selecting main screen. Copies 6 bytes from $28D2 (ROM 0) to $F6EE.

L28E8:

LD HL,L28D1
LD DE,$F6EE
JP L3FBA

Default main screen editing information.
Editing information stores.
Copy bytes.

Handle Key Press Character Code
This routine handles a character typed at the keyboard, inserting it into the Screen Line Edit Buffer as appropriate.
Entry:

A=Key press character code.

L28F1:

LD HL,$EC0D
OR A
OR A
BIT 0,(HL)
JP NZ,L29F2
RES 7,(HL)
SET 3,(HL)
PUSH HL
PUSH AF
CALL L29EC
POP AF
PUSH AF
CALL L2E81
POP AF
LD A,B
CALL L2B78

POP HL
SET 7,(HL)
JP NC,L29F2

LD A,B
JP C,L29F8

JP L29F2

Editor flags.
Clear carry flag. [Redundant instruction since carry flag return state never checked]
[Redundant instruction]
Is the Screen Line Edit Buffer is full?
Jump if it is to set attribute at editing position so as to show the cursor, and return.
Signal got a key press.
Signal current line has been altered.
Save address of the flags.
Save key code.
Remove cursor, restoring old attribute.

Get and save key code.
Insert the character into the Screen Line Edit Buffer.
Get key code.
B=Current cursor column position.
Find next Screen Line Edit Buffer editable position to right, moving to next row if
necessary.
Get address of the flags.
Signal wait for a key.
Jump if new position not available to set cursor attribute at existing editing position,
and return.
A=New cursor column position.
Jump if new position is editable to store editing position and print cursor. [This only
needs to be JP $29F8 (ROM 0), thereby saving 3 bytes, since a branch to $29F2
(ROM 0) would have been taken above if the carry flag was reset]
Set attribute at editing position so as to show the cursor, and return.

150

SPECTRUM 128 ROM 0 DISASSEMBLY

DELETE-RIGHT Key Handler Routine
Delete a character to the right. An error beep is not produced if there is nothing to delete.
Symbol:

DEL

Exit: Carry flag set to indicate not to produce an error beep.

L291B:

LD HL,$EC0D
SET 3,(HL)
CALL L29EC
CALL L2F12
SCF
LD A,B
JP L29F8

HL points to Editor flags.
Indicate 'line altered'.
Remove cursor, restoring old attribute. Exit with C=row, B=column.
Delete character to the right, shifting subsequent rows as required.
Signal do not produce an error beep.
A=The new cursor editing position.
Store editing position and print cursor, and then return.

DELETE Key Handler Routine
Delete a character to the left. An error beep is not produced if there is nothing to delete.
Symbol:

DEL

Exit: Carry flag set to indicate not to produce an error beep.

L292B:

LD HL,$EC0D
RES 0,(HL)
SET 3,(HL)
CALL L29EC
CALL L2B5B
CCF
JP C,L29F2

CALL L2F12
SCF
LD A,B
JP L29F8

HL points to Editor flags.
Signal that the Screen Line Edit Buffer is not full.
Indicate 'line altered'.
Remove cursor, restoring old attribute. Exit with C=row, B=column.
Select previous column position (Returns carry flag set if editable).
Signal do not produce an error beep if not editable.
Jump if not editable to set attribute at editing position so as to show the cursor, and
return.
Delete character to the right, shifting subsequent rows as required.
Signal do not produce an error beep.
A=The new cursor editing position.
Store editing position and print cursor, and then return.

ENTER Key Handler Routine
This routine handles ENTER being pressed. If not on a BASIC line then it does nothing. If on an unaltered BASIC line then insert a blank row after it and
move the cursor to it. If on an altered BASIC line then attempt to enter it into the BASIC program, otherwise return to produce an error beep.
Exit: Carry flag reset to indicate to produce an error beep.

L2944:

CALL L29EC
PUSH AF
CALL L30B4
PUSH BC
LD B,$00
CALL L2E41

POP BC
JR C,L295E

Remove cursor, restoring old attribute.
Save preferred column number.
DE=Start address in Screen Line Edit Buffer of the row specified in C.
Stack current editing position.
Column 0.
Is this a blank row? i.e. Find editable position on this row to the right, returning
column number in B.
Retrieve current editing position.
Jump ahead if editable position found, i.e. not a blank row.

No editable characters on the row, i.e. a blank row

LD HL,$0020
ADD HL,DE
LD A,(HL)
CPL
AND $09
JR Z,L297A

Point to the flag byte for the row.
Fetch the flag byte.
Invert it.
Keep the 'first row' and 'last row' flags.
Jump if both flags were set indicating not on a BASIC line.

151

SPECTRUM 128 ROM 0 DISASSEMBLY

On a BASIC line

L295E:

LD A,($EC0D)
BIT 3,A
JR Z,L296A

Editor flags.
Has the current line been altered?
Jump ahead if not.

The current BASIC line has been altered

L296A:

CALL L2C8E
JR NC,L297F
CALL L2C4C

CALL L2B78
CALL L2ECE

Enter line into program.
Jump if syntax error to produce an error beep.
Find end of the current BASIC line in the Screen Line Edit Buffer, scrolling up rows
as required. Returns column number into B.
Find address of end position in current BASIC line. Returns address into HL.
Insert a blank line in the Screen Line Edit Buffer, shifting subsequent rows down.

Display the cursor on the first column of the next row

LD B,$00
POP AF
SCF
JP L29F8

First column.
A=Preferred column number.
Signal do not produce an error beep.
Store editing position and print cursor, and then return.

Cursor is on a blank row, which is not part of a BASIC line

L297A:

POP AF
SCF
JP L29F2

Discard stacked item.
Signal do not produce an error beep.
Set attribute at current editing position so as to show the cursor, and return.

A syntax error occurred so return signalling to produce an error beep

L297F:

POP AF
JP L29F2

Discard stacked item.
Set attribute at current editing position so as to show the cursor, and return.

TOP-OF-PROGRAM Key Handler Routine
Move to the first row of the first line of the BASIC program. An error beep is not produced if there is no program.
Symbol:

Exit: Carry flag set to indicate not to produce an error beep.

L2983:

LD A,($EC0E)
CP $04
RET Z

Fetch mode.
Calculator mode?
Exit if so.

Editor mode

CALL L29EC
LD HL,$0000
CALL L1F20
RST 28H
DEFW LINE_ADDR
RST 28H
DEFW LINE_NO
CALL L1F45
LD ($5C49),DE
LD A,$0F
CALL L3A96
CALL L152F
SCF
JP L29F2

Remove cursor, restoring old attribute.
The first possible line number.
Use Normal RAM Configuration (physical RAM bank 0).
Find address of line number 0, or the next line if it does not exist.
$196E. Return address in HL.
Find line number for specified address, and return in DE.
$1695. DE=Address of first line in the BASIC program.
Use Workspace RAM configuration (physical RAM bank 7).
E_PPC. Store the current line number.
Paper 1, Ink 7 - Blue.
Set the cursor colour.
Relist the BASIC program.
Signal do not produce an error beep.
Set attribute at editing position so as to show the cursor, and return.

152

SPECTRUM 128 ROM 0 DISASSEMBLY

END-OF-PROGRAM Key Handler Routine
Move to the last row of the bottom line of the BASIC program. An error beep is not produced if there is no program.
Symbol:

Exit: Carry flag set to indicate not to produce an error beep.

L29AB:

LD A,($EC0E)
CP $04
RET Z

Fetch mode.
Calculator mode?
Exit if so.

Editor mode

CALL L29EC
LD HL,$270F
CALL L1F20
RST 28H
DEFW LINE_ADDR
EX DE,HL
RST 28H
DEFW LINE_NO
CALL L1F45
LD ($5C49),DE
LD A,$0F
CALL L3A96
CALL L152F
SCF
JP L29F2

Remove cursor, restoring old attribute.
The last possible line number, 9999.
Use Normal RAM Configuration (physical RAM bank 0).
Find address of line number 9999, or the previous line if it does not exist.
$196E. Return address in HL.
DE=Address of last line number.
Find line number for specified address, and return in DE.
$1695. DE=Address of last line in the BASIC program.
Use Workspace RAM configuration (physical RAM bank 7).
E_PPC. Store the current line number.
Paper 1, Ink 7 - Blue.
Set the cursor colour.
Relist the BASIC program.
Signal do not produce an error beep.
Set attribute at editing position so as to show the cursor, and return.

WORD-LEFT Key Handler Routine
This routine moves to the start of the current word that the cursor is on, or if it is on the first character of a word then it moves to the start of the previous
word. If there is no word to move to then signal to produce an error beep.
Symbol:

Exit: Carry flag reset to indicate to produce an error beep.

L29D4:

CALL L29EC
CALL L2BEA
JP NC,L29F2

LD A,B

JP L29F8

Remove cursor, restoring old attribute.
Find start of the current word to the left.
Jump if no word to the left to restore cursor attribute at current editing position, and
return. [Could have saved 4 bytes by joining the routine below, i.e. JR $29E7]
A=New cursor column number. Carry flag is set indicating not to produce an error
beep.
Store editing position and print cursor, and then return.

WORD-RIGHT Key Handler Routine
This routine moves to the start of the next word. If there is no word to move to then signal to produce an error beep.
Symbol:

Exit: Carry flag reset to indicate to produce an error beep.

L29E1:

CALL L29EC
CALL L2C09
JR NC,L29F2

LD A,B

JR L29F8

Remove cursor, restoring old attribute.
Find start of the current word to the right.
Jump if no word to the right to restore cursor attribute at current editing position, and
return.
A=The new cursor editing column number. Carry is set indicating not to produce an
error beep.
Store editing position and print cursor, and then return.

153

SPECTRUM 128 ROM 0 DISASSEMBLY

Remove Cursor
Remove editing cursor colour from current position.
Exit: C=row number.
B=Column number.

L29EC:

CALL L2A07
JP L364F

Get current cursor position (C=row, B=column, A=preferred column).
Restore previous colour to character square

Show Cursor
Set editing cursor colour at current position.
Exit: C=row number.
B=Column number.

L29F2:

CALL L2A07
JP L3640

Get current cursor position (C=row, B=column, A=preferred column).
Set editing position character square to cursor colour to show it. [Could have saved
1 byte by using a JR instruction to join the end of the routine below]

Display Cursor
Set editing cursor position and colour and then show it.
Entry:

C=Row number.
B=Column number.
A=Preferred column number.

Store new editing position.

Paper 1, Ink 7 - Blue.
Store new cursor colour.

Set editing position character square to cursor colour to show it.

Editing info.
Row number.

Column number.

Preferred column number.

L29F8:

CALL L2A11
PUSH AF
PUSH BC
LD A,$0F
CALL L3A96
POP BC
POP AF
JP L3640

Fetch Cursor Position
Returns the three bytes of the cursor position.
Exit : C=Row number.
B=Column number
A=Preferred column number.

L2A07:

LD HL,$F6EE
LD C,(HL)
INC HL
LD B,(HL)
INC HL
LD A,(HL)
INC HL
RET

Store Cursor Position
Store new editing cursor position.
Entry:

C=Row number.
B=Column number.
A=Preferred column number.

L2A11:

LD HL,$F6EE

Editing information.

154

SPECTRUM 128 ROM 0 DISASSEMBLY

LD (HL),C
INC HL
LD (HL),B
INC HL
LD (HL),A
RET

Row number.

Column number.

Preferred column number.

Get Current Character from Screen Line Edit Buffer

L2A1A:

PUSH HL
CALL L30B4
LD H,$00
LD L,B
ADD HL,DE
LD A,(HL)
POP HL
RET

DE=Start address in Screen Line Edit Buffer of the row specified in C.
[Could have saved 2 bytes by calling the unused routine at $2E7B (ROM 0)]

Point to the column position within the row.
Get character at this position.

TEN-ROWS-DOWN Key Handler Routine
Move down 10 rows within the BASIC program, attempting to place the cursor as close to the preferred column number as possible.
An error beep is produced if there is not 10 rows below.
Symbol:

Exit: Carry flag reset to indicate to produce an error beep.

L2A25:

L2A2B:

CALL L29EC
LD E,A
LD D,$0A
PUSH DE
CALL L2B30

POP DE

JR NC,L29F2

LD A,E
CALL L2A11
LD B,E
CALL L2AF9

JR NC,L2A42
DEC D
JR NZ,L2A2B
LD A,E
JR C,L29F8

Remove cursor, restoring old attribute.
E=Preferred column.
The ten lines to move down.

Move down to the next row, shifting rows up as appropriate. If moving onto a new
BASIC line then
insert the previous BASIC line into the BASIC program if it has been altered. Returns
new row number in C.
Jump if there was no row below to set attribute at editing position so as to show the
cursor, and return.
A=Preferred column.
Store cursor editing position.
B=Preferred column.
Find closest Screen Line Edit Buffer editable position to the right else to the left,
returning column number in B.
Jump if no editable position found on the row, i.e. a blank row.
Decrement row counter.
Repeat to move down to the next row.
A=Preferred column.
Jump if editable row exists to store editing position and print cursor, and then return.
[Redundant check of the carry flag, should just be JR $29F8 (ROM 0)]

A blank row was found below, must be at the end of the BASIC program

L2A42:

PUSH DE
CALL L2B0B
POP DE
LD B,E
CALL L2AF9

LD A,E
OR A
JR L29F8

Move back up to the previous row.

B=Preferred column.
Find closest Screen Line Edit Buffer editable position to the right else to the left,
returning column number in B.
A=Preferred column.
Carry will be reset indicating to produce an error beep.
Store editing position and print cursor, and then return.

155

SPECTRUM 128 ROM 0 DISASSEMBLY

TEN-ROWS-UP Key Handler Routine
Move up 10 rows within the BASIC program, attempting to place the cursor as close to the preferred column number as possible.
An error beep is produced if there is not 10 rows above.
Symbol:

Exit: Carry flag reset to indicate to produce an error beep.

L2A4F:

L2A55:

CALL L29EC
LD E,A
LD D,$0A
PUSH DE
CALL L2B0B

POP DE
JR NC,L29F2

LD A,E
CALL L2A11
LD B,E
CALL L2B02

JR NC,L2A6D
DEC D
JR NZ,L2A55
LD A,E
JP C,L29F8

Remove cursor, restoring old attribute.
E=Preferred column.
The ten lines to move up.

Move up to the previous row, shifting rows down as appropriate. If moving onto a
new BASIC line then
insert the previous BASIC line into the BASIC program if it has been altered.
Jump if there was no row above to set cursor attribute colour at existing editing
position, and return.
A=Preferred column.
Store cursor editing position.
B=Preferred column.
Find closest Screen Line Edit Buffer editable position to the left else right, return
column number in B.
Jump if no editable positions were found in the row, i.e. it is a blank row.
Decrement row counter.
Repeat to move up to the previous row.
A=Preferred column.
Jump if editable row exists to store editing position and print cursor, and then return.
[Redundant check of the carry flag, should just be JP $29F8 (ROM 0)]

A blank row was found above, must be at the start of the BASIC program [???? Can this ever be the case?]

L2A6D:

PUSH AF
CALL L2B30
LD B,$00
CALL L2BD4

POP AF
JP L29F8

Save the preferred column number and the flags.
Move back down to the next row. Returns new row number in C.
Column 0.
Find editable position in the Screen Line Edit Buffer row to the right, return column
position in B.
A=Preferred column. Carry will be reset indicating to produce an error beep.
Store editing position and print cursor, and then return.

END-OF-LINE Key Handler Routine
Move to the end of the current BASIC line. An error beep is produced if there is no characters in the current BASIC line.
Symbol:

Exit: Carry flag reset to indicate to produce an error beep and set not to produce an error beep.

L2A7A:

CALL L29EC
CALL L2C4C
JP NC,L29F2

LD A,B

JP L29F8

Remove cursor, restoring old attribute.
Find the end of the current BASIC line in the Screen Line Edit Buffer.
Jump if a blank row to set attribute at existing editing position so as to show the
cursor, and return.
A=The new cursor editing column number. Carry is set indicating not to produce an
error beep.
Store editing position and print cursor, and then return.

START-OF-LINE Key Handler Routine
Move to the start of the current BASIC line. An error beep is produced if there is no characters in the current BASIC line.
Symbol:

156

SPECTRUM 128 ROM 0 DISASSEMBLY

Exit: Carry flag reset to indicate to produce an error beep.

L2A87:

CALL L29EC
CALL L2C31
JP NC,L29F2

LD A,B

JP L29F8

Remove cursor, restoring old attribute.
Find the start of the current BASIC line in the Screen Line Edit Buffer.
Jump if a blank row to set attribute at existing editing position so as to show the
cursor, and return.
A=The new cursor editing position. Carry is set indicating not to produce an error
beep.
Store editing position and print cursor, and then return.

CURSOR-UP Key Handler Routine
Move up 1 row, attempting to place the cursor as close to the preferred column number as possible.
An error beep is produced if there is no row above.
Exit: Carry flag reset to indicate to produce an error beep.

L2A94:

CALL L29EC
LD E,A
PUSH DE
CALL L2B0B

POP DE
JP NC,L29F2

LD B,E
CALL L2B02

LD A,E
JP C,L29F8

Remove cursor, restoring old attribute.
E=Preferred column.

Move up to the previous row, shifting rows down as appropriate. If moving onto a
new BASIC line then
insert the previous BASIC line into the BASIC program if it has been altered.
Jump if there was no row above to set cursor attribute colour at existing editing
position, and return.
B=Preferred column.
Find closest Screen Line Edit Buffer editable position to the left else right, return
column number in B.
A=Preferred column.
Jump if an editable position was found to store editing position and print cursor, and
then return.

A blank row was found above, must be at the start of the BASIC program [???? Can this ever be the case?]

PUSH AF
CALL L2B30

LD B,$00
CALL L2AF9
POP AF
JP L29F8

Save the preferred column number and the flags.
Move down to the next row, shifting rows up as appropriate. Returns new row
number in C.
Column 0.
Find closest Screen Line Edit Buffer editable position to the right.
A=Preferred column. Carry flag is reset indicating to produce an error beep.
Store editing position and print cursor, and then return.

CURSOR-DOWN Key Handler Routine
Move down 1 row, attempting to place the cursor as close to the preferred column number as possible.
An error beep is produced if there is no row below.
Exit: Carry flag reset to indicate to produce an error beep.

L2AB5:

CALL L29EC
LD E,A
PUSH DE
CALL L2B30

POP DE

JP NC,L29F2

LD B,E
CALL L2B02

LD A,E
JP C,L29F8

Remove cursor, restoring old attribute.
E=Preferred column.

Move down to the next row, shifting rows up as appropriate. If moving onto a new
BASIC line then
insert the previous BASIC line into the BASIC program if it has been altered. Returns
new row number in C.
Jump if there was no row below to set attribute at editing position so as to show the
cursor, and return.
B=Preferred column.
Find closest Screen Line Edit Buffer editable position to the left else right, return
column number in B.
A=Preferred column.
Jump if an editable position was found to store editing position and print cursor, and
then return.

157

A blank row was found above, must be at the start of the BASIC program [???? Can this ever be the case?]

SPECTRUM 128 ROM 0 DISASSEMBLY

PUSH DE
CALL L2B0B
POP DE
LD B,E
CALL L2AF9

LD A,E
OR A
JP L29F8

Save the preferred column.
Move up to the previous row, shifting rows down as appropriate.

B=Preferred column.
Find closest Screen Line Edit Buffer editable position to the right else to the left,
returning column number in B.
A=Preferred column.
Reset carry flag to indicate to produce an error beep.
Store editing position and print cursor, and then return.

CURSOR-LEFT Key Handler Routine
Move left 1 character, stopping if the start of the first row of the first BASIC line is reached.
An error beep is produced if there is no character to the left or no previous BASIC line to move to.
Exit: Carry flag reset to indicate to produce an error beep.

L2AD7:

CALL L29EC
CALL L2B5B

JP C,L29F8

Remove cursor, restoring old attribute. Returns with C=row, B=column.
Find next Screen Line Edit Buffer editable position to left, wrapping to previous row
as necessary.
Jump if editable position found to store editing position and print cursor, and then
return.

A blank row was found above, must be at the start of the BASIC program

JP L29F2

Set cursor attribute at existing editing position, and return. Carry flag is reset
indicating to produce an error beep.

CURSOR-RIGHT Key Handler Routine
Move right 1 character, stopping if the end of the last row of the last BASIC line is reached.
An error beep is produced if there is no character to the right or no next BASIC line to move to.
Exit: Carry flag reset to indicate to produce an error beep.

L2AE3:

CALL L29EC
CALL L2B78

JP C,L29F8

Remove cursor, restoring old attribute.
Find next Screen Line Edit Buffer editable position to right, wrapping to next row if
necessary.
Jump if editable position found to store editing position and print cursor, and then
return.

A blank row was found below, must be at the end of the BASIC program

PUSH AF
CALL L2B0B
LD B,$1F
CALL L2BDF

POP AF
JP L29F8

Save the carry flag and preferred column number.
Move up to the previous row, shifting rows down as appropriate.
Column 31.
Find the last editable column position searching to the left, returning the column
number in B. (Returns carry flag set if there is one)
Carry flag is reset indicating to produce an error beep.
Store editing position and print cursor, and then return.

Edit Buffer Routines — Part 1

Find Closest Screen Line Edit Buffer Editable Position to the Right else Left
This routine searches the specified Screen Line Edit Buffer row from the specified column to the right looking for the first editable position. If one cannot
be found then a search is made to the left.
B=Column number.
Entry:
Carry flag set if character at specified column is editable.
Exit :
B=Number of closest editable column.

158

SPECTRUM 128 ROM 0 DISASSEMBLY

HL=Address of closest editable position.

L2AF9:

PUSH DE
CALL L2BD4

CALL NC,L2BDF

POP DE
RET

Find Screen Line Edit Buffer editable position from previous column (or current
column if the previous column does not exist) to the right, return column position in
B.
If no editable character found then search to the left for an editable character, return
column position in B.

Find Closest Screen Line Edit Buffer Editable Position to the Left else Right
This routine searches the specified Screen Line Edit Buffer row from the specified column to the left looking for the first editable position. If one cannot
be found then a search is made to the right.
B=Column number.
Entry:
Carry flag set if character at specified column is editable.
Exit :
B=Number of closest editable column.
HL=Address of closest editable position.

L2B02:

PUSH DE
CALL L2BDF

CALL NC,L2BD4

POP DE
RET

Find Screen Line Edit Buffer editable position to the left, returning column position in
B.
If no editable character found then search from previous column (or current column if
the previous column does not exist) to the right, return column position in B.

Insert BASIC Line, Shift Edit Buffer Rows Down If Required and Update Display File If Required
Called from the cursor up and down related key handlers. For example, when cursor up key is pressed the current BASIC line may need to be inserted
into the BASIC program if it has been altered. It may also be necessary to shift all rows down should the upper scroll threshold be reached. If the cursor
was on a blank row between BASIC lines then it is necessary to shift all BASIC lines below it up, i.e. remove the blank row.
Entry:
Exit :

C=Current cursor row number in the Screen Line Edit Buffer.
C=New cursor row number in the Screen Line Edit Buffer.
Carry flag set if a new row was moved to.

L2B0B:

CALL L2C7C

JR NC,L2B2F
PUSH BC
CALL L30B4
LD B,$00
CALL L2E41

CALL NC,L2F80

POP BC
LD HL,$F6F1
LD A,(HL)
CP C
JR C,L2B2D

If current BASIC line has been altered and moved off of then insert it into the
program.
Jump if BASIC line was not inserted. [Could have saved 1 byte by using RET NC]
Save the new cursor row and column numbers.
DE=Start address in Screen Line Edit Buffer of the row specified in C.
Column 0.
Is this a blank row? i.e. Find editable position on this row to the right, returning
column number in B.
If no editable position found then the cursor is on a blank row so shift all BASIC lines
below it up to close the gap.
Retrieve the new cursor row and column numbers.
Point to the editing area information.
Fetch the upper scroll threshold.
Is it on the threshold?
Jump if on a row below the threshold.

The upper row threshold for triggering scrolling the screen has been reached so proceed to scroll down one row

PUSH BC
CALL L166F
POP BC
RET C

Save the new cursor row and column numbers.
Shift all edit buffer rows down, and update display file if required.

Return if edit buffer rows were shifted.

The edit buffer rows were not shifted down

159

LD A,C
OR A
RET Z
DEC C
SCF
RET

L2B2D:

L2B2F:

SPECTRUM 128 ROM 0 DISASSEMBLY

On the top row of the editing area?

Return with carry flag reset if on the top row.
Move onto the previous row.
Signal a new row was moved to.

Insert BASIC Line, Shift Edit Buffer Rows Up If Required and Update Display File If Required
Called from the cursor up and down related key handlers. For example, when cursor down key is pressed the current BASIC line may need to be inserted
into the BASIC program if it has been altered. It may also be necessary to shift all rows up should the lower scroll threshold be reached. If the cursor was
on a blank row between BASIC lines then it is necessary to shift all BASIC lines below it up, i.e. remove the blank row.
Entry:
Exit :

C=Current cursor row number in the Screen Line Edit Buffer.
C=New cursor row number in the Screen Line Edit Buffer.
Carry flag set if a new row was moved to.

L2B30:

L2B3F:

PUSH BC
CALL L30B4

LD B,$00
CALL L2E41

POP BC
JR C,L2B3F

JP L2F80
CALL L2C68
JR NC,L2B5A

Save row number.
DE=Start address in Screen Line Edit Buffer of row held in C, i.e. the new cursor
row.
Column 0.
Is this a blank row? i.e. Find editable position on this row to the right, returning
column number in B.
Get row number.
Jump if editable position found, i.e. the row exists. [Could have saved 2 bytes by
using JP NC,$2F80 (ROM 0)]
Cursor is on a blank row so shift all BASIC lines below it up to close the gap.
Insert the BASIC Line into the BASIC program if the line has been altered.
Jump if the line was inserted into the program. [Could have saved 1 byte by using
RET NC]

The BASIC line was not inserted into the program. C=New cursor row number, B=New cursor column number, A=New cursor preferred column number

LD HL,$F6F1
INC HL

LD A,C
CP (HL)
JR C,L2B58

Point to the editing area information.
Point to the 'Bottom Row Scroll Threshold' value. [Could have saved 1 byte by using
LD HL,$F6F2]
Fetch the new cursor row number.
Is it on the lower scroll threshold?
Jump if on a row above the threshold.

The lower row threshold for triggering scrolling the screen has been reached so proceed to scroll up one row

PUSH BC
PUSH HL
CALL L1639
POP HL
POP BC
RET C

Save the new cursor row and column numbers.
Save the editing area information address.
Shift all edit buffer rows up, and update display file if required.

Return if edit buffer rows were shifted.

The edit buffer rows were not shifted up

INC HL
LD A,(HL)
CP C
RET Z
INC C
SCF
RET

L2B58:

L2B5A:

Point to the 'Number of Rows in the Editing Area' value.
A=Number of rows in the editing area.
On the last row of the editing area?
Return with carry flag reset if on the bottom row.
Move onto the next row.
Signal a new row was moved to.

Find Next Screen Line Edit Buffer Editable Position to Left, Wrapping Above if Required
This routine searches to the left to see if an editable position exists. If there is no editable position available to the left on the current row then the previous
row is examined from the last column position.
B=Column number.
Entry:

160

Exit :

L2B5B:

SPECTRUM 128 ROM 0 DISASSEMBLY

Carry flag reset.
Carry flag set if a position to the 'left' exists.
B=Number of new editable position.
HL=Address of new editable position.

LD D,A
DEC B
JP M,L2B66
LD E,B
CALL L2BDF

LD A,E
RET C

Save the key code character.
Back one column position.
Jump if already at beginning of row.
E=Column number.
Find Screen Line Edit Buffer editable position to the left, returning column position in
B.
A=Column number.
Return if the new column is editable, i.e. the cursor can be moved within this row.

Wrap above to the previous row

L2B66:

PUSH DE
CALL L2B0B

POP DE
LD A,E
RET NC

A row above exists

LD B,$1F
CALL L2BDF

LD A,B
RET C

LD A,D
LD B,$00
RET

Return column 0

E=Store the column number.
Move up to the previous row, shifting rows down as appropriate. If moving onto a
new BASIC line then
insert the previous BASIC line into the BASIC program if it has been altered.
A=Column number.
Return if there was no row above.

Column 31.
Find the last editable column position searching to the left, returning the column
number in B. (Returns carry flag set if there is one)
A=Column number of the closest editable position.
Return if an editable position was found, i.e. the cursor can be moved.

Restore the key code character.
Set column position 0.
[BUG - This should really ensure the carry flag is reset to signal that no editable
position to the left exists, e.g. by using OR A. Fortunately, the carry flag is always
reset when this routine is called and so the bug is harmless. Credit: Paul Farrow]

Find Next Screen Line Edit Buffer Editable Position to Right, Wrapping Below if Required
This routine searches to the right to see if an editable position exists. If there is no editable position available to the right on the current row then the
next row is examined from the first column position.
The routine is also called when a character key has been pressed and in this case if the cursor moves to the next row then a blank row is inserted and
all affected rows are shifted down.
Entry:

Exit :

L2B78:

B=Column number.
C=Row number.
Carry flag set if a position to the 'right' exists.
B=Number of closest editable column, i.e. new column number.
A=New column position, i.e. preferred column number or indentation column number.
HL=Address of the new editable position.

LD D,A
INC B
LD A,$1F
CP B
JR C,L2B85

Save the key code character.
Advance to the next column position.
Column 31.

Jump if reached end of row.

New position is within the row

LD E,B

E=New column number.

161

SPECTRUM 128 ROM 0 DISASSEMBLY

CALL L2BD4

LD A,E
RET C

Find Screen Line Edit Buffer editable position from previous column to the right,
returning column position in B.
A=New column number.
Return if the new column is editable, i.e. the cursor can be moved within this row.

Need to wrap below to the next row

L2B85:

DEC B
PUSH BC
PUSH HL
LD HL,$EC0D
BIT 7,(HL)
JR NZ,L2BC0

B=Original column position.
Save original column and row numbers.
HL=Address of the new editable position.
Editor flags.
Got a key press?
Jump if not.

A key is being pressed so need to insert a new row

CALL L30B4
LD HL,$0020
ADD HL,DE
LD A,(HL)
BIT 1,A
JR NZ,L2BC0

DE=Start address in Screen Line Edit Buffer of the row specified in C.

Point to the flag byte for the current row.

Does the BASIC line row span onto another row?
Jump if so to test the next row (it could just be the cursor).

The BASIC line row does not span onto another row, i.e. cursor at end of line

SET 1,(HL)

RES 3,(HL)
LD HL,$0023
ADD HL,DE
EX DE,HL

POP HL
POP BC
PUSH AF
CALL L2B30

POP AF
CALL L30B4
LD HL,$0023
ADD HL,DE
EX DE,HL
RES 0,A
SET 3,A
CALL L2ED3

Signal that the row spans onto another row, i.e. a new blank row containing the
cursor.
Signal that the row is not the last row of the BASIC line.
Point to the next row.

DE=Address of the next row. [Redundant calculation as never used. Could have
saved 5 bytes]
HL=Address of the new editable position.
B=Original column number. C=Row number.
Save flag byte for the previous row.
Move down to the next row, shifting rows up as appropriate. Returns new row
number in C.
Retrieve flag byte for the previous row.
DE=Start address in Screen Line Edit Buffer of the new row, as specified in C.

HL=Address of the row after the new row.
DE=Address of the row after the new row. HL=Address of the new row.
Signal 'not the start row of the BASIC line'.
Signal 'end row of the BASIC line'.
Insert a blank row into the Screen Edit Buffer at row specified by C, shifting rows
down.

[BUG - When typing a line that spills over onto a new row, the new row needs to be indented. However, instead of the newly inserted row being indented,
it is the row after it that gets indented. The indentation occurs within the Screen Line Edit Buffer and is not immediately reflected in the display file. When
the newly typed line is executed or inserted into the program area, the Screen Line Edit Buffer gets refreshed and hence the effect of the bug is never
normally seen. The bug can be fixed by inserting the following instructions. Credit: Paul Farrow.

LD HL,$FFDD
ADD HL,DE
EX DE,HL

CALL L35F4

LD A,B
SCF
RET

-35.

DE=Points to the start of the previous row.]

Indent the row by setting the appropriate number of null characters in the current
Screen Line Edit Buffer row.
A=First column after indentation.
Signal not to produce an error beep.

Wrap below to the next row. Either a key was not being pressed, or a key was being pressed and the BASIC line spans onto a row below (which could
contain the cursor only)

162

L2BC0:

POP HL
POP BC
PUSH DE
CALL L2B30

POP DE

LD A,B
RET NC

A row below exists

LD B,$00
CALL L2BD4

LD A,B
RET C

LD A,E
LD B,$00
RET

Return column 0

SPECTRUM 128 ROM 0 DISASSEMBLY

HL=Address of the new editable position.
B=Original column position.
E=New column number.
Move down to the next row, shifting rows up as appropriate. If moving onto a new
BASIC line then
insert the previous BASIC line into the BASIC program if it has been altered. Returns
new row number in C.
A=Original column position.
Return if there was no row below.

Column 0.
Find Screen Line Edit Buffer editable position to the right, returning column position
in B.
A=New column position.
Return if an editable position was found, i.e. the cursor can be moved.

A=Preferred column number.
Column 0.
Return with carry flag reset.

Find Screen Line Edit Buffer Editable Position from Previous Column to the Right
This routine finds the first editable character position in the specified Screen Line Edit Buffer row from the previous column to the right.
It  first  checks  the  current  column,  then  the  previous  column  and  then  the  columns  to  the  right.  The  column  containing  the  first  non-null  character
encountered is returned.
Entry:

B=Column number to start searching from.
C=Row number.
Carry flag set if an editable character was found.
B=Number of closest editable column.

PUSH DE
PUSH HL
CALL L30B4
CALL L2E41

JP L2C65

Save registers.

DE=Start address in Screen Line Edit Buffer of the row specified in C.
Find editable position on this row from the previous column to the right, returning
column number in B.
Restore registers and return. [Could have saved a byte by using JR $2C07 (ROM 0)]

Find Screen Line Edit Buffer Editable Position to the Left
This routine finds the first editable character position in the Screen Line Edit Buffer row from the current column to the left.
It first checks the current column and returns this if it contains an editable character. Otherwise it searches the columns to the left and if an editable
character is found then it returns the column to the right of it.
Entry:

B=Column number to start searching from.
C=Row number.
Carry flag set if an editable character was found.
B=Number of the column after the editable position.

PUSH DE
PUSH HL
CALL L30B4
CALL L2E63

JP L2C65

Save registers.

DE=Start address in Screen Line Edit Buffer of the row specified in C.
Find editable position from current column to the left, returning the column number in
B.
Restore registers and return. [Could have saved a byte by using JR $2C07 (ROM 0)]

Exit :

L2BD4:

Exit :

L2BDF:

Find Start of Word to Left in Screen Line Edit Buffer
This routine searches for the start of the current word to the left within the current Screen Line Edit Buffer.

163

SPECTRUM 128 ROM 0 DISASSEMBLY

It is called from the WORD-LEFT key handler routine.
Entry:
Exit :

C=Row number.
Carry flag set if word to the left is found.
B=Column position of the found word.

L2BEA:

PUSH DE
PUSH HL

Save registers.

Search towards the left of this row until a space or start of line is found

L2BEC:

CALL L2B5B

L2BF1:

JR NC,L2C07
CALL L2A1A
CP ' '
JR Z,L2BEC

Find next Screen Line Edit Buffer editable position to left, moving to next row if
necessary.
Jump if not editable, i.e. at start of line.
Get character at new position.
$20. Is it a space?
Jump back if it is, until a non-space or start of line is found.

Search towards the left of this row until the start of the word or start of the line is found

L2BF8:

CALL L2B5B

JR NC,L2C07
CALL L2A1A
CP ' '
JR NZ,L2BF8

A space prior to the word was found

Find next Screen Line Edit Buffer editable position to left, moving to next row if
necessary.
Jump if not editable, i.e. at start of line.
Get character at new position.
$20. Is it a space?
Jump back if it is not, until a space or start of line is found.

CALL L2B78

L2C07:

JR L2C65

Find next Screen Line Edit Buffer editable position to right to start of the word,
moving to next row if necessary. [Returns carry flag set since the character will exist]
Jump forward to restore registers and return.

Find Start of Word to Right in Screen Line Edit Buffer
This routine searches for the start of the current word to the right within the current Screen Line Edit Buffer.
It is called from the WORD-RIGHT key handler routine.
Entry:
Exit :

C=Row number.
Carry flag set if word to the right is found.
B=Column position of the found word.

L2C09:

PUSH DE
PUSH HL

Save registers.

Search towards the right of this row until a space or end of line is found

L2C0B:

CALL L2B78

JR NC,L2C2B
CALL L2A1A
CP ' '
JR NZ,L2C0B

Find next Screen Line Edit Buffer editable position to right, moving to next row if
necessary.
Jump if none editable, i.e. at end of line.
Get character at new position.
$20. Is it a space?
Jump back if it is not, until a space or end of line is found.

Search towards the right of this row until the start of a new word or end of the line is found

L2C17:

CALL L2B78

JR NC,L2C2B
CALL L2E41

JR NC,L2C2B
CALL L2A1A
CP ' '

Find next Screen Line Edit Buffer editable position to right, moving to next row if
necessary.
Jump if none editable, i.e. at end of line.
Find editable position on this row from the previous column to the right, returning
column number in B.
Jump if none editable, i.e. at start of next line.
Get character at new position.
$20. Is it a space?

164

SPECTRUM 128 ROM 0 DISASSEMBLY

JR Z,L2C17

Loop back until a non-space is found, i.e. start of a word.

Start of new word found

SCF
JR L2C65

Indicate cursor position can be moved.
Jump forward to restore registers and return.

End of line or start of next line was found

L2C2B:

CALL NC,L2B5B

OR A
JR L2C65

If no word on this row then find next Screen Line Edit Buffer editable position to left,
moving to previous row if necessary thereby restoring the row number to its original
value. [Carry flag is always reset by here so the test on the flag is unnecessary]
Clear carry flag to indicate cursor position can not be moved.
Jump forward to restore registers and return.

Find Start of Current BASIC Line in Screen Line Edit Buffer
This routine searches for the start of the BASIC line, wrapping to the previous rows as necessary.
It is called from the START-OF-LINE key handler routine.
Entry:
Exit :

C=Row number.
Carry flag set if row is not blank.
B=New cursor column.

L2C31:

L2C33:

PUSH DE
PUSH HL
CALL L30B4
LD HL,$0020
ADD HL,DE
BIT 0,(HL)
JR NZ,L2C45

Not on the first row of the BASIC line

Save registers.

DE=Start address in Screen Line Edit Buffer of the row specified in C.

Point to flag byte of next row.
On first row of the BASIC line?
Jump if on the first row of the BASIC line.

CALL L2B0B

JR C,L2C33
JR L2C65

Move up to the previous row, shifting rows down as appropriate. If moving onto a
new BASIC line then insert the previous BASIC line into the BASIC program if it has
been altered.
Jump back if still on the same BASIC line, i.e. was not on first row of the BASIC line.
Jump forward to restore registers and return.

On the first row of the BASIC line, so find the starting column

L2C45:

LD B,$00
CALL L2BD4

JR L2C65

Column 0.
Find Screen Line Edit Buffer editable position to the right, return column position in
B. (Returns carry flag reset if blank row)
Jump forward to restore registers and return.

Find End of Current BASIC Line in Screen Line Edit Buffer
This routine searches for the end of the BASIC line, wrapping to the next rows as necessary.
It is called from the END-OF-LINE key handler routine.
Entry:
Exit :

C=Row number.
Carry flag set if row is not blank.
B=New cursor column.

L2C4C:

L2C4E:

PUSH DE
PUSH HL
CALL L30B4
LD HL,$0020
ADD HL,DE
BIT 3,(HL)
JR NZ,L2C60

Save registers.

DE=Start address in Screen Line Edit Buffer of the row specified in C.

Point to flag byte of next row.
On last row of the BASIC line?
Jump if on the last row of the BASIC line.

165

Not on the last row of the BASIC line

SPECTRUM 128 ROM 0 DISASSEMBLY

CALL L2B30

JR C,L2C4E
JR L2C65

Move down to the next row, shifting rows up as appropriate. If moving onto a new
BASIC line then insert the previous BASIC line into the BASIC program if it has been
altered. Returns new row number in C.
Jump back if still on the same BASIC line, i.e. was not on last row of the BASIC line.
Jump forward to restore registers and return.

On the last row of the BASIC line, so find the last column

L2C60:

L2C65:

LD B,$1F
CALL L2BDF

POP HL
POP DE
RET

Column 31.
Find the last editable column position searching to the left, returning the column
number in B. (Returns carry flag reset if blank row)
Restore registers.

Insert BASIC Line into Program if Altered

L2C68:

LD A,($EC0D)
BIT 3,A
SCF
RET Z
CALL L30B4
LD HL,$0020
ADD HL,DE
BIT 3,(HL)
SCF
RET Z
JR L2C8E

Editor flags.
Has the current line been altered?
Signal line not inserted into BASIC program.
Return if it has not.
DE=Start address in Screen Line Edit Buffer of the row specified in C.

HL points to the flag byte for the row.
Is this the end of the BASIC line?
Signal line not inserted into BASIC program.
Return if it is not.
Insert line into BASIC program.

Insert Line into BASIC Program If Altered and the First Row of the Line

L2C7C:

LD A,($EC0D)
BIT 3,A
SCF
RET Z
CALL L30B4
LD HL,$0020
ADD HL,DE
BIT 0,(HL)
SCF
RET Z

Editor flags.
Has current line been altered?
Signal success.
Return if it has not.
DE=Start address in Screen Line Edit Buffer of the row specified in C.

Point to the flag byte for the row.
Is this the first row of the BASIC line?
Signal success.
Return if it is not.

Insert Line into BASIC Program
This routine parses a line and if valid will insert it into the BASIC program. If in calculator mode then the line is not inserted into the BASIC program. If
a syntax error is found then the location to show the error marker is determined.
Entry:
Exit :

C=Row number.
Carry flag reset if a syntax error.
Carry flag set if the BASIC line was inserted successfully, and C=Cursor row number, B=Cursor column number, A=Preferred cursor
column number.

L2C8E:

LD A,$02

Signal on first row of BASIC line.

Find the start address of the row in the Screen Line Edit Buffer

L2C90:

CALL L30B4
LD HL,$0020

DE=Start address in Screen Line Edit Buffer of the row specified in C.

166

SPECTRUM 128 ROM 0 DISASSEMBLY

ADD HL,DE
BIT 0,(HL)
JR NZ,L2CA3
DEC C
JP P,L2C90

Point to the flag byte for the row.
First row of the BASIC line?
Jump ahead if so.
Move to previous row.
Jump back until found the first row of the BASIC line or the top of the screen.

First row of the BASIC line is above the screen

LD C,$00
LD A,$01

Row 0.
Signal first row of BASIC line above screen.

DE=Start address of the first row of the BASIC line
HL=Address of the flag byte for the first row of the BASIC line

L2CA3:

LD HL,$EC00
LD DE,$EC03
OR $80
LD (HL),A
LD (DE),A
INC HL
INC DE
LD A,$00
LD (HL),A
LD (DE),A
INC HL
INC DE
LD A,C
LD (HL),A
LD (DE),A
LD HL,$0000
LD ($EC06),HL
CALL L335F

CALL L3C67
PUSH IX
CALL L1F20
CALL L026B
CALL L1F45
POP IX
LD A,($5C3A)
INC A
JR NZ,L2CEF
LD HL,$EC0D
RES 3,(HL)
CALL L365E
LD A,($EC0E)
CP $04
CALL NZ,L152F
CALL L26FA
CALL L2A07
SCF
RET

BASIC line insertion flags.
BASIC line insertion error flags.
Signal location of cursor not yet found.

[Could have saved 1 byte by using XOR A]
Starting column number of the first visible row of the BASIC line being entered.

Fetch the row number of the first visible row of the BASIC line being entered.
Store the start row number of the first visible row of the BASIC line being entered.

No editable characters in the line prior to the cursor.
Copy 'Insert Keyword Representation Into Keyword Construction Buffer' routine to
RAM.
Tokenize the typed BASIC line.
IX=Address of cursor settings.
Use Normal RAM Configuration (physical RAM bank 0).
Syntax check/execute the command line.
Use Workspace RAM configuration (physical RAM bank 7).
IX=Address of cursor settings.
ERR_NR. Fetch error code.
Was an error code set?
Jump ahead if so.
Editor flags.
Signal line has not been altered.
Reset to 'L' Mode.
Fetch mode.
Calculator mode?
If not calculator mode then relist the BASIC program.
Produce success beep.
Get current cursor position (C=Row, B=Column, A=Preferred column).
Set the carry flag to signal that that BASIC line was inserted successfully.

A syntax error occurred

L2CEF:

LD HL,$EC00
LD DE,$EC03
LD A,(DE)
RES 7,A
LD (HL),A
INC HL
INC DE
LD A,(DE)
LD (HL),A
INC HL
INC DE

BASIC line insertion flags.
BASIC line insertion error flags.
Fetch the BASIC line insertion error flags.
Signal location of cursor found.
Update the BASIC line insertion flags with the error flags.

Restore the initial column number, i.e. column 0.

167

SPECTRUM 128 ROM 0 DISASSEMBLY

LD A,(DE)
LD (HL),A

CALL L3C63
JR C,L2D0A

Restore the initial row number, i.e. row number of the first visible row of the BASIC
line being entered.
Locate the position to insert the error marker into the typed BASIC line.
Jump if the error marker was found.

Assume the error maker is at the same position as the cursor

LD BC,($EC06)

Fetch the number of editable characters in the line prior to the cursor within the
Screen Line Edit Buffer.

The position of the error marker within the typed BASIC line has been determined. Now shift the cursor to the corresponding position on the screen.

L2D0A:

LD HL,($EC06)

Fetch the number of editable characters in the line prior to the cursor within the
Screen Line Edit Buffer.

OR A
SBC HL,BC

PUSH AF
PUSH HL
CALL L2A07

POP HL
POP AF
JR C,L2D2A
JR Z,L2D45

HL=Difference between the cursor and the error marker positions (negative if the
error marker is after the cursor).
Save the flags.
HL=Difference between the cursor and error marker.
Get current cursor position, returning C=row number, B=column number,
A=preferred column number.
HL=Difference between the cursor and error marker.
Restore the flags.
Jump if error marker is after the cursor position.
Jump if cursor is at the same location as the error marker.

The error marker is before the cursor position. Move the cursor back until it is at the same position as the error marker.

L2D1B:

PUSH HL
LD A,B
CALL L2B5B

POP HL
JR NC,L2D45
DEC HL
LD A,H
OR L
JR NZ,L2D1B
JR L2D45

Save the number of positions to move.
B=Cursor column number.
Find previous editable position to the left in the Screen Line Edit Buffer, moving to
previous row if necessary.
Retrieve the number of positions to move.
Jump if no previous editable position exists.
Decrement the number of positions to move.

Jump back if the cursor position requires further moving.
Jump ahead to continue.

The error marker is after the cursor position. Move the cursor back until it is at the same position as the error marker.

L2D2A:

PUSH HL

L2D2B:

L2D38:

LD HL,$EC0D
RES 7,(HL)

POP HL
EX DE,HL
LD HL,$0000
OR A
SBC HL,DE
PUSH HL
LD A,B
CALL L2B78

POP HL
JR NC,L2D45
DEC HL
LD A,H
OR L
JR NZ,L2D38

Save the number of positions that the error marker is before the cursor. This will be
a negative number is the cursor is after the error marker.
Editor flags.
Signal 'got a key press'. Used in routine at $2B78 (ROM 0) to indicate that a new
character has caused the need to shift the cursor position.
Retrieve the negative difference in the cursor and error marker positions.
DE=Negative difference in the cursor and error marker positions.
Make the negative difference a positive number by subtracting it from 0.

HL=Positive difference in the cursor and error marker positions.
Save the number of positions to move.
B=Cursor column number.
Find next editable position to the right in the Screen Line Edit Buffer, moving to next
row if necessary.
Retrieve the number of positions to move.
Jump if no next editable position exists.
Decrement the number of positions to move.

Jump back if the cursor position requires further moving.

The cursor position is at the location of the error marker position

168

SPECTRUM 128 ROM 0 DISASSEMBLY

L2D45:

LD HL,$EC0D
SET 7,(HL)

Editor flags.
Set 'waiting for key press' flag.

[BUG - When moving the cursor up or down, an attempt is made to place the cursor at the same column position that it had on the previous row (the
preferred column). If this is not possible then the cursor is placed at the end of the row. However, it is the intention that the preferred column is still
remembered and hence an attempt is made to place the cursor at this column whenever it is subsequently moved. However, a bug at this point in the
ROM causes the preferred column position for the cursor to be overwritten with random data. If the cursor was moved from its original position into its
error position then the preferred column gets set to zero and the next up or down cursor movement will cause the cursor marker to jump to the left-hand
side of the screen. However, if the cursor remained in the same position then the preferred column gets set to a random value and so on the next up
or down cursor movement the cursor marker can jump to a random position on the screen. The bug can can reproduced by typing a line that is just
longer than one row, pressing enter twice and then cursor down. The cursor marker will probably jump somewhere in the middle of the screen. Press
an arrow again and the computer may even crash. Credit: Ian Collier (+3), Andrew Owen (128)] [The bug can be fixed by pre-loading the A register with
the current preferred column number. Credit: Paul Farrow.

LD A,($F6F0)

Fetch the preferred column position.]

CALL L2A11
LD A,$17
CALL L3A96
OR A
RET

Store cursor editing position.
Paper 2, Ink 7 - Red.
Set the cursor colour to show the position of the error.
Reset the carry flag to signal that a syntax error occurred.

Fetch Next Character from BASIC Line to Insert
This routine fetches a character from the BASIC line being inserted. The line may span above or below the screen, and so the character is retrieved
from the appropriate buffer.
Exit : A=Character fetched from the current position, or 'Enter' if end of line found.

L2D54:

L2D62:

LD HL,$EC00
BIT 7,(HL)
JR Z,L2D62
LD HL,($EC06)
INC HL

LD ($EC06),HL
LD HL,$EC00
LD A,(HL)
INC HL
LD B,(HL)
INC HL
LD C,(HL)
PUSH HL
AND $0F

Point to the 'insert BASIC line' details.
Has the column with the cursor been found?
Jump if it has been found.

Increment the count of the number of editable characters in the BASIC line up to the
cursor.

Point to the 'insert BASIC line' details.
Fetch flags.

Fetch the column number of the character being examined.

Fetch the row number of the character being examined.

Extract the status code.

Register A:
Bit 0: 1=First row of the BASIC line off top of screen.
Bit 1: 1=On first row of the BASIC line.
Bit 2: 1=Using lower screen and only first row of the BASIC line visible.
Bit 3: 1=At end of last row of the BASIC line (always 0 at this point).

LD HL,L2D85
CALL L3FCE

Jump table to select appropriate handling routine.
Call handler routine.

Register L:
$01 - A character was returned from the Above-Screen Line Edit Buffer row.
$02 - A character was returned from the Screen Line Edit Buffer row.
$04 - A character was returned from the Below-Screen Line Edit Buffer row.
$08 - At the end of the last row of the BASIC line.
Register A holds the character fetched or 'Enter' if at the end of the BASIC line.

LD E,L
POP HL
JR Z,L2D79
LD A,$0D

E=Return status.

Jump if no match found.
A='Enter' character.

169

L2D79:

LD (HL),C
DEC HL
LD (HL),B
DEC HL
PUSH AF
LD A,(HL)
AND $F0
OR E
LD (HL),A
POP AF
RET

SPECTRUM 128 ROM 0 DISASSEMBLY

Save the next character position row to examine.

Save the next character position column to examine.

Save the character.
Fetch the current status flags.
Keep the upper nibble.
Update the location flags that indicate where to obtain the next character from.
Store the status flags.
Retrieve the character.

Fetch Next Character Jump Table
Jump to one of three handling routines when fetching the next character from the BASIC line to insert.

L2D85:

DEFB $03
DEFB $02
DEFW L2DAC
DEFB $04
DEFW L2DE9
DEFB $01
DEFW L2D8F

Number of table entries.
On first row of the BASIC line.

Using lower screen and only first row of the BASIC line visible.

First row of the BASIC line off top of screen.

Fetch Character from the Current Row of the BASIC Line in the Screen Line Edit Buffer
Fetch character from the current row of the BASIC line in the Screen Line Edit Buffer, skipping nulls until the end of the BASIC line is found.
Entry:
Exit :

C=Row number.
L=$01 - A character was returned from the Above-Screen Line Edit Buffer row, with A holding the character.
$02 - A character was returned from the Screen Line Edit Buffer row, with A holding the character.
$04 - A character was returned from the Below-Screen Line Edit Buffer row, with A holding the character.
$08 - At the end of the last row of the BASIC line, with A holding an 'Enter' character.
Zero flag set to indicate a match from the handler table was found.

Table entry point - First row of BASIC line off top of screen

L2D8F:
L2D92:

CALL L32B7
CALL L2E0E
JR NC,L2D9E
CP $00
JR Z,L2D92
LD L,$01

RET

Find row address in Above-Screen Line Edit Buffer, return in DE.
Fetch character from Above-Screen Line Edit Buffer row.
Jump if end of row reached.
Is it a null character, i.e. not editable?
Jump back if so until character found or end of row reached.
Signal a character was returned from the Above-Screen Line Edit Buffer row, with A
holding the character.
Return with zero flag reset to indicate match found.

End of row reached - no more editable characters in Above-Screen Line Edit Buffer row

L2D9E:

INC C
LD B,$00
LD HL,($F9DB)

LD A,C
CP (HL)
JR C,L2D8F

Next row.
Column 0.
[BUG - This should be LD HL,$F9DB. The bug manifests itself when Enter is
pressed on an edited BASIC line that goes off the top of the screen and causes
corruption to that line. The bug at $30D0 (ROM 0) that sets default data for the
Below-Screen Line Edit Buffer implies that originally there was the intention to
have a pointer into the next location to use within that buffer, and so it seems to
reasonable to assume the same arrangement would have been intended for the
Above-Screen Line Edit Buffer. If that were the case then the instruction here was
intended to fetch the next address within the Above-Screen Line Edit Buffer. Credit:
Ian Collier (+3), Andrew Owen (128)]
Fetch the row number.
Exceeded last row of Above-Screen Line Edit Buffer?
Jump back if not exceeded last row the Above-Screen Line Edit Buffer.

All characters from rows off top of screen fetched so continue onto the rows on screen [Note it is not possible to have more than 20 rows off the top
of the screen]

170

SPECTRUM 128 ROM 0 DISASSEMBLY

LD B,$00
LD C,$00

Column 0.
Row 0. This is the first visible row of the BASIC line on screen.

Table entry point - On visible row of BASIC line
C=Row number of the first visible row of the BASIC line in the Screen Line Edit Buffer B=Starting column number of the first visible row of the BASIC
line in the Screen Line Edit Buffer

L2DAC:

PUSH HL
LD HL,$F6EE
LD A,(HL)
CP C
JR NZ,L2DBE

Save address of the table entry.
Point to the cursor position details.
Fetch the row number of the cursor.
Is cursor on the first visible row of the BASIC line?
Jump if not.

Cursor on first visible row of the BASIC line in the Screen Line Edit Buffer.

L2DBE:
L2DBF:

INC HL
LD A,(HL)
CP B
JR NZ,L2DBE
LD HL,$EC00
RES 7,(HL)
POP HL
CALL L30B4
CALL L2E0E

JR NC,L2DCE
CP $00
JR Z,L2DAC

Fetch the column number of the cursor.
Reached the column with the cursor in the first visible row of the BASIC line?
Jump if not.
BASIC line insertion flags.
Indicate that the column with the cursor has been found.
Retrieve address of the table entry.
DE=Start address in Screen Line Edit Buffer of the row specified in C.
Fetch character from Screen Line Edit Buffer row at column held in B, then
increment B.
Jump if end of row reached.
Is the character a null, i.e. not editable?
Jump back if null to keep fetching characters until a character is found or the end of
the row is reached.

A character in the current row of the BASIC line was found

LD L,$02

RET

L=Signal a character was returned from the Screen Line Edit Buffer row, with A
holding the character.
Return with zero flag reset to indicate match found.

End of row reached - no editable characters in the Screen Line Edit Buffer row

L2DCE:

LD HL,$0020
ADD HL,DE
BIT 3,(HL)
JR Z,L2DDB

Point to the flag byte for the row.
Is it the last row of the BASIC line?
Jump if not.

On last row of the BASIC line and finished fetching characters from the line

LD L,$08
LD A,$0D
RET

L=Signal at the end of the last row of the BASIC line.
A='Enter' character.
Return with zero flag reset to indicate match found.

Not on the last row of the BASIC line so move to the beginning of the next, if it is on screen.

L2DDB:

LD HL,$F6F3
INC C
LD A,(HL)
CP C
LD B,$00
JR NC,L2DBF

Point to the 'top row scroll threshold' value.
Next row of the BASIC line in the Screen Line Edit Buffer.
Fetch the number of the last row in the Screen Line Edit Buffer.
Exceeded the upper scroll threshold?
Column 0.
Jump back if not to retrieve the character from the next row.

The upper row threshold for triggering scrolling the screen has been reached so proceed to scroll up one line

LD B,$00
LD C,$01

Column 0. [Redundant byte]
Row 1. (Row 0 holds a copy of the last row visible on screen)

Table entry point - Using lower screen and only top row of a multi-row BASIC line is visible

171

SPECTRUM 128 ROM 0 DISASSEMBLY

L2DE9:
L2DEC:

CALL L31C3
CALL L2E0E

JR NC,L2DF8
CP $00
JR Z,L2DEC

LD L,$04

RET

Find the address of the row specified by C in Below-Screen Line Edit Buffer, into DE.
Fetch character from Below-Screen Line Edit Buffer row, incrementing the column
number.
Jump if end of row reached.
Is the character a null, i.e. not editable?
Jump back if null to keep fetching characters until a character is found or the end of
the row is reached.
L=Signal a character was returned from the Below-Screen Line Edit Buffer row, with
A holding the character.
Return with zero flag reset to indicate match found.

End of row reached - no editable characters in the (below screen) Below-Screen Line Edit Buffer row

L2DF8:

LD HL,$0020
ADD HL,DE
BIT 3,(HL)
JR NZ,L2E09
INC C
LD B,$00
LD A,($F6F5)
CP C
JR NC,L2DE9

Point to the flag byte for the row.
Is it the last row of the BASIC line?
Jump if so.
Next row.
Column 0.
Fetch number of rows in the Below-Screen Line Edit Buffer.
Exceeded last line in Below-Screen Line Edit Buffer?
Jump back if not to retrieve the character from the next row.

All characters from rows off bottom of screen fetched so return an 'Enter' [Note it is not possible to have more than 20 rows off the bottom of the screen]

L2E09:

LD L,$08
LD A,$0D
RET

L=Signal at the end of the last row of the BASIC line.
A='Enter' character.
Return with zero flag reset to indicate match found.

Fetch Character from Edit Buffer Row

Column 31.
Is column

Return if B is greater than 31.

HL=Column number.

Fetch the character at the specified column.
Increment the column number.
Signal character fetched.

L2E0E:

LD A,$1F
CP B
CCF
RET NC
LD L,B
LD H,$00
ADD HL,DE
LD A,(HL)
INC B
SCF
RET

Upper Screen Rows Table
Copied to $EC15-$EC16.

L2E1B:

DEFB $01
DEFB $14

Number of bytes to copy.
Number of editing rows (20 for upper screen).

Lower Screen Rows Table
Copied to $EC15-$EC16.

L2E1D:

DEFB $01
DEFB $01

Number of bytes to copy.
Number of editing rows (1 for lower screen).

172

Reset to Main Screen

L2E1F:

LD HL,$5C3C
RES 0,(HL)
LD HL,L2E1B
LD DE,$EC15
JP L3FBA

Reset to Lower Screen

L2E2D:

LD HL,$5C3C
SET 0,(HL)
LD BC,$0000
CALL L372B
LD HL,L2E1D
LD DE,$EC15
JP L3FBA

SPECTRUM 128 ROM 0 DISASSEMBLY

TVFLAG.
Signal using main screen.
Upper screen lines table.
Destination workspace variable. The number of editing rows on screen.
Copy one byte from $2E1C (ROM 0) to $EC15

TVFLAG.
Signal using lower screen.

Perform 'PRINT AT 0,0;'.
Lower screen lines table.
Destination workspace variable. The number of editing rows on screen.
Copy one byte from $2E1E (ROM 0) to $EC15

Find Edit Buffer Editable Position from Previous Column to the Right
This routine finds the first editable character position in the specified edit buffer row from the previous column to the right.
It  first  checks  the  current  column,  then  the  previous  column  and  then  the  columns  to  the  right.  The  column  containing  the  first  non-null  character
encountered is returned.
Entry:

B =Column number to start searching from.
DE=Start of row in edit buffer.
Carry flag set if an editable character was found.
HL=Address of closest editable position.
B =Number of closest editable column.

Exit :

L2E41:

L2E56:

L2E5B:

LD H,$00
LD L,B
ADD HL,DE
LD A,(HL)
CP $00
SCF
RET NZ
LD A,B
OR A
JR Z,L2E5B
PUSH HL
DEC HL
LD A,(HL)
CP $00
SCF
POP HL
RET NZ
LD A,(HL)
CP $00
SCF
RET NZ
INC HL
INC B
LD A,B
CP $1F
JR C,L2E56
RET

[Could have saved 1 byte by calling routine at $2E7B (ROM 0)]
HL=Column number.
HL=Address in edit buffer of the specified column.
Fetch the contents.
Is it a null character, i.e. end-of-line or past the end-of-line?

Return if this character is part of the edited line.

Jump ahead if the first column.
Otherwise check the
preceding byte
and if it is non-zero
then return with
HL pointing to the
first zero byte.

Get the current character.
Is it a null (i.e. end-of-line)?
Signal position is editable.
Return if this character is part of the edited line.
Advance to the next position.
Increment the column number.

Reached the end of the row?
Jump back if more columns to check.
Return with carry flag reset if specified column position does not exist.

173

SPECTRUM 128 ROM 0 DISASSEMBLY

Find Edit Buffer Editable Position to the Left
This routine finds the first editable character position in the specified edit buffer row from the current column to the left.
It first checks the current column and returns this if it contains an editable character. Otherwise it searches the columns to the left and if an editable
character is found then it returns the column to the right of it.
Entry:

B =Column number to start searching from.
DE=Start of row in edit buffer.
Carry flag set if an editable character was found.
HL=Address of closest editable position.
B =Number of the column after the editable position.

Exit :

L2E63:

L2E6C:

L2E78:

LD H,$00
LD L,B
ADD HL,DE
LD A,(HL)
CP $00
SCF
RET NZ
LD A,(HL)
CP $00
JR NZ,L2E78
LD A,B
OR A
RET Z
DEC HL
DEC B
JR L2E6C
INC B
SCF
RET

[Could have saved 1 byte by calling routine at $2E7B (ROM 0)]
HL=Column number.
HL=Address in edit buffer of the specified column.
Fetch the contents.
Is it a null character, i.e. end-of-line or past the end-of-line?
Signal position is editable.
Return if an editable character was found.
Get the current character.
Is it a null, i.e. non-editable?
Jump if not.
At column 0?

Return if so.
Next column position to test.
Decrement column index number.
Repeat test on previous column.
Advance to the column after the editable position.
Signal position is editable.

Fetch Edit Buffer Row Character
DE=Add of edit buffer row.
Entry:
B =Column number.
A =Character at specified column.

Exit :

[Not used by the ROM]

L2E7B:

LD H,$00
LD L,B
ADD HL,DE
LD A,(HL)
RET

HL=Column number.
HL=Address in edit buffer of the specified column.
Get the current character.

Insert Character into Screen Line Edit Buffer
Called when a non-action key is pressed. It inserts a character into the Screen Line Edit Buffer if there is room.
Entry:

A=Character code.
B=Cursor column position.
C=Cursor row position.

L2E81:

LD HL,$EC0D
OR A
BIT 0,(HL)
RET NZ
PUSH BC
PUSH AF
CALL L30B4
POP AF

Editor flags.
Clear carry flag. [Redundant since carry flag return state never checked]
Is the Screen Line Edit Buffer is full?
Return if it is.
Save cursor position.
Save key code. [Redundant since $30B4 (ROM 0) preserves AF]
DE=Start address in Screen Line Edit Buffer of the row specified in C.
Get key code. [Redundant since $30B4 (ROM 0) preserves AF]

174

SPECTRUM 128 ROM 0 DISASSEMBLY

Insert the character into the current row. If a spill from this row occurs then insert that character into the start of the following row and shift all existing
characters right by one. Repeat this process until all rows have been shifted.

L2E8E:

CALL L16AC

PUSH AF
EX DE,HL
CALL L3604
EX DE,HL
POP AF
CCF

JR Z,L2ECC

Insert character into edit buffer row at current cursor position, shifting the row right.
Returns carry flag reset. Zero flag will be set if byte shift out of last column position
was $00.
Save key code and flags.
HL=Address of edit buffer row. DE=Address of flags.
Print a row of the edit buffer to the screen.
DE=Address of edit buffer row. HL=Address of flags.
Get key code and flags.
Sets the carry flag since it was reset via the call to $16AC (ROM 0). [Redundant
since never tested]
Jump ahead to make a return if there was no spill out from column 31, with the carry
flag set.

There was a spill out from the current row, and so this character will need to be inserted as the first character of the following row.
If this is the last row of the BASIC line then a new row will need to be inserted.

PUSH AF
LD B,$00
INC C
LD A,($EC15)
CP C
JR C,L2EC8

Save key code.
First column in the next row.
Next row.
The number of editing rows on screen.
Has the bottom of the Screen Line Edit Buffer been reached?
Jump ahead if so.

The editing screen is not full

LD A,(HL)
LD E,A
AND $D7

CP (HL)
LD (HL),A
LD A,E
SET 1,(HL)
PUSH AF
CALL L30B4
POP AF
JR Z,L2EC2

Fetch contents of flag byte for the row (byte after the 32 columns).
E=Old flags.
Mask off 'last row of BASIC line' flag. [Other bits not used, could have used AND
$F7]
Has the status changed?
Store the new flags, marking it as not the last BASIC row.
A=Original flags byte for the row.
Signal that the row spans onto another row.
Save the flags.
DE=Start address in Screen Line Edit Buffer of the following row, as specified in C.
Fetch the flags.
Jump if the character was not inserted into the last row of the BASIC line.

The character was inserted into the last row of the BASIC line causing a spill of an existing character into a new row, and therefore a new 'last' row
needs to be inserted.

RES 0,A
CALL L2ED3
JR NC,L2ECC
CALL L35F4

POP AF
JR L2E8E

Signal not the first row of the BASIC line.
Insert a blank line into the Screen Edit Buffer.
Jump if the buffer is full to exit.
Indent the row by setting the appropriate number of null characters in the current
Screen Line Edit Buffer row.
Get key code.
Jump back to insert the character in the newly inserted row. [Could have saved 2
bytes by using JR $2EC5 (ROM 0)]

The character was not inserted into the last row of the BASIC line, so find the first editable position on the following row, i.e.
skip over any indentation.

L2EC2:

CALL L2E41

POP AF
JR L2E8E

Find editable position on this row from the previous column to the right, returning
column number in B.
Get key code.
Jump back to insert the character into the first editable position of next the row.

The Screen Edit Line Buffer is full and the character insertion requires shifting of all rows that are off screen in the Below-Screen Line Edit Buffer.

L2EC8:

POP AF

Get key code.

175

SPECTRUM 128 ROM 0 DISASSEMBLY

CALL L316E

Insert the character at the start of the Below-Screen Line Edit Buffer, shifting all
existing characters to the right.

All paths join here

L2ECC:

POP BC
RET

Retrieve cursor position.

Insert Blank Row into Screen Edit Buffer, Shifting Rows Down
This routine inserts a blank row at the specified row, shifting affected rows down.
Entry:
Exit :

C=Row number to insert the row at.
Carry flag set to indicate edit buffer rows were shifted.

L2ECE:

CALL L30B4
LD A,$09

DE=Start address in Screen Line Edit Buffer of the row specified in C.
Signal 'first row' and 'last row', indicating a new blank row.

DE=Address of row within Screen Line Edit Buffer.
C=Row number to insert the row at.
A=Screen Line Edit Buffer row flags value.

L2ED3:

PUSH BC
PUSH DE
LD B,C
LD HL,L2EEF
LD C,A
PUSH BC
CALL L1675

POP BC
LD A,C
JR NC,L2EEC

Rows were shifted down

LD C,B
CALL L30B4
LD HL,$0020
ADD HL,DE
LD (HL),A
SCF
POP DE
POP BC
RET

L2EEC:

Empty Edit Buffer Row Data

L2EEF:

DEFB $00
DEFB $00
DEFB $00
DEFB $00
DEFB $00
DEFB $00
DEFB $00
DEFB $00
DEFB $00
DEFB $00
DEFB $00
DEFB $00
DEFB $00
DEFB $00
DEFB $00

Save registers.

B=Row number.
The empty row data.
C=Flags for the row.

Shift all Screen Line Edit Buffer rows down and insert a new blank row, updating the
display file if required.

A=Flags for the row.
Jump if no edit buffer rows were shifted.

B=Row number, where the new blank row now is.
DE=Start address in Screen Line Edit Buffer of the row specified in C.
Point to the flag byte for the row.

Store the flag byte value for the row.
Signal edit buffer rows were shifted.
Restore registers.

32 null column markers, i.e. none of the columns are editable.

176

DEFB $00
DEFB $00
DEFB $00
DEFB $00
DEFB $00
DEFB $00
DEFB $00
DEFB $00
DEFB $00
DEFB $00
DEFB $00
DEFB $00
DEFB $00
DEFB $00
DEFB $00
DEFB $00
DEFB $00
DEFB $09

DEFW $0000

SPECTRUM 128 ROM 0 DISASSEMBLY

Flags: Bit 0: 1=The first row of the BASIC line. Bit 1: 0=Does not span onto another
row. Bit 2: 0=Not used (always 0). Bit 3: 1=The last row of the BASIC line. Bit 4:
0=No associated line number. Bit 5: 0=Not used (always 0). Bit 6: 0=Not used
(always 0). Bit 7: 0=Not used (always 0).
There is no BASIC line number associated with this edit row.

Delete a Character from a BASIC Line in the Screen Line Edit Buffer
Delete a character at the specified position, shifting subsequent characters left as applicable.
Entry:

B=Column number.
C=Row number.

L2F12:

PUSH BC
CALL L30B4
PUSH BC

Save initial cursor row and column numbers.
DE=Start address in Screen Line Edit Buffer of the row specified in C.
Stack initial cursor row and column numbers again.

Enter a loop to find the last row of the BASIC line or the end of the visible screen, whichever comes first

L2F17:

LD HL,$0020
ADD HL,DE
BIT 1,(HL)
LD A,$00

JR Z,L2F31

The row spans onto another

INC C
LD HL,$0023
ADD HL,DE
EX DE,HL

LD A,($EC15)
CP C
JR NC,L2F17

Point to the flag byte for this row.
Does the row span onto another row?
A null character will be inserted. [Could have saved 1 byte by using XOR A and
placing it above the BIT 1,(HL) instruction]
Jump ahead if the row does not span onto another row, i.e. the last row.

C=Advance to the next row.

DE points to the first character of the next row. HL points to the first character of the
current row.
A=Number of editing lines.
Has the end of the screen been reached?
Jump back if within screen range to find the last row of the BASIC line.

The end of the screen has been reached without the end of the BASIC line having been reached

DEC C
CALL L31C9

Point to last row on screen.
Shift all characters of the BASIC Line held within the Below-Screen Line Edit Buffer.

A loop is entered to shift all characters to the left, beginning with the last row of the BASIC line in the Screen Line Edit Buffer and until the row that
matches the current cursor position is reached.

L2F31:
L2F32:

POP HL
PUSH HL

Fetch the initial cursor row and column numbers.
Stack initial cursor row and column numbers.

177

SPECTRUM 128 ROM 0 DISASSEMBLY

CALL L30B4
POP HL
LD B,A
LD A,C
CP L
LD A,B
PUSH AF
JR NZ,L2F41

DE=Start address in Screen Line Edit Buffer of the last row, as specified in C.
HL=Initial cursor row and column numbers.
B=Character to insert.
A=Row number to delete from.
Deleting from the same row as the cursor is on within the BASIC line?
A=Character to insert.
Save the flags status.
Jump if not deleting from the row containing the cursor.

Deleting from the row matching the cursor position within the BASIC line, therefore only shift those bytes after the cursor position

LD B,H
JR L2F4A

B=Initial column number.
Jump ahead to continue, with zero flag set to indicate deleting from the row contain
the cursor.

Deleting on row after that matching the cursor position, therefore shift all editable characters within the row

L2F41:

PUSH AF
PUSH HL
LD B,$00
CALL L2E41

POP HL
POP AF

Save the character to insert.
Save initial cursor row and column numbers.

Find first editable position on this row searching to the right, returning column
number in B.
HL=Initial cursor row and column numbers.
A=Character to insert, and zero flag reset to indicate not deleting from the row
contain the cursor.

DE=Start address of Screen Line Edit Buffer row.
A=Character to shift into right of row.
B=The column to start shifting at.
C=Row number to start shifting from.
Zero flag is set if deleting from the row matching the cursor position.

L2F4A:

L2F54:

PUSH HL
LD HL,$F6F4
SET 0,(HL)
JR Z,L2F54
RES 0,(HL)
CALL L16C1

PUSH AF

PUSH BC
PUSH DE
LD HL,$F6F4
BIT 0,(HL)
JR NZ,L2F6F

HL=Initial cursor row and column numbers.
Deleting flags.
Signal deleting on the row matching the cursor position.
Jump if deleting from the row matching the cursor position.
Signal not deleting on the row matching the cursor position.
Insert the character into the end of the edit buffer row, shifting all columns left until
the cursor position is reached.
A=Character shifted out, and therefore to be potentially shifted into the end of the
previous row.
B=New column number. C=Row number.
DE=Start address of row to delete from.
Deleting flags.
Deleting from the row matching the cursor position?
Jump ahead if so.

Deleting from a row after the cursor position

LD B,$00
CALL L2BD4
JR C,L2F6F

Column 0.
Is there an editable character on the row?
Jump if there is.

Shifting the characters on this row has resulted in a blank row, so shift all rows below screen up to remove this blank row

CALL L2F80
POP DE
POP BC
JR L2F74

Shift up all BASIC line rows below to close the gap.
DE=Start address of row to delete from.
B=New column number. C=Row number.
Jump ahead.

There are characters remaining on the row following the shift so display this to the screen and then continue to shift the remaining rows

L2F6F:

POP HL
POP BC

HL=Start address of the row.
B=New column number. C=Row number.

178

L2F74:

CALL L3604
POP AF
DEC C
LD B,A
POP HL
POP AF

LD A,B
JP NZ,L2F32

SPECTRUM 128 ROM 0 DISASSEMBLY

Print the row of the edit buffer to the screen, if required.
A=Character to insert.
Previous row.
B=Character to insert.
HL=Initial cursor row and column numbers.
Retrieve the flags status (zero flag set if deleting from the row matching the cursor
position).
A=Character to insert.
Jump back if not deleting from the row matching the cursor position, i.e. all rows
after the cursor have not yet been shifted.

[BUG - The 'line altered' flag is not cleared when an 'edited' null line is entered. To reproduce the bug, insert a couple of BASIC lines, type a character,
delete it, and then cursor up or down onto a program line. The line is considered to have been changed and so is processed as if it consists of characters.
Further, when cursor down is pressed to move to a BASIC line below, that line is deemed to have changed and hence moving off from it causing that line
to be re-inserted into the BASIC program. Credit: Ian Collier (+3), Paul Farrow (128)] [The fix for the bug is to check whether all characters have been
deleted from the line and if so to reset the 'line altered' flag. This would require the following code to be inserted at this point. Credit: Paul Farrow. PUSH
DE LD HL,$0020 ADD HL,DE ; Point to the flag byte for this row. POP DE BIT 0,(HL) ; First row of BASIC line in addition to the last? JR Z,SKIP_CLEAR ;
Jump ahead if not. LD B,$00 CALL $2E41 (ROM 0) ; Is this a blank row? i.e. Find editable position on this row to the right, returning column number in B.
JR C,SKIP_CLEAR ; Jump if a character exists on the line. LD HL,$EC0D RES 3,(HL) ; Signal that the current line has not been altered. SKIP_CLEAR:
XOR A ; Set the preferred column to 0.]

SCF
POP BC
RET

[Redundant since never subsequently checked]
Retrieve initial cursor row and column numbers.

Shift Rows Up to Close Blank Row in Screen Line Edit Buffer
The cursor is on a blank row but has been moved off of it. Therefore shift all BASIC lines below it up so as to remove the blank row.
Entry:

DE=Address of the row in the Screen Line Edit Buffer containing the cursor.
C =Row number in the Screen Line Edit Buffer containing the cursor.
Carry flag set if rows were shifted up, i.e. a row below existed.

L2F80:

LD HL,$0020
ADD HL,DE
LD A,(HL)
BIT 0,(HL)
JR NZ,L2FB2

Point to the flag byte for the row.

Is the cursor on a blank row (which is flagged as the first row of a BASIC line)?
Jump ahead if it is. [Could have improved speed by jumping to $2FB6 (ROM 0)
since DE already holds the start address of the row]

Cursor not on a blank row but is on its own row at the end of a multi-row BASIC line

PUSH AF
PUSH BC
LD A,C
OR A
JR NZ,L2FA4

Save the cursor row flag byte.
Save the cursor row number in C.
Is the cursor on row 0?

Jump ahead if it is not, i.e. there is at least one row above.

Cursor on row 0, hence a BASIC line must be off the top of the screen [???? Can this ever be the case?]

PUSH BC
LD HL,($FC9A)
CALL L334A
LD ($FC9A),HL
LD A,($F9DB)

LD C,A
DEC C
CALL L32B7
POP BC
JR L2FA8

Save the cursor row number.
Line number at top of screen.
Find closest line number (or $0000 if no line).
Line number at top of screen.
Fetch the number of rows of the BASIC line that are in the Above-Screen Line Edit
Buffer,
i.e. that are off the top of the screen.
Decrement the row count, i.e. one less row off the top of the screen.
DE=Address of row in Above-Screen Line Edit Buffer.
Retrieve the cursor row number.
Jump ahead.

There is a row above so set this as the last row of the BASIC line

179

SPECTRUM 128 ROM 0 DISASSEMBLY

L2FA4:

L2FA8:

DEC C
CALL L30B4
POP BC
POP AF
LD HL,$0020
ADD HL,DE
RES 1,(HL)
OR (HL)
LD (HL),A

Previous row, i.e. the last row of the BASIC line that contains editable characters.
DE=Start address in Screen Line Edit Buffer of the previous row.
Retrieve the cursor row number.
Retrieve the cursor row flag byte, which indicates last row of BASIC line.
Point to the flag byte for the previous row.

Signal that the previous row does not span onto another row.
Keep the previous row's first BASIC row flag.
Update the flag byte for the previous row.

Shift up all rows below the old cursor position within the Screen Line Edit Buffer and including the Below-Screen Line Edit Buffer, and update the display
file if required

L2FB2:

LD B,C
CALL L30B4
CALL L30DF

JP L1648

B=Row number in the Screen Line Edit Buffer.
DE=Start address in Screen Line Edit Buffer of the row specified in C.
Shift up rows of the BASIC line in the Below-Screen Line Edit Buffer, or insert the
next line BASIC line if buffer empty.
Shift Screen Line Edit Buffer rows up from row specified by B and update the display
file if required. [Could have saved 3 bytes by replacing the instructions CALL $30DF
(ROM 0) / JP $1648 (ROM 0) with JP $1645 (ROM 0)]

DELETE-WORD-LEFT Key Handler Routine
This routine deletes to the start of the current word that the cursor is on, or if it is on the first character of a word then it deletes to the start of the previous
word. Since the function works by deleting one character at a time, display file updates are disabled whilst the function is executing to prevent screen flicker.
If there is no word to delete then an error beep is requested.
Symbol:

DEL

Exit: Carry flag reset to indicate to produce an error beep and set not to produce an error beep.

L2FBC:

CALL L3084

L2FBF:

PUSH HL
CALL L3095
JR Z,L2FF7
CALL L2B5B
POP HL
JR NC,L2FF8

A previous character exists and is editable

Remove cursor attribute, disable display file updates and get current cursor position.
Exits with HL pointing to the editing area information.
Save address of the editing area information.
Does a previous character exist in the current Screen Line Edit Buffer row?
Jump if at the start of the BASIC line to print all rows.
Is previous column position editable? (Returns carry flag set if editable)
Retrieve address of the editing area information.
Jump if not editable to print all rows.

CALL L2A1A
PUSH AF
PUSH HL
CALL L2F12
POP HL
POP AF
CP $20
JR Z,L2FBF

Get character from current cursor position.
Save current character.
Save address of the editing area information.
Delete character to the right, shifting subsequent rows as required.
Retrieve address of the editing area information.
Retrieve current character.
Is it a space?
Jump back if so to find the end of the last word.

The end of the word to delete has been found, so enter a loop to search for the start of the word

L2FD9:

PUSH HL
CALL L3095
JR Z,L2FF7
CALL L2B5B
POP HL
JR NC,L2FF8
CALL L2A1A
CP $20
JR Z,L2FF3

Character is not a space

Save address of the editing area information.
Does a previous character exist in the current Screen Line Edit Buffer row?
Jump if at the start of a BASIC line to print all rows.
Is previous column position editable? (Returns carry flag set if editable)
Retrieve address of the editing area information.
Jump if not editable to print all rows.
Get character from current cursor position
Is it a space?
Jump if so.

180

SPECTRUM 128 ROM 0 DISASSEMBLY

PUSH HL
CALL L2F12
POP HL
JR L2FD9

Save address of the editing area information.
Delete character to the right, shifting subsequent rows as required.
Retrieve address of the editing area information.
Jump back to delete next character until start of the word found.

A space prior to a word has been found

L2FF3:

PUSH HL
CALL L2B78

L2FF7:

POP HL

Print all rows to the screen

L2FF8:

LD A,B
PUSH AF
PUSH HL
LD HL,$EEF5
RES 2,(HL)
LD A,($EC15)

PUSH BC
LD B,$00
LD C,A
CP A
CALL L1605
POP BC
LD HL,$EC0D
SET 3,(HL)
POP HL

Save address of the editing area information.
Find next Screen Line Edit Buffer editable position to right, moving to next row if
necessary.
Retrieve address of the editing area information.

Fetch the new end column number.
Save the flags status.
Save address of the editing area information.

Re-enable display file updates.
The number of editing rows on screen. [This will end up being used as the alternate
cursor column]
Save the row and new column numbers.
B=Print from row 0.
C=Number of editing rows on screen.
Set the zero flag to signal not to change cursor position settings.
Print all Screen Line Edit Buffer rows to the display file.
Retrieve the row and new column numbers.
Editor flags.
Indicate current line has been altered.
Retrieve address of the editing area information.

[BUG - The preferred cursor column field gets corrupted with the number of editing rows on screen. Credit: Ian Collier (+3), Andrew Owen (128)] [The
bug can be fixed by pre-loading the A register with the current preferred column number. Credit: Paul Farrow.

LD A,($F6F0)

Fetch the preferred column position.]

CALL L29F8
POP AF
RET

Store editing position and print cursor.
Retrieve the flags status.

DELETE-WORD-RIGHT Key Handler Routine
This routine deletes to the start of the next word. Since the function works by deleting one character at a time, display file updates are disabled whilst
the function is executing to prevent screen flicker.
If there is no word to delete then an error beep is requested.
Symbol:

DEL

Exit: Carry flag set to indicate not to produce an error beep.

L3017:

CALL L3084

L301A:

PUSH HL
CALL L2A1A
POP HL
CP $00
SCF
JR Z,L2FF8
PUSH AF
PUSH HL
CALL L2F12
POP HL
POP AF
CP $20

Remove cursor attribute, disable display file updates and get current cursor position.
Exits with HL pointing to the editing area information.
Save address of the editing area information.
Get character from current cursor position.
Retrieve address of the editing area information.
Is it a null character, i.e. end of BASIC line?
Signal do not produce an error beep.
Jump if end of the BASIC line to print all rows.
Save the character.
Save address of the editing area information.
Delete character to the right, shifting subsequent rows as required.
Retrieve address of the editing area information.
Retrieve the character.
Was the character a space?

181

L302F:

JR NZ,L301A
CALL L2A1A
CP $20
SCF
JR NZ,L2FF8
PUSH HL
CALL L2F12
POP HL
JR L302F

SPECTRUM 128 ROM 0 DISASSEMBLY

Jump back if not to delete the next character until the end of the word is found.
Get character from current cursor position.
Is it a space?
Signal do not produce an error beep.
Jump if not to print all rows.
Save address of the editing area information.
Delete character to the right, shifting subsequent rows as required.
Retrieve address of the editing area information.
Jump back to delete all subsequent spaces until the start of the next word or the end
of the line is found.

DELETE-TO-START-OF-LINE Key Handler Routine
Delete to the start of the current BASIC line. Since the function works by deleting one character at a time, display file updates are disabled whilst the
function is executing to prevent screen flicker.
An error beep is not produced if there is no characters in the current BASIC line.
Symbol:

DEL

Exit: Carry flag set to indicate not to produce an error beep.

L303E:

CALL L3084

L3041:

PUSH HL
CALL L30B4
LD HL,$0020
ADD HL,DE
BIT 0,(HL)
JR NZ,L3059

Not in the first row of a BASIC line

Remove cursor attribute, disable display file updates and get current cursor position.
Exits with HL pointing to the editing area information.
Save address of the editing area information.
DE=Start address in Screen Line Edit Buffer of the row specified in C.

Point to the flag byte for the row.
Is it the first row of the BASIC line?
Jump if so.

CALL L2B5B
JR NC,L306D
CALL L2F12
POP HL
JR L3041
PUSH HL

Is previous column position editable? (Returns carry flag set if editable)
Jump if not editable since nothing to delete.
Delete character to the right, shifting subsequent rows as required.
Retrieve address of the editing area information.
Jump back to delete next character until first row of the BASIC line is found.
[Redundant byte]

In the first row of the BASIC line

L3059:

L306D:
L306E:

LD A,B
CP $00
JR Z,L306D
DEC B
CALL L2A1A
INC B
CP $00
JR Z,L306D
DEC B
CALL L2F12
JR L3059
POP HL
SCF
JP L2FF8

Fetch the new end column number.
Is it at the start of the row?
Jump if so since nothing to delete.
Point to previous column.
Get character from current cursor position.
Point back to the new end column.
Is it a null character, i.e. not editable?
Jump if so since nothing to delete.
Point to previous column.
Delete character to the right, shifting subsequent rows as required.
Jump back to delete the next character until the start of the BASIC line is found.
Retrieve address of the editing area information.
Signal not to produce error beep.
Jump back to print all rows.

DELETE-TO-END-OF-LINE Key Handler Routine
Delete to the end of the current BASIC line. Since the function works by deleting one character at a time, display file updates are disabled whilst the
function is executing to prevent screen flicker.
An error beep is not produced if there is no characters in the current BASIC line.
Symbol:

182

SPECTRUM 128 ROM 0 DISASSEMBLY

DEL

Exit: Carry flag set to indicate not to produce an error beep.

L3072:

CALL L3084

L3075:

CALL L2A1A
CP $00
SCF
JR Z,L306E
PUSH HL
CALL L2F12
POP HL
JR L3075

Remove cursor attribute, disable display file updates and get current cursor position.
Exits with HL pointing to the editing area information.
Get character from current cursor position.
Is it a null character, i.e. at end of BASIC line?
Signal not to produce an error beep.
Jump if end of BASIC line to print all rows.
Save address of the editing area information.
Delete character to the right, shifting subsequent rows as required.
Retrieve address of the editing area information.
Jump back to delete the next character until the end of the BASIC line is found.

Remove Cursor Attribute and Disable Updating Display File
This routine is called by the DELETE key handler routines. Aside from removing the cursor from the display, it prevents display file updates occurring
whilst the delete functions are executing.
Exit: HL=Address of the editing area information.
A=Cursor column number preferred.
B=Cursor column number.
C=Cursor row number.

L3084:

LD HL,$EC0D
RES 0,(HL)
CALL L29EC
LD HL,$EEF5
SET 2,(HL)

LD HL,$F6F1
RET

Editor flags.
Signal that the Screen Line Edit Buffer is not full.
Remove cursor, restoring old attribute.

Indicate not to print edit buffer rows, therefore preventing intermediate screen
updates.
Point to the editing area information.

Previous Character Exists in Screen Line Edit Buffer?
This routine tests the whether a previous character exists in the current BASIC line within the Screen Line Edit Buffer.
Entry:

C=Row number.
B=Column number.
Zero flag set if at start of the BASIC line (first column or leading null).

Exit :

L3095:

CALL L30B4
LD HL,$0020
ADD HL,DE
BIT 0,(HL)
JR Z,L30AE

DE=Start address in Screen Line Edit Buffer of the row specified in C.

HL=Address of the flag byte for this row.
Is this the first row of a BASIC line?
Jump if not.

On first row of a BASIC line

LD A,B
CP $00
JR Z,L30B2
DEC B
CALL L2A1A
INC B
CP $00
JR Z,L30B2
LD A,$01
OR A
RET
XOR A
RET

L30AE:

L30B2:

Fetch the column number.
At the start of the row?
Jump ahead if so.
Move to the previous column.
Get current character from Screen Line Edit Buffer.
Move back to the original column.
Does the position contain a null?
Jump if not.

Reset the zero flag.

Set the zero flag.

183

SPECTRUM 128 ROM 0 DISASSEMBLY

Find Row Address in Screen Line Edit Buffer
Find address in Screen Line Edit Buffer of specified row.
This routine calculates DE = $EC16 + $0023*C.
Entry:
Exit :

C=Row number.
DE=Address of edit row.

L30B4:
L30B7:

L30BC:

L30C3:

LD HL,$EC16
PUSH AF
LD A,C
LD DE,$0023
OR A
JR Z,L30C3
ADD HL,DE
DEC A
JR L30BC
EX DE,HL
POP AF
RET

Point to the Screen Line Edit Buffer.
Save A.
A=Edit row number.
35 bytes per row.
Row requested found?
Jump to exit if so.
Advance to next row.

Jump to test if requested row found.
Transfer address to DE.
Restore A.

Find Position within Screen Line Edit Buffer
Find the address of a specified row and column in the Screen Line Edit Buffer.
The routine calculates DE = $EC16 + $0023*C + B.
Entry:

B=Column number.
C=Row number.
HL=Address of specified position.

Exit :

[Not used by the ROM]

L30C6:

PUSH DE
CALL L30B4
LD H,$00
LD L,B
ADD HL,DE
POP DE
RET

DE=Start address in Screen Line Edit Buffer of the row specified in C.

DE = $EC16 + $0023*C + B.

Below-Screen Line Edit Buffer Settings
This table holds the default values for the Below-Screen Line Edit Buffer settings starting at $F6F5. It should only contain a table of 3 bytes to tie up
with the space allocated within the Editor workspace variables at $F6F5. As a result, the last 2 bytes will get copied into the Below-Screen Line Edit
Buffer itself. It appears that the word at $F6F6 is supposed to be a pointer to the next available or accessed location within the buffer but this facility
is never used. Therefore the table need only be 1 byte long, in which case it would be more efficient for the routine at $30D6 (ROM 0) to simply set
the byte at $F6F5 directly.

L30D0:

DEFB $05
DEFB $00
DEFW $0000

DEFW $F6F8

Number of bytes in table.
$F6F5 = Number of rows held in the Below-Screen Line Edit Buffer.
$F6F6/7. [BUG - These two bytes should not be here and the table should only
contain 3 bytes. Credit: Paul Farrow]
$F6F8/9 = Points to next location within the Below-Screen Line Edit Buffer.

Set Below-Screen Line Edit Buffer Settings
Sets the default values for the Below-Screen Line Edit Buffer settings.
Copy 5 bytes from $30D1-$30D5 (ROM 0) to $F6F5-$F6F9.

L30D6:

LD HL,L30D0
LD DE,$F6F5
JP L3FBA

Default Below-Screen Line Edit Buffer settings.
Destination address.
Copy bytes.

184

SPECTRUM 128 ROM 0 DISASSEMBLY

Shift Up Rows in Below-Screen Line Edit Buffer
Shifts up all rows in the Below-Screen Line Edit Buffer, or if empty then copies a BASIC line from the program area into the Below-Screen Line Edit Buffer.
Exit: HL=Address of the Below-Screen Line Edit Buffer.

L30DF:

PUSH BC
PUSH DE
LD HL,$F6F5
PUSH HL
LD A,(HL)
OR A
JR NZ,L3101

Save BC.
Save DE.
Point to the Below-Screen Line Edit Buffer details.
Save it.
A=Number of rows held in Below-Screen Line Edit Buffer.
Are there any rows below screen?
Jump if so.

There are no rows in the Below-Screen Line Edit Buffer

L30F8:

PUSH HL
CALL L335F

LD HL,($F9D7)
CALL L3352

JR NC,L30F8
LD ($F9D7),HL
LD B,H
LD C,L
POP HL
CALL L32D6

DEC A

JR L3116

Save the address of the Below-Screen Line Edit Buffer details.
Copy 'Insert Keyword Representation Into Keyword Construction Buffer' routine into
RAM.
HL=Line number of the BASIC line in the program area being edited.
Create line number representation in the Keyword Construction Buffer of the next
BASIC line.
Jump if next line does not exist, with HL holding $0000.
Store the new line number.

BC=Line number of the next BASIC line, or last BASIC line in the program.
Retrieve the address of the Below-Screen Line Edit Buffer details.
Copy the BASIC line into the Below-Screen Line Edit Buffer, or empty the first buffer
row if the BASIC line does not exist.
Decrement the count of the number of rows held in the Below-Screen Line Edit
Buffer, i.e. assume the rows have been shifted.
Jump forward.

There are rows in the Below-Screen Line Edit Buffer so shift all rows up

L3101:

L3116:

LD HL,$EC0D
RES 0,(HL)
LD HL,$F6F8
LD D,H
LD E,L
LD BC,$0023
ADD HL,BC
LD BC,$02BC
LDIR
DEC A

SCF
POP DE
LD (DE),A
LD HL,$F6F8
POP DE
POP BC
RET

Editor flags.
Signal that the Screen Line Edit Buffer is not full.
Below-Screen Line Edit Buffer, the temporary copy of line being edited.

Move all rows in the Below-Screen Line Edit Buffer up by one row.

20 rows.

Decrement the count of the number of rows held in the Below-Screen Line Edit
Buffer.
[Redundant since never subsequently checked]
DE=Points to number of rows held in the Below-Screen Line Edit Buffer.
Update the number of rows held in the Below-Screen Line Edit Buffer
HL=Address of first row in the Below-Screen Line Edit Buffer.
Restore DE.
Restore BC.

Shift Down Rows in Below-Screen Line Edit Buffer
Shifts down all rows in the Below-Screen Line Edit Buffer, or the last Screen Line Edit Buffer row contains a complete BASIC line then it empties the
Below-Screen Line Edit Buffer.
Entry:
Exit :

DE=Start address in Screen Line Edit Buffer of the last editing row.
Carry flag reset to indicate Below-Screen Line Edit Buffer full.
A =Number of rows held in the Below-Screen Line Edit Buffer.
HL=Address of first row in the Below-Screen Line Edit Buffer.

L311E:

PUSH BC

Save BC.

185

PUSH DE
LD HL,$0020
ADD HL,DE
LD A,(HL)
CPL
AND $11
JR NZ,L313F

SPECTRUM 128 ROM 0 DISASSEMBLY

DE=Start address in Screen Line Edit Buffer of the last editing row.

Point to the flag byte for the edit buffer row.
Fetch flag byte.
Invert bits.

Jump if not the first row of the BASIC line or no associated line number stored.

First row of the BASIC line or an associated line number stored

PUSH HL
PUSH DE
INC HL
LD D,(HL)
INC HL
LD E,(HL)
PUSH DE
CALL L335F

POP HL
CALL L334A
JR NC,L313D
LD ($F9D7),HL
POP DE
POP HL
BIT 0,(HL)
LD HL,$F6F5
PUSH HL
JR Z,L314C

L313D:

L313F:

HL=Points at flag byte of the last Screen Line Edit Buffer row.
DE=Address of the last Screen Line Edit Buffer row.

DE=Corresponding BASIC line number.
Save it.
Copy 'Insert Keyword Representation Into Keyword Construction Buffer' routine to
RAM.
HL=Corresponding line number for last editing row.
Find the closest line number.
Jump if line does not exist.
Store as the line number of the BASIC line being edited.
DE=Address of the last Screen Line Edit Buffer row.
HL=Points at flag byte of edit buffer row.
Is it the first row of the BASIC line?
Point to the Below-Screen Line Edit Buffer details.
Save the address of the Below-Screen Line Edit Buffer details.
Jump if not the first row of the BASIC line.

The first row of the BASIC line, hence after the shift there will not be a row straggling off the bottom of the screen

LD A,$00

SCF
JR L3116

Signal no rows held in the Below-Screen Line Edit Buffer. [Could have saved 1 byte
by using XOR A]
Signal Below-Screen Line Edit Buffer is not full.
Store new flag.

Not the first row the BASIC line

L314C:

LD A,(HL)
CP $14
JR Z,L3116

Fetch the number of rows held in the Below-Screen Line Edit Buffer.
Has the bottom of the buffer been reached?
Jump if so, with the carry flag reset to indicate the buffer is full.

The Below-Screen Line Edit Buffer is not full so copy the last Screen Line Edit Buffer row into the top 'visible' Below-Screen Line Edit Buffer row

LD BC,$0023
LD HL,$F6F8
EX DE,HL

LDIR

Length of an edit buffer row.
Address of the first row in the Below-Screen Line Edit Buffer.
HL=Address of the last row in the Screen Line Edit Buffer, DE=Address of the first
row in the Below-Screen Line Edit Buffer.
Copy the last Screen Line Edit Buffer row into the first Below-Screen Line Edit Buffer
row, i.e. the 'visible' edit buffer row.

Copy all Below-Screen Line Edit Buffer rows down

LD HL,$F9D6
LD D,H
LD E,L
LD BC,$0023
OR A
SBC HL,BC
LD BC,$02BC
LDDR
INC A
SCF
JR L3116

DE=End of the last row in the Below-Screen Line Edit Buffer.
Length of an edit buffer row.

HL=End of penultimate row in the Below-Screen Line Edit Buffer.
Length of the Below-Screen Line Edit Buffer minus one row.
Shift all the rows down by one.
Increment the number of rows held in the Below-Screen Line Edit Buffer.
Signal Below-Screen Line Edit Buffer is not full.
Jump to store the number of rows held in the Below-Screen Line Edit Buffer.

186

SPECTRUM 128 ROM 0 DISASSEMBLY

Insert Character into Below-Screen Line Edit Buffer
Called when a non-action key is pressed and rows of the BASIC line spans into the Below-Screen Line Edit Buffer and therefore require shifting.
Entry:

HL=Current row's flag byte.
A=Character code to insert at the start of the first row of the Below-Screen Line Edit Buffer.

L316E:

PUSH BC
PUSH DE
PUSH AF
LD B,$00
LD C,$01
PUSH HL
CALL L31C3
POP HL
BIT 3,(HL)
RES 3,(HL)
JR NZ,L31A0

Save registers.

Save the character to insert.
Column 0.
Row 1.
Save address of the row's flag byte.
Find row address specified by C in the Below-Screen Line Edit Buffer, into DE.
Retrieve address of the row's flag byte.
Is this the end row of the BASIC line?
Indicate that it is no longer the end row of the BASIC line.
Jump if it was the end row of the BASIC line.

The row in the Below-Screen Line Edit Buffer is not the last row of the BASIC line.
Insert the character into the current row. If a spill from this row occurs then insert that character into the start of the following row and shift all existing
characters right by one. Repeat this process until all rows have been shifted.

L3180:

CALL L2E41

L3184:

POP AF
CALL L16AC

JR Z,L31BA

Find first editable position on this row from the previous column to the right, returning
column number in B.
A=Character to insert.
Insert character into the start of the edit buffer row, shifting the row right. Returns
carry flag reset.
Jump if the byte shifted out of the last column position was $00, hence no more
shifting required.

The end character of the row has spilled out so it must be inserted as the first editable character of the following row

PUSH AF
LD B,$00
INC C
LD A,C
CP $15
JR C,L31A0

Stack the character which needs to be inserted into the next row.
B=First column in the next row.
C=Next row.

Has the bottom row of the Below-Screen Line Edit Buffer been reached, i.e. row 21?
Jump ahead if not.

The bottom row of the Below-Screen Line Edit Buffer has been reached

DEC HL
LD A,(HL)
INC HL
CP $00
JR Z,L31A0

Point to last character of the current row.
Get the character.
Point back to the flag byte of this row.
Is the character a null character? [Could have saved 1 byte by using AND A]
Jump ahead if it is.

The Below-Screen Line Edit Buffer is completely full

PUSH HL
LD HL,$EC0D
SET 0,(HL)

POP HL

Save address of the flag byte.
Editor flags.
Signal that the Screen Line Edit Buffer (including Below-Screen Line Edit Buffer) is
full.
HL=Address of the flag byte.

Check whether there is another row to shift

L31A0:

BIT 1,(HL)
SET 1,(HL)
RES 3,(HL)
CALL L31C3
JR NZ,L3180

Does the row span onto another row?
Signal that the row spans onto another row.
Signal not the last row of the BASIC line.
Find the address of the row specified by C in Below-Screen Line Edit Buffer, into DE.
Jump back if spans onto another row to shift it also.

187

All existing rows have now been shifted but a new row needs to be inserted

SPECTRUM 128 ROM 0 DISASSEMBLY

PUSH BC
PUSH DE
CALL L35E6
LD (HL),$08
POP DE
POP BC
CALL L35F4
POP AF
JR L3184

B=Column number. C=Row number.
DE=Start address of the row in the edit buffer.
Null all column positions in the edit buffer row.
Set the flag byte for the row to indicate it is the last row of the BASIC line.
DE=Start address of the row in the edit buffer.
B=Column number. C=Row number.
Indent the row by setting the appropriate number of null characters.
Get character to insert.
Jump back to insert it.

The shifting of all rows has completed

L31BA:

LD A,C
LD ($F6F5),A
SET 3,(HL)
POP DE
POP BC
RET

Get the row number.
Store as the number of rows held within the Below-Screen Line Edit Buffer.
Mark this row as the last row of the BASIC line.
Restore registers.

Find Row Address in Below-Screen Line Edit Buffer
Find address in the Below-Screen Line Edit Buffer of specified row.
This routine calculates DE = $F6F8 + $0023*C.
Entry:
Exit :

C=Row number.
Address of edit row in DE.

L31C3:

LD HL,$F6F8
JP L30B7

Address of the Below-Screen Line Edit Buffer.
Jump to find the row address and return.

Delete a Character from a BASIC Line in the Below-Screen Line Edit Buffer
Delete a character at the specified position, shifting subsequent characters left as applicable.
Exit: A=Character shifted out of the top row of the Below-Screen Line Edit Buffer.

L31C9:

PUSH BC
PUSH DE
LD HL,$EC0D
RES 0,(HL)

LD A,($F6F5)
LD C,A
OR A
LD A,$00
JR Z,L321B

Save registers.

Editor flags.
Signal that the Screen Line Edit Buffer (including Below-Screen Line Edit Buffer) is
not full.
A=Number of rows held in the Below-Screen Line Edit Buffer.
C=Number of rows held in the Below-Screen Line Edit Buffer.
Are there any rows in the Below-Screen Line Edit Buffer?
A null character.
Jump if there are no rows. [Redundant check since this routine should never be
called if there are no rows in this buffer]

There is at least one row in the Below-Screen Line Edit Buffer

L31D9:

CALL L31C3
PUSH AF
LD B,$00
CALL L2E41
JR NC,L31F2

The row is not blank

Find the address of the last used row within Below-Screen Line Edit Buffer, into DE.
Save the character to insert.
Start searching from column 0.
Find editable position on this row to the right, returning column number in B.
Jump if no editable position found, i.e. a blank row.

POP AF

A=Character to insert.

DE=Address within a row of edit buffer.
A=Character to shift into right of row.

188

B=The column to start shifting at.

SPECTRUM 128 ROM 0 DISASSEMBLY

CALL L16C1

PUSH AF
PUSH BC
LD B,$00
CALL L2E41

POP BC
JR C,L3216

Insert the character into the end of the edit buffer row, shifting all columns left until
the cursor position is reached.
A=Character shifted out, zero flag set if the shifted out character was a null ($00).
Save the row number.
Start searching from column 0.
Is this now a blank row? i.e. Find editable position on this row to the right, returning
column number in B.
C=Row number.
Jump if editable position found.

The row is already blank or the result of the shift has caused it to become blank.
HL points to the last blank character in the row.

L31F2:

INC HL
LD A,(HL)
PUSH AF
PUSH BC
LD A,C
CP $01
JR NZ,L3204

Point to the flag byte for the blank row.
Fetch the flag byte.
Save the flag byte for the blank row.
Save the row number.
Fetch the row number of this blank row.
Is this the first row in the Below-Screen Line Edit Buffer?
Jump if not.

The first row in the Below-Screen Line Edit Buffer is empty and hence the BASIC line now fits completely on screen, i.e. within the Screen Line Edit Buffer

LD A,($EC15)
LD C,A
CALL L30B4
JR L3208

The number of editing rows on screen.
C=Bottom row number in the Screen Line Edit Buffer.
DE=Start address in Screen Line Edit Buffer of the bottom row, as specified in C.
Jump ahead to continue.

The blank row is not the first row in the Below-Screen Line Edit Buffer, and hence there are further rows above to be shifted

L3204:

L3208:

DEC C
CALL L31C3
POP BC
POP AF
LD HL,$0020
ADD HL,DE
RES 1,(HL)
OR (HL)
LD (HL),A
LD HL,$F6F5
DEC (HL)

Continue with the next row

L3216:

POP AF

DEC C
JR NZ,L31D9

Previous row within the Below-Screen Line Edit Buffer.
Find the address of the row specified by C in Below-Screen Line Edit Buffer, into DE.
Retrieve the row number.
A=Flag byte value for the blank row.

Point to the flag byte for the row above.
Signal that the row above does not span onto another row.
Or in the flag bits from the blank row, essentially this will retain the 'last row' bit.
Update the flag byte for the row above.
Point to the number of rows held in the Below-Screen Line Edit Buffer.
Decrement the row count.

Fetch the character shifted out from the current row, ready for insertion into the row
above.
Previous row.
Jump back if the character shifted out was not null, i.e. more rows above to shift.

All rows in the Below-Screen Line Edit Buffer have been shifted

L321B:

SCF
POP DE
POP BC
RET

[Redundant since never subsequently checked]
Restore registers.

Above-Screen Line Edit Buffer Settings
This table holds the default values for the Below-Screen Line Edit Buffer settings starting at $F9DB.

189

SPECTRUM 128 ROM 0 DISASSEMBLY

It appears that the word at $F9DC is supposed to be a pointer to the next available or accessed location within the buffer but this facility is never used.
Therefore the table need only be 1 byte long, in which case it would be more efficient for the routine at $3222 (ROM 0) to simply set the byte at $F9DB
directly.

L321E:

DEFB $03
DEFB $00
DEFW $F9DE

Number of bytes in table.
$F9DB = Number of rows held in the Above-Screen Line Edit Buffer.
$F9DC/D = Points to next available location within the Above-Screen Line Edit
Buffer.

Set Above-Screen Line Edit Buffer Settings
Sets the default values for the Above-Screen Line Edit Buffer settings.
Copy 3 bytes from $321F-$3221 (ROM 0) to $F9DB-$F9DD.

L3222:

LD HL,L321E
LD DE,$F9DB
JP L3FBA

Default Above-Screen Line Edit Buffer settings.
Destination address.
Copy bytes.

Shift Rows Down in the Above-Screen Line Edit Buffer
If Above-Screen Line Edit Buffer contains row then decrement the count, i.e. less rows off screen.
If the Above-Screen Line Edit Buffer is empty then load in the new BASIC line at the top of the screen.
Exit : HL=Address of next row to use within the Above-Screen Line Edit Buffer.
Carry flag reset if Above-Screen Line Edit Buffer is empty, i.e. no edit buffer rows were shifted.

L322B:

PUSH BC
PUSH DE
LD HL,$F9DB
PUSH HL
LD A,(HL)
OR A
JR NZ,L3253

Save registers.

Point to the Above-Screen Line Edit Buffer settings.
Save address of the Above-Screen Line Edit Buffer settings.
Fetch number of rows of the BASIC line that are off the top of the screen.
Are there any rows off the top of the screen?
Jump if there are.

There are no rows of the BASIC line off the top of the screen so use the top line that is visible on screen

L3244:

PUSH HL
CALL L335F

LD HL,($FC9A)
CALL L334A
JR NC,L3244
LD ($FC9A),HL
LD B,H
LD C,L
POP HL
INC HL
INC HL
INC HL
JR NC,L325D

Save address of the Above-Screen Line Edit Buffer settings.
Copy 'Insert Keyword Representation Into Keyword Construction Buffer' routine to
RAM.
HL=New line number at top of screen.
Verify the line number exists, or fetch the next line number if not.
Jump if the line does not exist.
Store the line number found as the one at the top of screen.

BC=New line number at top of screen.
HL=Address of the Above-Screen Line Edit Buffer settings.

Point to the first row of the Above-Screen Line Edit Buffer.
Jump if the line did not exist.

The line specified as the one at the top of the screen does exists [BUG - HL points to the start of the first row of the Above-Screen Line Edit Buffer but
it should point to the settings fields 3 bytes earlier since the call to $32D6 (ROM 0) will advance HL by 3 bytes. The bug manifests itself when modifying
a BASIC line that spans off the top of the screen. It causes corruption to the line number, causing a new BASIC line to be inserted rather than updating
the line being edited. When editing lines with a high line number, the corrupted line number can end up larger 9999 and hence the line is deemed invalid
when Enter is pressed to insert the line into the BASIC program. The effects of the bug are often masked by the bug at $2DA1 (ROM 0) which performs
LD HL,($F9DB) instead of LD HL,$F9DB and thereby fails to detect when the end of the Above-Screen Line Edit Buffer has been reached. The bug can
be fixed by inserted three DEC HL instructions before the call to $32D6 (ROM 0). Credit: Paul Farrow]

CALL L32D6
DEC A

EX DE,HL
JR L325D

Copy the new BASIC line into the Above-Screen Line Edit Buffer.
Decrement the count of the number of rows held in the Above-Screen Line Edit
Buffer.
HL=Start of the next row in the Above-Screen Line Edit Buffer.
Jump ahead to continue.

190

SPECTRUM 128 ROM 0 DISASSEMBLY

There are rows of the BASIC line off the top of the screen

L3253:

LD HL,($F9DC)
LD BC,$0023
SBC HL,BC
SCF
DEC A

HL=Address of the next location within the Above-Screen Line Edit Buffer to use.

Point to the previous row location within the Above-Screen Line Edit Buffer.
Signal to update the number of rows held in the Above-Screen Line Edit Buffer.
Decrement the count of the number of rows held in the Above-Screen Line Edit
Buffer.

A=New number of rows held in the Above-Screen Line Edit Buffer.
HL=Address of a next row to use within the Above-Screen Line Edit Buffer.
Carry flag reset if no need to update the count of the number of rows in the Above-Screen Line Edit Buffer.

L325D:

L3262:

EX DE,HL
POP HL
JR NC,L3262

LD (HL),A
INC HL
LD (HL),E
INC HL
LD (HL),D
EX DE,HL
POP DE
POP BC
RET

DE=Address of next row to use within the Above-Screen Line Edit Buffer.
HL=Address of the Above-Screen Line Edit Buffer settings.
Jump if no need to update the count of the number of rows in the Above-Screen Line
Edit Buffer.
Store the number of rows held in the Above-Screen Line Edit Buffer.

Store the address of the next row to use within the Above-Screen Line Edit Buffer.
HL=Address of next row to use within the Above-Screen Line Edit Buffer.
Restore registers.

Shift Row Up into the Above-Screen Line Edit Buffer if Required
This routine is used to shift up a Screen Line Edit Buffer or a Below-Screen Line Edit Buffer row into the Above-Screen Line Edit Buffer.
If shifting the top row of the Screen Line Edit Buffer would result in a straggle into the Above-Screen Line Edit Buffer then the top row is shifted into
the next available location within the Above-Screen Line Edit Buffer. If the shift would place the start of a BASIC line on the top row then the Above-
Screen Line Edit Buffer is set as empty.
The routine is also called when relisting the BASIC program. The first BASIC line may straggle above the screen and so it is necessary to load the BASIC
line into the Above-Screen Line Edit Buffer. This is achieved by using the Below-Screen Line Edit Buffer as a temporary line workspace. This routine is
called to shift each row into the Above-Screen Line Edit Buffer as appropriate.
Entry:
Exit :

DE=Start address of the first row in the Screen Line Edit Buffer, or start address of a Below-Screen Line Edit Buffer row.
HL=Address of next row to use within the Below-Screen or Screen Line Edit Buffer.
Carry flag set if the Line Edit Buffer if not full.

L326A:

PUSH BC
PUSH DE
LD HL,$0020
ADD HL,DE
LD A,(HL)
CPL
AND $11
JR NZ,L3282

Save registers.

Point to the flag byte for this row within the Below-Screen or Screen Line Edit Buffer.
Fetch the flag byte.

Jump if not the first row of the BASIC line or no associated line number stored.

First row of the BASIC line and associated line number stored

PUSH DE
PUSH HL
INC HL
LD D,(HL)
INC HL
LD E,(HL)
LD ($FC9A),DE
POP HL

POP DE
BIT 3,(HL)
LD HL,$F9DB
PUSH HL

L3282:

DE=Start address of the row.
HL=Address of the flag byte for the row in the Line Edit Buffer.

DE=Line number of the corresponding BASIC line.
Store this as the line number that is at the top of the screen.
HL=Address of the flag byte for the row in the Below-Screen or Screen Line Edit
Buffer.
DE=Start address of the row.
Is this the last row of the BASIC line?
Point to the Above-Screen Line Edit Buffer settings.
Stack the address of the Above-Screen Line Edit Buffer settings.

191

SPECTRUM 128 ROM 0 DISASSEMBLY

JR Z,L32A0

Jump if not the last row of the BASIC line.

The last row of the BASIC line

PUSH HL
CALL L335F

LD HL,($FC9A)
CALL L3352

LD ($FC9A),HL
POP HL
INC HL
INC HL
INC HL
LD A,$00

SCF
JR L325D

Stack the address of the Above-Screen Line Edit Buffer settings.
Copy 'Insert Keyword Representation Into Keyword Construction Buffer' routine to
RAM.
Line number at top of screen.
Create line number representation in the Keyword Construction Buffer of the next
BASIC line.
Update the line number at top of screen.
HL=Address of the Above-Screen Line Edit Buffer settings.

Point to the start of the Above-Screen Line Edit Buffer.
No rows held in the Above-Screen Line Edit Buffer. [Could have saved 1 byte by
using XOR A]
Signal to update the number of rows count.
Jump back to store the new Above-Screen Line Edit Buffer settings.

Not the last row of the BASIC line

L32A0:

LD A,(HL)
CP $14
JR Z,L32B3

Fetch the number of rows held in the Above-Screen or Screen Line Edit Buffer.
Are there 20 rows, i.e. the buffer is full?
Jump if the buffer is full, with the carry flag reset.

Shift the top row of the Screen Line Edit Buffer into the Above-Screen Line Edit Buffer

INC A
LD HL,($F9DC)
LD BC,$0023
EX DE,HL

LDIR
EX DE,HL
SCF
JR L325D

Increment the count of the number of rows in the Above-Screen Line Edit Buffer.
Fetch the address of the next row to use within the Above-Screen Line Edit Buffer.
The length of one row in the edit buffer, including the 3 data bytes.
DE=Address of next location within the Above-Screen Line Edit Buffer, HL=Address
of the row in the Below-Screen or Screen Line Edit Buffer to store.
Copy the row of the BASIC line into the Above-Screen Line Edit Buffer.
HL=Address of next row to use within the Above-Screen Line Edit Buffer.
Signal to update the count of the number of rows.
Jump back to store the new Above-Screen Line Edit Buffer settings.

Above-Screen Line Edit Buffer is full

L32B3:

POP HL
POP DE
POP BC
RET

HL=Address of the Above-Screen Line Edit Buffer settings.
Restore registers.

Find Row Address in Above-Screen Line Edit Buffer
Find the address in the Above-Screen Line Edit Buffer of the specified row.
This routine calculates DE = $F9DE + $0023*C.
Entry:
Exit :

C=Row number.
DE=Address of edit row.

L32B7:

LD HL,$F9DE
JP L30B7

Point to the start of the Above-Screen Line Edit Buffer.
Find the row address.

BASIC Line Character Action Handler Jump Table

L32BD:

DEFB $08
DEFB $0D
DEFW L35CC
DEFB $01

Number of table entries.
Code: Enter.
Address of the 'Enter' action handler routine.
Code: NULL.

192

DEFW L35DA
DEFB $12
DEFW L335A
DEFB $13
DEFW L335A
DEFB $14
DEFW L335A
DEFB $15
DEFW L335A
DEFB $10
DEFW L335A
DEFB $11
DEFW L335A

SPECTRUM 128 ROM 0 DISASSEMBLY

Null remaining columns of an edit buffer row.
Code: FLASH.
Fetch next de-tokenized character from the BASIC line within the program area.
Code: BRIGHT.
Fetch next de-tokenized character from the BASIC line within the program area.
Code: INVERSE.
Fetch next de-tokenized character from the BASIC line within the program area.
Code: OVER.
Fetch next de-tokenized character from the BASIC line within the program area.
Code: INK.
Fetch next de-tokenized character from the BASIC line within the program area.
Code: PAPER.
Fetch next de-tokenized character from the BASIC line within the program area.

Copy a BASIC Line into the Above-Screen or Below-Screen Line Edit Buffer
Copy a BASIC line into the Above-Screen or Below-Screen Line Edit Buffer, handling indentation.
Entry:

HL=Address of the previous row's flag byte in Above-Screen or Below-Screen Line Edit Buffer.
BC=Line number corresponding to the row being edited.
A=Number of rows in the Above-Screen Line Edit Buffer.
HL=Address of the first row of the BASIC line being edited in the Above-Screen Line Edit Buffer.
DE=Address of the last row of the BASIC line being edited in the Above-Screen Line Edit Buffer.

Exit :

L32D6:

LD D,H

LD E,L

INC DE
INC DE
INC DE
PUSH DE

LD HL,$0020
ADD HL,DE
LD (HL),$01
INC HL
LD (HL),B
INC HL
LD (HL),C
LD C,$01
LD B,$00

HL=Address of the previous row's flag byte in the Above-Screen/Below-Screen Line
Edit Buffer.
DE=Address of the previous row's flag byte in the Above-Screen/Below-Screen Line
Edit Buffer.

Advance to the start of the row in the edit buffer.
DE=Address of the start of the BASIC line in the Above-Screen/Below-Screen Line
Edit Buffer.

Point to the flag byte for the row.
Signal the first row of the BASIC line.

Store the corresponding BASIC line number.
Row 1.
Column 0.

Enter a loop to process each character from the current BASIC line

L32EA:

PUSH BC
PUSH DE
LD A,($EC0E)
CP $04
CALL NZ,L3517

POP DE
POP BC
JR C,L3307

Save the column and row numbers.
Save the Above-Screen/Below-Screen Line Edit Buffer address.
Fetch mode.
Calculator mode?
If not then fetch the next de-tokenized character from the BASIC line within the
program area.
Retrieve the Above-Screen/Below-Screen Line Edit Buffer address.
Retrieve the column and row numbers.
Jump if Editor mode and a character was available (if calculator mode then carry flag
was reset by test above).

Calculator mode, or Editor mode and a character was not available

LD A,C
CP $01
LD A,$0D
JR NZ,L3307

A=Row number.
Is it row 1?
A='Enter' character.
Jump if not.

Row 1

193

SPECTRUM 128 ROM 0 DISASSEMBLY

LD A,B
OR A
LD A,$01
JR Z,L3307
LD A,$0D
LD HL,L32BD
CALL L3FCE
JR C,L332C
JR Z,L32EA

L3307:

A=Column number.
Is it column 0?
A='Null' character, the code used to indicate to null edit positions.
Jump if so.
A='Enter' character.
The action handler table.
Call the action handler routine to process the character.
Jump if no more characters are available.
Jump back if an action handler was found so as to process the next character.

A character was available but there was no action handler routine to process it

PUSH AF
LD A,$1F
CP B
JR NC,L3326

A=Character.

Exceeded column 31?
Jump ahead if not.

Exceeded last column

LD A,$12

CALL L3331
JR C,L3323

New flag byte value indicating the row spans onto another row and there is an
associated line number.
Mark this row as spanning onto the next and clear the following row's flags.
Jump ahead if not at bottom of the line edit buffer.

At the bottom of the edit buffer so process the line as if an 'Enter' character had been encountered

POP AF
LD A,$0D
JR L3307

Discard the stacked item.
A='Enter' character.
Jump back to process the 'Enter' code.

The edit buffer has room for another character

L3323:

CALL L35F4

L3326:

POP AF
CALL L35C5
JR L32EA

No more characters are available

L332C:

POP HL
LD A,C
RET Z

SCF
RET

Indent the row by setting the appropriate number of null characters in the current
Above-Screen Line Edit Buffer row.
A=Character.
Store the character in the current row/column in the Above-Screen Line Edit Buffer.
Jump back to handle the next character.

HL=Address of the BASIC line being edited in the Above-Screen Line Edit Buffer.
A=Number of rows in the Above-Screen Line Edit Buffer.
[Redundant since carry flag is always set by here, and zero flag never subsequently
checked]
[Redundant since never subsequently checked]

Set 'Continuation' Row in Line Edit Buffer
This routine is used when the insertion of a BASIC line needs to span onto a another row.
It marks the current row as 'not the last row of the BASIC line' and clears the following row's flags
Entry:

DE=Address of start of line edit buffer row.
B=Column number (will be $20).
C=Row number.
A=New flag byte value (will be $12).
Carry flag reset if bottom of line edit buffer reached.
HL=Address of the flag byte for the new row.

Exit :

L3331:

PUSH AF
CALL L35E6
POP AF
XOR (HL)
LD (HL),A

Save the new flag byte value.
HL=Address of flag byte for the row.
Retrieve the new flag byte value.
Toggle to set 'associated line number' and 'row spans onto another row' flags.
Store the new flag byte value.

194

LD A,C
CP $14
RET NC
INC C
LD HL,$0023
ADD HL,DE
EX DE,HL
LD HL,$0020
ADD HL,DE
LD (HL),$00
SCF
RET

SPECTRUM 128 ROM 0 DISASSEMBLY

A=Row number.
At bottom of line edit buffer?
Return if so.
Advance the row number.

Point to the start of the next row.

Point to the flag byte for the next row.
Clear the flags to indicate no BASIC line on this row.
Signal still on a row within the edit buffer.

BASIC Line Handling Routines

Find Address of BASIC Line with Specified Line Number
This routine finds the address of the BASIC line in the program area with the specified line number, or the next line is the specified one does not exist.
Entry:
Exit :

HL=Line number.
Carry flag set if line exists.
DE=Points to the command of the BASIC line within the program area.
HL=Line number ($0000 for no line number).

L334A:

CALL L34B6

RET C
LD HL,$0000
RET

Find the address of the BASIC line in the program area with the specified line
number.
Return if the line exists.
No line number.

Create Next Line Number Representation in Keyword Construction Buffer
This routine is used to create a string representation of the line number for the next line after the specified line, and store it in the Keyword Construction
Buffer.
Entry:

HL=Line number.
A=Print leading space flag ($00=Print leading space).
Carry flag set to indicate specified line exists.
DE=Points to the command field of the BASIC line.
HL=Line number, or $0000 if line does not exist.

Exit :

L3352:

CALL L3430
RET C
LD HL,$0000
RET

Create next line number representation in the Keyword Construction Buffer.
Return if line exists.
Line not found.

Fetch Next De-tokenized Character from Selected BASIC Line in Program Area
Exit: Carry flag reset if a character was available.
A=Character fetched.

L335A:

CALL L3517
CCF
RET NC

Fetch the next de-tokenized character from the BASIC line within the program area.

Return if a character was available. [BUG - This should just be a RET. Its effect
is harmless since the routine below has previously been called and hence simply
overwrites the data already copied to RAM. Credit: Ian Collier (+3), Andrew Owen
(128)]

195

SPECTRUM 128 ROM 0 DISASSEMBLY

Copy 'Insert Keyword Representation into Keyword Construction Buffer' Routine into RAM
Copies Insert Keyword Representation Into Keyword Construction Buffer routine into physical RAM bank 7, and resets pointers to indicate that there is
no BASIC line currently being de-tokenized.

L335F:

LD HL,$0000
LD ($FC9F),HL
LD ($FCA1),HL
LD HL,L3374
LD DE,$FCAE

LD BC,$00BC
LDIR
RET

Signal no line number of command.
Signal no further character to fetch from the BASIC line within the program area.
Signal no further character to fetch from the Keyword Construction Buffer.
Source for Insert Keyword Representation Into Keyword Construction Buffer routine.
Destination for Insert Keyword Representation Into Keyword Construction Buffer
routine.

Copy the routine to RAM bank 7 at address $FCAE.

Insert Keyword Representation into Keyword Construction Buffer « RAM Routine »
This routine copies a keyword string from ROM 1 into the Keyword Construction Buffer, terminating it with an 'end of BASIC line' marker (code ' '+$80).
Only standard Spectrum keywords are handled by this routine (SPECTRUM and PLAY are processed elsewhere).
The routine is run from RAM bank 7 at $FCAE so that access to both ROMs is available.
Depending on the value of A (which should be the ASCII code less $A5, e.g. 'RND', the first (48K) keyword, has A=0), a different index into the token
table is taken. This is to allow speedier lookup since there are never more than 15 keywords to advance through.
Entry:

A=Keyword character code-$A5 (range $00-$5A).
DE=Insertion address within Keyword Construction Buffer.

Copied to physical RAM bank 7 at $FCAE-$FCFC by subroutine at $335F (ROM 0).

L3374:

DI
LD BC,$7FFD
LD D,$17
OUT (C),D
CP $50
JR NC,L33B1
CP $40
JR NC,L33AA
CP $30
JR NC,L33A3
CP $20
JR NC,L339C
CP $10
JR NC,L3395

Disable interrupts whilst paging.

Page in ROM 1, SCREEN 0, no locking, RAM bank 7.

Was the token $F5 or above?

Was the token $E5 or above?

Was the token $D5 or above?

Was the token $C5 or above?

Was the token $B5 or above?

Used for token range $A5-$B4 ($00 <= A <= $0F)

LD HL,TOKENS+$0001
JR L33B6

$0096. Token table entry "RND" in ROM 1.

Used for token range $B5-$C4 ($10 <= A <= $1F)

L3395:

SUB $10
LD HL,TOKENS+$003A
JR L33B6

Used for token range $C5-$D4 ($20 <= A <= $2F)

L339C:

SUB $20
LD HL,TOKENS+$006B
JR L33B6

Used for token range $D5-$E4 ($30 <= A <= $3F)

$00CF. Token table entry "ASN" in ROM 1.

$0100. Token table entry "OR" in ROM 1.

L33A3:

SUB $30
LD HL,TOKENS+$00A9

$013E. Token table entry "MERGE" in ROM 1.

196

JR L33B6

Used for token range $E5-$F4 ($40 <= A <= $4F)

L33AA:

SUB $40
LD HL,TOKENS+$00F6
JR L33B6

Used for token range $F5-$FF (A >= $50)

L33B1:

L33B6:

L33B8:
L33BA:

SUB $50
LD HL,TOKENS+$013F
LD B,A
OR A
JR Z,L33C3
LD A,(HL)
INC HL
AND $80
JR Z,L33BA
DEC B
JR L33B8

SPECTRUM 128 ROM 0 DISASSEMBLY

$018B. Token table entry "RESTORE" in ROM 1.

$01D4. Token table entry "PRINT" in ROM 1.
Take a copy of the index value.
If A=0 then already have the entry address.
If indexed item found then jump ahead to copy the characters of the token.
Fetch a character.
Point to next character.
Has end of token marker been found?
Loop back for next character if not.
Count down the index of the required token.
Jump back to test whether the required token has been reached.

Copy Keyword Characters « RAM Routine »
This routine copies a keyword string from ROM 1 into the Keyword Construction Buffer, terminating it with an 'end of BASIC line' marker (code ' '+$80).
A leading space will be inserted if required and a trailing space is always inserted.
The routine is run from physical RAM bank 7 so that access to both ROMs is available.
Entry:

HL=Address of keyword string in ROM 1.
DE=Insertion address within Keyword Construction Buffer.

Copied to physical RAM bank 7 at $FCFD-$FD2D by subroutine at $335F (ROM 0).

L33C3:

L33D9:

LD DE,$FCA3
LD ($FCA1),DE
LD A,($FC9E)
OR A
LD A,$00
LD ($FC9E),A
JR NZ,L33D9
LD A,$20
LD (DE),A
INC DE
LD A,(HL)
LD B,A
INC HL
LD (DE),A
INC DE
AND $80
JR Z,L33D9
LD A,B
AND $7F
DEC DE
LD (DE),A
INC DE
LD A,' '+$80
LD (DE),A
LD A,$07
LD BC,$7FFD
OUT (C),A
EI
RET

DE=Keyword Construction Buffer.
Store the start address of the constructed keyword.
Print a leading space?

Signal leading space not required.
Jump if leading space not required.
Print a leading space.
Insert a leading space.
Advance to next buffer position.
Fetch a character of the keyword.
Store it.
Advance to next keyword character.
Store the keyword character in the BASIC line buffer.
Advance to the next buffer position.
Test if the end of the keyword string.
Jump back if not to repeat for all characters of the keyword.
Get keyword character back.
Mask off bit 7 which indicates the end of string marker.
Point back at the last character of the keyword copied into the buffer
and store it.
Advance to the position in the buffer after the last character of the keyword.
$A0. Space + end marker.
Store an 'end of BASIC line so far' marker.

Page in ROM 0, SCREEN 0, no locking, RAM bank 7.
Re-enable interrupts.

197

SPECTRUM 128 ROM 0 DISASSEMBLY

Identify Token from Table
This routine identifies the string within the Keyword Conversion Buffer and returns the character code. The last character of the string to identify has
bit 7 set.
Only 48K mode tokens are identified.
Exit: Carry flag set if token identified.
A=Character code.
Copied to RAM at $FD2E-$FD69 by routine at $335F (ROM 0).

L33F4:

DI
LD BC,$7FFD
LD D,$17
OUT (C),D
LD HL,TOKENS+1
LD B,$A5

Disable interrupts whilst paging.

Select ROM 1, SCREEN 0, RAM bank 7.

$0096. Address of token table in ROM 1.
Character code of the first token - 'RND'.

Entry point here used to match 128K mode tokens and mis-spelled tokens

L3401:
L3404:

L340E:

LD DE,$FD74
LD A,(DE)
AND $7F
CP $61
LD A,(DE)
JR C,L340E
AND $DF
CP (HL)
JR NZ,L341A
INC HL
INC DE
AND $80
JR Z,L3404

A match was found

L341A:

SCF
JR L3426
INC B
JR Z,L3425

Keyword Conversion Buffer holds the text to match against.
Fetch a character from the buffer.
Mask off terminator bit.
Is it lowercase?
Fetch the character again from the buffer.
Jump if uppercase.
Make the character uppercase.
Does the character match the current item in the token table?
Jump if it does not.
Point to the next character in the buffer.
Point to the next character in the token table.
Has the terminator been reached?
Jump back if not to test the next character in the token.

Signal a match was found.
Jump ahead to continue.
The next character code to test against.
Jump if all character codes tested.

The token does not match so skip to the next entry in the token table

L341D:

LD A,(HL)
AND $80
INC HL
JR Z,L341D
JR L3401

Fetch the character from the token table.
Has the end terminator been found?
Point to the next character.
Jump back if no terminator found.
Jump back to test against the next token.

All character codes tested and no match found

L3425:

OR A

Clear the carry flag to indicate no match found.

The common exit point

L3426:

LD A,B
LD D,$07
LD BC,$7FFD
OUT (C),D
EI
RET

Fetch the character code of the matching token ($00 for no match).
Select ROM 0, SCREEN 0, RAM bank 7.

Re-enable interrupts.
« Last byte copied to RAM »

198

SPECTRUM 128 ROM 0 DISASSEMBLY

Create Next Line Number Representation in Keyword Construction Buffer
This routine is used to create a string representation of the line number for the next line after the specified line, and store it in the Keyword Construction
Buffer.
Entry:

Exit :

HL=Line number.
A=Print leading space flag ($00=Print leading space).
Carry flag set to indicate specified line available.
DE=Points to the command field of the BASIC line.
HL=Line number.

L3430:

CALL L34EA

OR A

LD ($FC9E),A
CALL L1F20
CALL L34F6
JR NC,L3491
JR NZ,L344D

The line number requested exists

LD A,B
OR C
JR Z,L344D

Fetch the next line

Clear BASIC line construction pointers (address of next character in the Keyword
Construction Buffer and the address of the next character in the BASIC line within
the program area being de-tokenized).
[BUG - Supposed to be XOR A to ensure that a leading space is shown before a
command keyword is printed. However, most of the time the A register will enter the
routine holding $00 and so the bug is probably harmless. Credit: Paul Farrow]
Print a leading space flag.
Use Normal RAM Configuration (physical RAM bank 0).
Find address of the specified BASIC line, into HL.
Jump if suitable line number not found, i.e. end of program reached.
Jump if line number did not match, i.e. is higher than the line requested.

BC=Line number.

Jump if the first program line requested (line number of 0).

CALL L34CF
CALL L34D9
JR NC,L3491

Move to the start of the next BASIC line.
Check whether at the end of the BASIC program.
Jump if at the end of the BASIC program.

Insert line number into the BASIC Line Construction Buffer

L344D:

LD D,(HL)
INC HL
LD E,(HL)
CALL L1F45
PUSH DE
PUSH HL
PUSH IX
LD IX,$FCA3
LD ($FCA1),IX
EX DE,HL
LD B,$00
LD DE,$FC18
CALL L3495
LD DE,$FF9C
CALL L3495
LD DE,$FFF6
CALL L3495
LD DE,$FFFF
CALL L3495

DEC IX
LD A,(IX+$00)
OR $80
LD (IX+$00),A
POP IX
POP HL

HL=Address of the BASIC line.

DE=Line number.
Use Workspace RAM configuration (physical RAM bank 7).
Save the line number.
Save the address of the BASIC line+1.
Save IX.
IX=Keyword Construction Buffer, the location where the line number will be created.
Store the start of the buffer as the next location to store a character in.
HL=Line number.
Signal no digit printed yet.
-1000.
Insert the thousand digit.
-100.
Insert the hundred digit.
-10.
Insert the ten digit.
-1.
Insert the units digits. [Note that this is not designed to handle line number 0, which
technically is not supported by Sinclair BASIC. The call would need to be preceded
by a LD B,$01 instruction to make this function support a line number of 0. Credit:
Ian Collier (+3), Andrew Owen (128)]
IX points to previous ASCII digit.

Set bit 7 to mark it as the end of the line number representation.
Restore registers.
HL=Address of the BASIC line+1.

199

POP DE
INC HL
INC HL
INC HL
LD ($FC9F),HL
EX DE,HL
SCF
RET

SPECTRUM 128 ROM 0 DISASSEMBLY

DE=Line number.
HL=Points to length field of the BASIC line.

HL=Points to the command field of the BASIC line.
Store it as the next character to fetch when parsing the BASIC line to de-tokenize it.
DE=Points to the command field of the BASIC line, HL=Line number.
Signal line exists.

End of program reached, no line number available

L3491:

CALL L1F45
RET

Use Workspace RAM configuration (physical RAM bank 7).
Return with carry flag reset to signal line does not exist.

Insert ASCII Line Number Digit
Insert text representation of a line number digit in a buffer.
Insert a $00 character for every leading zero.
Entry:

DE=Subtraction amount (-1000, -100, -10, -1).
HL=Line number.
IX=Address of the buffer to write the ASCII line number to.
B=Indicates if digit printed yet ($00=not printed).
IX points to next buffer location.
B=$01 if digit printed.
HL=Line number remainder.

Exit :

L3495:
L3496:

XOR A
ADD HL,DE
INC A
JR C,L3496
SBC HL,DE
DEC A

A=Counter.
Keep adding DE
and incrementing the counter
until there is no carry.
Adjust for the last addition and.
counter value that caused the overflow.

A=Number of multiples of DE in the line number

ADD A,$30
LD (IX+$00),A
CP '0'
JR NZ,L34B1
LD A,B
OR A
JR NZ,L34B3
LD A,$00
LD (IX+$00),A
JR L34B3
LD B,$01
INC IX
RET

L34B1:
L34B3:

Convert to an ASCII digit.
Store in the buffer.
$30. Is it a zero?
Jump ahead if not.
Get the 'digit printed' flag.

Jump ahead if already printed a digit.
Otherwise this is a leading zero, so
store a zero byte to indicate 'nothing to print'.
and jump ahead to point to the next buffer location.
Indicate 'digit printed'.
Point to the next buffer location.

Find Address of BASIC Line with Specified Line Number
This routine finds the address of the BASIC line in the program area with the specified line number, or the next line is the specified one does not exist.
Entry:

Exit :

HL=Line number.
A=$00 to print a leading space.
Carry flag set if line exists.
DE=Points to the command of the BASIC line within the program area.
HL=Line number.

L34B6:

CALL L34EA

Clear BASIC line construction pointers (address of next character in the Keyword
Construction Buffer and the address of the next character in the BASIC line within
the program area being de-tokenized).

200

OR A

LD ($FC9E),A
CALL L1F20
CALL L34F6
JR NC,L3491
EX DE,HL
LD A,L
OR H
SCF
JP NZ,L344D
CCF
JR L3491

SPECTRUM 128 ROM 0 DISASSEMBLY

[BUG - Supposed to be XOR A to ensure that a leading space is shown before a
command keyword is printed. However, most of the time the A register will enter the
routine holding $00 and so the bug is probably harmless. Credit: Paul Farrow]
Store 'print a leading space' flag.
Use Normal RAM Configuration (physical RAM bank 0).
Find the address of the BASIC line with this line number, or the next line otherwise.
Jump if does not exist.
HL=Address of BASIC line.

Address of $0000, i.e. no line exists?
Assume line number found.
Jump if a line was found.
Reset carry flag to indicate line number does not exist
and jump to make a return.

Move to Next BASIC Line

L34CF:

PUSH HL
INC HL
INC HL
LD E,(HL)
INC HL
LD D,(HL)
INC HL
ADD HL,DE
POP DE
RET

Save the address of the original line.
Skip past the line number.

Retrieve the line length into DE.

Point to the start of the next line.
DE=Address of original line.

Check if at End of BASIC Program
Check whether at the end of the BASIC program.
Entry:
Exit :

HL=Address of BASIC line.
Carry flag reset if end of BASIC program reached.

L34D9:

LD A,(HL)
AND $C0
SCF
RET Z
CCF
RET

Signal not at end of BASIC.
Return if not at end of program.
Signal at end of BASIC.

Compare Line Numbers
Compare line number at (HL) has line number held in BC.
HL=Address of first line number.
Entry:
BC=Second line number.
Carry flag and zero flag set if the line number matches.
Zero flag reset if no match, with carry flag set if line number held in BC
is lower than the line number pointed to by HL.

Exit :

L34E0:

LD A,B
CP (HL)
RET NZ
LD A,C
INC HL
CP (HL)
DEC HL
RET NZ
SCF
RET

Test the first byte.

Return if not the same.
Test the second byte.

Return if not the same.
Signal line number matches.

201

SPECTRUM 128 ROM 0 DISASSEMBLY

Clear BASIC Line Construction Pointers

L34EA:

PUSH HL
LD HL,$0000
LD ($FCA1),HL
LD ($FC9F),HL
POP HL
RET

Signal no next character to fetch from the Keyword Construction Buffer.
Signal no next character to fetch within the BASIC line in the program area.

Find Address of BASIC Line
This routine finds the address of the BASIC line within the program area with the specified line number.
Entry:
Exit :

HL=Line number to find ($0000 for first program line).
Carry flag set if requested or next line exists.
Zero flag reset if no match, with carry flag set if line number is lower than the first program line number.
HL=Address of the BASIC line number, or $0000 if line does not exist.
DE=Address of previous BASIC line number, or $0000 if line does not exist.
BC=Line number.

L34F6:

L350A:

PUSH HL
POP BC
LD DE,$0000
LD HL,($5C53)
CALL L34D9
RET NC
CALL L34E0
RET C
LD A,B
OR C
SCF
RET Z

CALL L34CF
CALL L34D9
RET NC
CALL L34E0
JR NC,L350A
RET

BC=Line number. [Quicker to have used the instructions LD B,H / LD C,L]

PROG. Address of the start of BASIC program.
Test for end of BASIC program.
Return if at end of program.
Compare line number at (HL) with BC.
Return if line number matches or is lower than the first program line number.

Return with carry and zero flags set if first program line was requested (line number
0).
Get address of next BASIC line.
Test for end of BASIC program.
Return if at end of program.
Compare line number at (HL) with BC.
If line number not the same or greater then back to test next line.
Exit with carry flag set if line found.

Fetch Next De-tokenized Character from BASIC Line in Program Area
This routine translates a tokenized BASIC line within the program area into the equivalent 'typed' line, i.e. non-tokenized.
The line number has been previously converted into a string representation and is held within the Keyword Construction Buffer at $FCA3. On each call
of this routine, the next character of the BASIC line representation is fetched. Initially this is the line number characters from the Keyword Construction
Buffer, and then the characters from the program line itself. As a token character is encountered, it is converted into its string representation and stored in
the Keyword Construction Buffer. Then each character of this string is fetched in turn. Once all of these characters have been fetched, the next character
will be from the last position accessed within the BASIC line in the program area.
Exit: Carry flag set to indicate that a character was available.
A=Character fetched.

L3517:

LD HL,($FCA1)
LD A,L
OR H
JR Z,L353C

Fetch the address of the character within the Keyword Construction Buffer.

Is there an address defined, i.e. characters still within the buffer to fetch?
Jump ahead if not.

There is a character within the Keyword Construction Buffer

LD A,(HL)
INC HL
CP ' '+$80
LD B,A

Fetch a character from the buffer.
Point to the next character.
$A0. Was it a trailing space, i.e. the last character?
Save the character.

202

L3529:

L3534:

LD A,$00
JR NZ,L3529
LD A,$FF
LD ($FC9E),A
LD A,B
BIT 7,A
JR Z,L3534
LD HL,$0000
LD ($FCA1),HL

AND $7F
JP L358F

SPECTRUM 128 ROM 0 DISASSEMBLY

Signal 'print a leading space'.
Jump ahead if not.
Signal 'do not print a leading space'.
Store the 'print a leading space' flag value.
Get the character back.
Is it the last character in the buffer, i.e. the terminator bit is set?
Jump ahead if not.
Signal no more characters within the Keyword Construction Buffer to fetch.
Store the address of the next line number/keyword character within the construction
buffer, or $0000 if no more characters.
Mask off the terminator bit.
Jump ahead to continue. [Could have saved 1 byte by using JR $358F (ROM 0)]

There is no line number/keyword defined within the buffer so fetch the next tokenized character from the BASIC line in the program area

L353C:

LD HL,($FC9F)

Fetch the address of the next character within the BASIC line construction
workspace.

L3547:

L3554:

LD A,L
OR H
JP Z,L3591
CALL L1F20
LD A,(HL)
CP $0E
JR NZ,L3554
INC HL
INC HL
INC HL
INC HL
INC HL
INC HL
JR L3547
CALL L1F45
INC HL
LD ($FC9F),HL
CP $A5

JR C,L3567
SUB $A5

Is there a character defined, i.e. end of line not yet reached?
Jump ahead if not. [Could have saved 1 byte by using JR $3591 (ROM 0)]
Use Normal RAM Configuration (physical RAM bank 0).
Fetch a character from the buffer.
Is it the hidden number marker indicating a floating-point representation?
Jump ahead if it is not.
Skip over it the floating-point representation.

Jump back to fetch the next character.
Use Workspace RAM configuration (physical RAM bank 7).
Point to the next character.
Store the address of the next command within the BASIC line to fetch.
'RND'. Is the current character a standard '48K' keyword? ('RND' = first 48K
keyword)
Jump ahead if not.
Reduce command code range to $00-$5A.

[BUG - The routine assumes all tokens require a leading and trailing space. However, this is not true for tokens '<=', '>=' and '<>'. Credit: Ian Collier
(+3), Paul Farrow (128)]

[To fix the bug, the call to $FCAE
would need to be replaced with
code such as the following.
Credit: Paul Farrow.
PUSH AF
CALL $FCAE
POP AF
CP $22
JR C,$3517 (ROM 0)
CP $25
JR NC,$3517 (ROM 0)
LD HL,($FCA1)
LD A,(HL)
CP ' '
JR NZ,NOT_LEADING
INC HL
LD ($FCA1),HL

LD A,$FF
LD ($FC9E),A
LD A,(DE)
CP ' '+$80
JR NZ,NOT_TRAILING
DEC DE

NOT_LEADING

Construct a string representation of the keyword in the Keyword Construction Buffer.
DE=Address of last character copied.
Was it '<=' or above?
Jump back if not to fetch and return the first character of the keyword string.
Was it '<>' or below?
Jump back if not to fetch and return the first character of the keyword string.
Is there a leading space?

Jump if there is not.

Skip past the leading space.

Signal 'do not print a leading space'.

Is there a trailing space?

Jump if there is not.

203

NOT_TRAILING

EX DE,HL
SET 7,(HL)

CALL $FCAE
JP L3517

It is not a standard 48K keyword

SPECTRUM 128 ROM 0 DISASSEMBLY

Set the terminator bit on the preceding character.

Construct a string representation of the keyword in the Keyword Construction Buffer.
Jump back to fetch and return the first character of the keyword string. [Could have
saved 1 byte by using JR $3517 (ROM 0)]

L3567:

CP $A3
JR C,L357B

Is it a '128K' keyword, i.e. 'SPECTRUM' or 'PLAY'?
Jump if not.

It is a 128K keyword

JR NZ,L3572

Jump if it is 'PLAY'.

Handle 'SPECTRUM'

L3572:
L3575:

Not a keyword

L357B:

LD HL,L3594
JR L3575
LD HL,L359C
CALL $FCFD
JP L3517

PUSH AF
LD A,$00
LD ($FC9E),A
POP AF
CP $0D
JR NZ,L358F

Keyword string "SPECTRUM".
Jump forward.
Keyword string "PLAY".
Copy the keyword string characters into the Keyword Construction Buffer.
Jump back to fetch and return the first character of the keyword string. [Could have
saved 1 byte by using JR $3517 (ROM 0)]

Save the character.

Signal to print a trailing space.
Get the character back.
Is it an 'Enter' character?
Jump if not to exit.

The end of the line was found so signal no further characters to fetch

LD HL,$0000
LD ($FCA1),HL
LD ($FC9F),HL
SCF
RET

L358F:

There was no character within the buffer

L3591:

SCF
CCF
RET

Signal no further character to fetch from the Keyword Construction Buffer.
Signal no further character to fetch from the BASIC line within the program area.
Set the carry flag to indicate that a character was available.

Reset the carry flag to indicate that a character was not available.

Edit Buffer Routines — Part 2

Keywords String Table
The following strings are terminated by having bit 7 set, referenced at $356D (ROM 0) and $3F87 (ROM 0).
The table consists of the new 128K mode keywords and mis-spelled keywords.

L3594:

L359C:

DEFM "SPECTRU"
DEFB 'M'+$80
DEFM "PLA"
DEFB 'Y'+$80
DEFM "GOT"
DEFB 'O'+$80

204

SPECTRUM 128 ROM 0 DISASSEMBLY

Number of bytes in table.
Flag never subsequently used. Possibly intended to indicate the start of a new
BASIC line and hence whether indentation required.
Number of characters to indent by.

DEFM "GOSU"
DEFB 'B'+$80
DEFM "DEFF"
DEFB 'N'+$80
DEFM "OPEN"
DEFB '#'+$80
DEFM "CLOSE"
DEFB '#'+$80

Indentation Settings
Copied to $FD6A-$FD6B.

L35B9:

DEFB $02
DEFB $01

DEFB $05

Set Indentation Settings

L35BC:

LD HL,L35B9
LD DE,$FD6A
JP L3FBA

HL=Address of the indentation settings data table.
Destination address.
Copy two bytes from $35B9-$35BA (ROM 0) to $FD6A-$FD6B.

Store Character in Column of Edit Buffer Row
Store character in the specified column of the current edit buffer row.
Entry:

B=Column number.
DE=Start address of row.
A=Character to insert.
B=Next column number.

Exit :

L35C5:

LD L,B
LD H,$00
ADD HL,DE
LD (HL),A
INC B
RET

Point to the required column.
Store the character.
Advance to the next column.

'Enter' Action Handler Routine

L35CC:

CALL L35E6
LD A,(HL)
OR $18
LD (HL),A
LD HL,$FD6A

SET 0,(HL)

SCF
RET

Null remaining column positions in the edit buffer row.
Fetch the flag byte.
Signal associated line number and last row in the BASIC line.
Update the flag byte.
[Redundant since flag never subsequently tested. Deleting these instructions would
have saved 5 bytes]
Flag possibly intended to indicate the start of a new BASIC line and hence whether
indentation required.
Signal no more characters are available, i.e. end of line.

'Null Columns' Action Handler Routine

L35DA:

CALL L35E6
SET 3,(HL)

Null remaining column positions in the edit buffer row.
Signal last row of the BASIC line in the row flag byte.

205

LD HL,$FD6A

SET 0,(HL)

SCF
RET

SPECTRUM 128 ROM 0 DISASSEMBLY

[Redundant since flag never subsequently tested. Deleting these instructions would
have saved 5 bytes]
Flag possibly intended to indicate the start of a new BASIC line and hence whether
indentation required.
Signal no more characters are available, i.e. end of line.

Null Column Positions
This routine inserts null characters into the remainder of a line edit buffer row.
Entry:

B=Initial column to null.
DE=Address of start of edit row.
HL=Address of the row's flag byte.

Exit :

L35E6:

L35EC:

LD L,B
LD H,$00
ADD HL,DE
LD A,$20
CP B
RET Z
LD (HL),$00
INC HL
INC B
JR L35EC

HL=Number of columns.
Point to column position in line edit buffer row.
32 columns.
Found specified column?
Return if so.
Store a null in the location.
Next buffer position.
Increment column position counter.
Repeat for next column.

Indent Edit Buffer Row
Indent a row by setting the appropriate number of characters in an edit buffer row to nulls, i.e. character $00.
Entry:
Exit :

DE=Address of row within edit buffer.
B=First usable column number in the row.

L35F4:

L35F9:

LD A,($FD6B)
LD B,$00
LD H,$00
LD L,B
ADD HL,DE
LD (HL),$00
INC B
DEC A
JR NZ,L35F9
RET

Get the number of indentation columns.
Start at first column.

HL=Column position.

Put a null in the column position.
Next position.

Repeat for all remaining columns.

Print Edit Buffer Row to Display File if Required
Print a row of the edit buffer to the display file if required.
HL=Address of edit buffer row.
Entry:

L3604:

L3614:

PUSH BC
PUSH DE
PUSH HL
PUSH HL
LD HL,$EEF5
BIT 2,(HL)
POP HL
JR NZ,L3614
LD B,C
CALL L3B1E
POP HL
POP DE
POP BC
RET

Save registers.

Save edit buffer row address.

Is printing of the edit buffer row required?
Retrieve edit buffer row address.
Jump if printing is not required.
B=Cursor row position.
Print the edit buffer row to the screen. Returns with the carry flag set.
Restore registers.

206

SPECTRUM 128 ROM 0 DISASSEMBLY

Shift Up Edit Rows in Display File if Required
This routine shifts edit rows in the display file up if required, replacing the bottom row with the top entry from the Below-Screen Line Edit Buffer.
Entry:

HL=Address of first row within the Below-Screen Line Edit Buffer.
C =Number of editing rows on screen.
B =Row number to shift from.

L3618:

L3628:

PUSH BC
PUSH DE
PUSH HL
PUSH HL
LD HL,$EEF5
BIT 2,(HL)
POP HL
JR NZ,L3628
LD E,C
CALL L3ABF

POP HL
POP DE
POP BC
RET

Save registers.

Save edit buffer row address.

Is updating of the display file required?
Retrieve edit buffer row address.
Jump if updating is not required.
E=Cursor row position, i.e. row to shift from.
Shift up edit rows in the display file, replacing the bottom row with the top entry from
the Below-Screen Line Edit Buffer.
Restore registers.

Shift Down Edit Rows in Display File if Required
This routine shifts edit rows in the display file down if required, replacing the top row with the bottom entry from the Above-Screen Line Edit Buffer.
Entry:

HL=Address of next row to use within the Above-Screen Line Edit Buffer.
C =Number of editing rows on screen.
B =Row number to shift from.

L362C:

L363C:

PUSH BC
PUSH DE
PUSH HL
PUSH HL
LD HL,$EEF5
BIT 2,(HL)
POP HL
JR NZ,L363C
LD E,C
CALL L3AC6

POP HL
POP DE
POP BC
RET

Save registers.

Save edit buffer row address.

Is updating of the display file required?
Retrieve edit buffer row address.
Jump if updating is not required.
E=Cursor row position, i.e. row to shift from.
Shift down edit rows in the display file, replacing the top row with the bottom entry
from the Above-Screen Line Edit Buffer.
Restore registers.

Set Cursor Attribute Colour

L3640:

PUSH AF
PUSH BC
PUSH DE
PUSH HL
LD A,B
LD B,C
LD C,A
CALL L3A9D
POP HL
POP DE
POP BC
POP AF
RET

Save registers.

Swap B with C.

Set cursor position attribute.
Restore registers.

207

SPECTRUM 128 ROM 0 DISASSEMBLY

Restore Cursor Position Previous Attribute

L364F:

PUSH AF
PUSH BC
PUSH DE
PUSH HL
LD A,B
LD B,C
LD C,A
CALL L3AB2
POP HL
POP DE
POP BC
POP AF
RET

Reset 'L' Mode

L365E:

L3668:

L367C:

LD A,$00
LD ($5C41),A
LD A,$02
LD ($5C0A),A
LD HL,$5C3B
LD A,(HL)
OR $0C
LD (HL),A
LD HL,$EC0D
BIT 4,(HL)
LD HL,FLAGS3
JR NZ,L367C
RES 0,(HL)
RET
SET 0,(HL)
RET

Wait for a Key Press
Exit: A holds key code.

L367F:
L3680:
L3683:

PUSH HL
LD HL,$5C3B
BIT 5,(HL)
JR Z,L3683
RES 5,(HL)
LD A,($5C08)
LD HL,$5C41
RES 0,(HL)
CP $20
JR NC,L36A2
CP $10
JR NC,L3680
CP $06
JR C,L3680

Control code or cursor key

L36A2:

L36A4:

CALL L36A4
JR NC,L3680
POP HL
RET
RST 28H

Save registers

Column.
Row.
Column.
Restore cursor position attribute.
Restore registers.

Select 'L' mode.
MODE.
Reset repeat key duration.
REPPER
FLAGS.

Select L-Mode and Print in L-Mode.

Editor flags.
Return to the calculator?
$5B66.
Jump ahead if so.
Select Editor/Menu mode.

Select BASIC/Calculator mode.

Preserve contents of HL.
FLAGS.

Wait for a key press.
Clear the new key indicator flag.
Fetch the key pressed from LAST_K.
MODE.
Remove extended mode.
Is it a control code?
Jump if not to accept all characters and token codes (used for the keypad).
Is it a cursor key?
Jump back if not to wait for another key.
Is it a cursor key?
Jump back if not to wait for another key.

Handle CAPS LOCK code and 'mode' codes.
Jump back if mode might have changed.
Restore contents of HL.

208

SPECTRUM 128 ROM 0 DISASSEMBLY

DEFW KEY_M_CL
RET

$10DB. Handle CAPS LOCK code and 'mode' codes via ROM 1.

MENU ROUTINES — PART 5

Display Menu
HL=Address of menu text.

L36A8:

L36D1:

L36D7:

L36E0:

L36E3:

PUSH HL
CALL L373B
LD HL,$5C3C
RES 0,(HL)
POP HL
LD E,(HL)
INC HL
PUSH HL
LD HL,L37EC
CALL L3733
POP HL
CALL L3733
PUSH HL
CALL L3822
LD HL,L37FA
CALL L3733
POP HL
PUSH DE
LD BC,$0807
CALL L372B
PUSH BC
LD B,$0C
LD A,$20
RST 10H
LD A,(HL)
INC HL
CP $80
JR NC,L36E0
RST 10H
DJNZ L36D7
AND $7F
RST 10H
LD A,$20
RST 10H
DJNZ L36E3
POP BC
INC B
CALL L372B
DEC E
JR NZ,L36D1
LD HL,$6F38
POP DE
SLA E
SLA E
SLA E
LD D,E
DEC D
LD E,$6F
LD BC,$FF00
LD A,D
CALL L3719
LD BC,$0001
LD A,E
CALL L3719
LD BC,$0100

Save address of menu text.
Store copy of menu screen area and system variables.
TVFLAG.
Signal using main screen.
HL=Address of menu text.
Fetch number of table entries.
Point to first entry.

Set title colours.
Print them.

Print menu title pointed to by HL.

Print Sinclair stripes.
Black ' '.
Print it.
HL=Address of first menu item text.
Save number of menu items left to print.

Perform 'Print AT 8,7;' (this is the top left position of the menu).
Save row print coordinates.
Number of columns in a row of the menu.
Print ' '.

Fetch menu item character.

End marker found?
Jump if end of text found.
Print menu item character
Repeat for all characters in menu item text.
Clear bit 7 to yield a final text character.
Print it.

Print trailing spaces
Until all columns filled.
Fetch row print coordinates.
Next row.
Print AT.

Repeat for all menu items.
Coordinates, pixel (111, 56) = end row 13, column 7.
Fetch number of menu items to E.

Determine number of pixels to span all menu items.

D=8*Number of menu items - 1.
Number of pixels in width of menu.
B=-1, C=0. Plot a vertical line going up.
A=Number of vertical pixels to plot.
Plot line.
B=0, C=1. Plot a horizontal line going to the right.
A=Number of horizontal pixels to plot.
Plot line.
B=1, C=0. Plot a vertical line going down.

209

LD A,D
INC A
CALL L3719
XOR A
CALL L37CA
RET

Plot a Line

L3719:

PUSH AF
PUSH HL
PUSH DE
PUSH BC
LD B,H
LD C,L
RST 28H
DEFW PLOT_SUB+4
POP BC
POP DE
POP HL
POP AF
ADD HL,BC
DEC A
JR NZ,L3719
RET

SPECTRUM 128 ROM 0 DISASSEMBLY

A=Number of vertical pixels to plot.
Include end pixel.
Plot line.
A=Index of menu option to highlight.
Toggle menu option selection so that it is highlight.
[Could have saved one byte by using JP $37CA (ROM 0)]

Save registers.

Coordinates to BC.

$22E9. Plot pixel
Restore registers.

Determine coordinates of next pixel.

Repeat for all pixels.

Print "AT B,C" Characters

L372B:

LD A,$16
RST 10H
LD A,B
RST 10H
LD A,C
RST 10H
RET

'AT'.
Print.
B=Row number.
Print.
C=Column number.
Print.

Print String
Print characters pointed to by HL until $FF found.

L3733:

LD A,(HL)
INC HL
CP $FF
RET Z
RST 10H
JR L3733

Fetch a character.
Advance to next character.
Reach end of string?
Return if so.
Print the character.
Back for the next character.

Store Menu Screen Area
Store copy of menu screen area and system variables.

L373B:

SCF
JR L373F

Set carry flag to signal to save screen area.
Jump ahead to continue.

Restore Menu Screen Area
Restore menu screen area and system variables from copy.
Entry:

IX=Address of the cursor settings information.

210

L373E:
L373F:

L3748:

L374D:

L3753:

L375B:

L3769:

AND A
LD DE,$EEF6
LD HL,$5C3C
JR C,L3748
EX DE,HL
LDI
JR C,L374D
EX DE,HL
LD HL,$5C7D
JR C,L3753
EX DE,HL
LD BC,$0014
LDIR
JR C,L375B
EX DE,HL
EX AF,AF'
LD BC,$0707
CALL L3B94

LD A,(IX+$01)

ADD A,B
LD B,A
LD A,$0C

PUSH BC
PUSH AF
PUSH DE
RST 28H
DEFW CL_ADDR
LD BC,$0007
ADD HL,BC
POP DE
CALL L377E
POP AF
POP BC
DEC B
DEC A
JR NZ,L3769
RET

SPECTRUM 128 ROM 0 DISASSEMBLY

Reset carry flag to signal restore screen area.
Store for TVFLAG.
TVFLAG.
Jump if storing copies.
Exchange source and destination pointers.
Transfer the byte.
Jump if storing copies.
Restore source and destination pointers.
COORDS. DE=$EEF7 by now.
Jump if storing copies.
Exchange source and destination pointers.
Copy 20 bytes.
Copy COORDS until ATTR_T.
Jump if storing copies.
Restore source and destination pointers.
Save copy direction flag.
Menu will be at row 7, column 7.
B=Number of rows to end row of screen. C=Number of columns to the end column
of the screen.
A=Rows above the editing area ($16 when using the lower screen, $00 when using
the main screen).
B=Row number within editing area.
B=Bottom screen row to store.
A=Number of rows to store. [Could have been just $07 freeing up 630 bytes of
workspace]
B holds number of row to store.
A holds number of rows left to store.
DE=End of destination address.

$0E9B. HL=Display file address of row B.
Menu always starts at column 7.
HL=Address of attribute byte at column 7.

Store / restore menu screen row.

Next row.
More rows to store / restore?
Repeat for next row

Store / Restore Menu Screen Row
Entry:

HL=Start address of menu row in display file.
DE=Screen location/Workspace store for screen row.
AF'=Carry flag set for store to workspace, reset for restore to screen.
DE=Screen location/workspace store for next screen row.

Exit :

Save the display file bytes

L377E:
L3781:

L3789:

L378E:

LD BC,$080E
PUSH BC
LD B,$00
PUSH HL
EX AF,AF'
JR C,L3789
EX DE,HL
LDIR
JR C,L378E
EX DE,HL
EX AF,AF'
POP HL
INC H
POP BC
DJNZ L3781

B=Menu row is 8 lines deep. C=Menu is 14 columns wide.
Save number of row lines.
Just keep the column count in BC.
Save display file starting address.
Retrieve copy direction flag.
Jump if storing copies of display file bytes.
Exchange source and destination pointers.
Copy the row of menu display file bytes.
Jump if storing copies of display file bytes.
Restore source and destination pointers.
Save copy direction flag.
Fetch display file starting address.
Advance to next line
Fetch number of lines.
Repeat for next line.

211

Now save the attributes

PUSH BC
PUSH DE
RST 28H
DEFW CL_ATTR
EX DE,HL
POP DE
POP BC
EX AF,AF'
JR C,L37A0
EX DE,HL
LDIR
JR C,L37A5
EX DE,HL
EX AF,AF'
RET

L37A0:

L37A5:

Move Up Menu

L37A7:

L37B1:

CALL L37CA
DEC A
JP P,L37B1
LD A,(HL)
DEC A
DEC A
CALL L37CA
SCF
RET

Move Down Menu

L37B6:

L37C5:

PUSH DE
CALL L37CA
INC A
LD D,A
LD A,(HL)
DEC A
DEC A
CP D
LD A,D
JP P,L37C5
XOR A
CALL L37CA
POP DE
RET

SPECTRUM 128 ROM 0 DISASSEMBLY

B=0. C=Number of columns.
DE=Destination address.

$0E88. HL=Address of attribute byte.
DE=Address of attribute byte.

Retrieve copy direction flag.
Jump if storing copies of attribute bytes.
Restore source and destination pointers.
Copy the row of menu attribute bytes.
Jump if storing copies of attribute bytes.
Restore source and destination pointers.
Save copy direction flag.

Toggle old menu item selection to de-highlight it.
Decrement menu index.
Jump if not exceeded top of menu.
Fetch number of menu items.
Ignore the title.
Make it indexed from 0.
Toggle new menu item selection to highlight it.
Ensure carry flag is set to prevent immediately
calling menu down routine upon return.

Save DE.
Toggle old menu item selection to de-highlight it.
Increment menu index.
Save menu index.
fetch number of menu items.
Ignore the title.
Make it indexed from 0.
Has bottom of menu been exceeded?
Fetch menu index.
Jump if bottom menu not exceeded.
Select top menu item.
Toggle new menu item selection to highlight it.
Restore DE.

Toggle Menu Option Selection Highlight

L37CA:

L37D6:

L37DA:

PUSH AF
PUSH HL
PUSH DE
LD HL,$5907
LD DE,$0020
AND A
JR Z,L37DA
ADD HL,DE
DEC A
JR NZ,L37D6
LD A,$78

Save registers.

First attribute byte at position (9,7).
The increment for each row.

Jump ahead if highlighting the first entry.
Otherwise increase HL
for each row.

Flash 0, Bright 1, Paper 7, Ink 0 = Bright white.

212

L37E1:
L37E3:

CP (HL)
JR NZ,L37E1
LD A,$68
LD D,$0E
LD (HL),A
INC HL
DEC D
JR NZ,L37E3
POP DE
POP HL
POP AF
RET

Menu Title Colours Table

L37EC:

DEFB $16, $07, $07
DEFB $15, $00
DEFB $14, $00
DEFB $10, $07
DEFB $11, 00
DEFB $13, $01
DEFB $FF

Menu Title Space Table

L37FA:

DEFB $11, $00
DEFB ' '
DEFB $11, $07
DEFB $10, $00
DEFB $FF

SPECTRUM 128 ROM 0 DISASSEMBLY

Is the entry already highlighted?
Jump ahead if not.
Flash 0, Bright 1, Paper 5, Ink 0 = Bright cyan.
There are 14 columns to set.
Set the attributes for all columns.

Restore registers.

AT 7,7
OVER 0
INVERSE 0
INK 7
PAPER 0
BRIGHT 1

PAPER 0

PAPER 7
INK 0

Menu Sinclair Stripes Bitmaps
Bit-patterns for the Sinclair stripes used on the menus.

L3802:

DEFB $01
DEFB $03
DEFB $07
DEFB $0F
DEFB $1F
DEFB $3F
DEFB $7F
DEFB $FF
DEFB $FE
DEFB $FC
DEFB $F8
DEFB $F0
DEFB $E0
DEFB $C0
DEFB $80
DEFB $00

0 0 0 0 0 0 0 1           X
0 0 0 0 0 0 1 1          XX
0 0 0 0 0 1 1 1         XXX
0 0 0 0 1 1 1 1        XXXX
0 0 0 1 1 1 1 1       XXXXX
0 0 1 1 1 1 1 1      XXXXXX
0 1 1 1 1 1 1 1     XXXXXXX
1 1 1 1 1 1 1 1    XXXXXXXX
1 1 1 1 1 1 1 0    XXXXXXX
1 1 1 1 1 1 0 0    XXXXXX
1 1 1 1 1 0 0 0    XXXXX
1 1 1 1 0 0 0 0    XXXX
1 1 1 0 0 0 0 0    XXX
1 1 0 0 0 0 0 0    XX
1 0 0 0 0 0 0 0    X
0 0 0 0 0 0 0 0

Sinclair Strip 'Text'
CHARS points to RAM at $5A98, and characters ' ' and '!' redefined as the Sinclair strips using the bit patterns above.

L3812:

DEFB $10, $02, ' '
DEFB $11, $06, '!'
DEFB $10, $04, ' '
DEFB $11, $05, '!'

INK 2
PAPER 6
INK 4
PAPER 5

213

SPECTRUM 128 ROM 0 DISASSEMBLY

DEFB $10, $00, ' '
DEFB $FF

INK 0

Print the Sinclair stripes on the menu

L3822:

PUSH BC
PUSH DE
PUSH HL
LD HL,L3802
LD DE,STRIP1
LD BC,$0010
LDIR
LD HL,($5C36)
PUSH HL
LD HL,STRIP1-$0100
LD ($5C36),HL
LD HL,L3812
CALL L3733
POP HL
LD ($5C36),HL
POP HL
POP DE
POP BC
RET

Save registers.

Graphics bit-patterns
$5B98.
Copy two characters.

Save CHARS.

$5A98.
Set CHARS to point to new graphics.
Point to the strip string.
Print it.
Restore CHARS.

Restore registers.

Print '128 BASIC' Banner

L3848:

LD HL,L2769
JR L385A

"128 BASIC" text from main menu.
Jump ahead to print banner.

Print 'Calculator' Banner

L384D:

LD HL,L2772
JR L385A

"Calculator" text from main menu.
Jump ahead to print banner.

Print 'Tape Loader' Banner

L3852:

LD HL,L275E
JR L385A

"Tape Loader" text from main menu.
Jump ahead to print banner.

Print 'Tape Tester' Banner

L3857:

LD HL,L2784

"Tape Tester" text from main menu.

Print Banner

L385A:

L3865:

PUSH HL
CALL L3881
LD HL,$5AA0
LD B,$20
LD A,$40
LD (HL),A
INC HL

Address in memory of the text of the selected menu item.
Clear lower editing area display.
Address of banner row in attributes.
32 columns.
FLASH 0, BRIGHT 1, PAPER 0, INK 0.
Set a black row.

214

DJNZ L3865
LD HL,L37EC
CALL L3733
LD BC,$1500
CALL L372B
POP DE
CALL L057D
LD C,$1A
CALL L372B
JP L3822

SPECTRUM 128 ROM 0 DISASSEMBLY

Menu title colours table.
Print the colours as a string.

Perform 'Print AT 21,0;'.
Address in memory of the text of the selected menu item.
Print the text.
B has not changed and still holds 21.
Perform 'Print AT 21,26;'.
Print Sinclair stripes and return to calling routine.

Clear Lower Editing Display

L3881:

LD B,$15
LD D,$17
JP L3B5E

Top row of editing area.
Bottom row of editing area.
Reset Display.

RENUMBER ROUTINE
Exit: Carry flag reset if required to produce an error beep.

L3888:

CALL L1F20
CALL L3A05
LD A,D
OR E
JP Z,L39C0
LD HL,(RNSTEP)
RST 28H
DEFW HL_MULT_DE

EX DE,HL
LD HL,(RNFIRST)
ADD HL,DE
LD DE,$2710
OR A
SBC HL,DE
JP NC,L39C0

There is a program that can be renumbered

L38AA:

L38B8:

L38C5:

LD HL,($5C53)
RST 28H
DEFW NEXT_ONE
INC HL
INC HL
LD (RNLINE),HL
INC HL
INC HL
LD (N_STR1+4),DE
LD A,(HL)
RST 28H
DEFW NUMBER
CP $0D
JR Z,L38C5
CALL L390E
JR L38B8
LD DE,(N_STR1+4)
LD HL,($5C4B)

Use Normal RAM Configuration (physical RAM bank 0).
DE=Count of the number of BASIC lines.

Were there any BASIC lines?
Jump if not to return since there is nothing to renumber.
$5B96. Fetch the line number increment for Renumber.

$30A9. HL=HL*DE in ROM 1. HL=Number of lines * Line increment = New last line
number. [BUG - If there are more than 6553 lines then an arithmetic overflow will
occur and hence the test below to check if line 9999 would be exceeded will fail. The
carry flag will be set upon such an overflow and simply needs to be tested. The bug
can be resolved by following the call to HL_MULT_DE with a JP C,$39C0 (ROM 0)
instruction. Credit: Ian Collier (+3), Andrew Owen (128)]
DE=Offset of new last line number from the first line number.
$5B94. Starting line number for Renumber.
HL=New last line number.
10000.

Would the last line number above 9999?
Jump if so to return since Renumber cannot proceed.

PROG. HL=Address of first BASIC line.
Find the address of the next BASIC line from the
$19B8. location pointed to by HL, returning it in DE.
Advance past the line number bytes to point
at the line length bytes.
$5B92. Store the address of the BASIC line's length bytes.
Advance past the line length bytes to point
at the command.
$5B6B. Store the address of the next BASIC line.
Get a character from the BASIC line.
Advance past a floating point number, if present.
$18B6.
Is the character an 'ENTER'?
Jump if so to examine the next line.
Parse the line, renumbering any tokens that may be followed by a line number.
Repeat for all remaining character until end of the line.
$5B6B. DE=Address of the next BASIC line.
VARS. Fetch the address of the end of the BASIC program.

215

SPECTRUM 128 ROM 0 DISASSEMBLY

AND A
SBC HL,DE
EX DE,HL
JR NZ,L38AA

Has the end of the BASIC program been reached?
HL=Address of start of the current BASIC line.
Jump back if not to examine the next line.

The end of the BASIC program has been reached so now it is time to update the line numbers and line lengths.

L38DD:

CALL L3A05
LD B,D
LD C,E
LD DE,$0000
LD HL,($5C53)
PUSH BC
PUSH DE
PUSH HL
LD HL,(RNSTEP)
RST 28H
DEFW HL_MULT_DE
LD DE,(RNFIRST)
ADD HL,DE
EX DE,HL
POP HL
LD (HL),D
INC HL
LD (HL),E
INC HL
LD C,(HL)
INC HL
LD B,(HL)
INC HL
ADD HL,BC
POP DE
INC DE
POP BC
DEC BC
LD A,B
OR C
JR NZ,L38DD
CALL L1F45
LD (RNLINE),BC

SCF
RET

DE=Count of the number of BASIC lines.

BC=Count of the number of BASIC lines.

PROG. HL=Address of first BASIC line.
BC=Count of number of lines left to update.
DE=Index of the current line.
HL=Address of current BASIC line.
$5B96. HL=Renumber line increment.
Calculate new line number offset, i.e. Line increment * Line index.
$30A9. HL=HL*DE in ROM 1.
$5B94. The initial line number when renumbering.
HL=The new line number for the current line.
DE=The new line number for the current line.
HL=Address of current BASIC line.
Store the new line number for this line.

Fetch the line length.

Point to the next line.
DE=Index of the current line.
Increment the line index.
BC=Count of number of lines left to update.
Decrement counter.

Jump back while more lines to update.
Use Workspace RAM configuration (physical RAM bank 7).
$5B92. Clear the address of line length bytes of the 'current line being renumbered'.
[No need to clear this]
Signal not to produce an error beep.

Tokens Using Line Numbers
A list of all tokens that maybe followed by a line number and hence require consideration.

L3907:

DEFB $CA
DEFB $F0
DEFB $E1
DEFB $EC
DEFB $ED
DEFB $E5
DEFB $F7

'LINE'.
'LIST'.
'LLIST'.
'GO TO'.
'GO SUB'.
'RESTORE'.
'RUN'.

Parse a Line Renumbering Line Number References
This routine examines a BASIC line for any tokens that may be followed by a line number reference and if one is found then the new line number if
calculated and substituted for the old line number reference. Although checks are made to ensure an out of memory error does not occur, the routine
simply returns silently in such scenarios and the renumber routine will continue onto the next BASIC line.
Entry:

HL=Address of current character in the current BASIC line.
A=Current character.

216

SPECTRUM 128 ROM 0 DISASSEMBLY

L390E:

INC HL
LD (HD_11+1),HL
EX DE,HL
LD BC,$0007
LD HL,L3907
CPIR
EX DE,HL
RET NZ

Point to the next character.
$5B79. Store it.
DE=Address of next character.
There are 7 tokens that may be followed by a line
number, and these are listed in the table at $3907 (ROM 0).
Search for a match for the current character.
HL=Address of next character.
Return if no match found.

A token that might be followed by a line number was found. If it is followed by a line number then proceed to renumber the line number reference. Note
that the statements such as GO TO VAL "100" will not be renumbered. The line numbers of each BASIC line will be renumbered as the last stage of
the renumber process at $38D2 (ROM 0).

L391F:

LD C,$00

LD A,(HL)
CP ' '
JR Z,L393F
RST 28H
DEFW NUMERIC
JR NC,L393F
CP '.'
JR Z,L393F
CP $0E
JR Z,L3943
OR $20
CP 'e'
JR NZ,L393B
LD A,B
OR C
JR NZ,L393F

A line number reference was not found

L393B:

L393F:

LD HL,(HD_11+1)
RET
INC BC
INC HL
JR L391F

An embedded number was found

L3943:

LD (HD_00),BC
PUSH HL
RST 28H
DEFW NUMBER
CALL L3A36
LD A,(HL)
POP HL
CP ':'
JR Z,L3957
CP $0D
RET NZ

End of statement/line found

L3957:

INC HL
RST 28H
DEFW STACK_NUM
RST 28H
DEFW FP_TO_BC

Counts the number of digits in the current line number representation. B will be $00
from above.
Fetch the next character.
$20. Is it a space?
Jump ahead if so to parse the next character.

$2D1B. Is the character a numeric digit?
Jump if a numeric digit to parse the next character.
$2E. Is it a decimal point?
Jump ahead if so to parse the next character.
Does it indicate a hidden number?
Jump ahead if so to process it.
Convert to lower case.
$65. Is it an exponent 'e'?
Jump if not to parse the next character.
Have any digits been found?

Jump ahead to parse the next character.

$5B79. Retrieve the address of the next character.

Increment the number digit counter.
Point to the next character.
Jump back to parse the character at this new address.

$5B71. Note the number of digits in the old line number reference.
Save the address of the current character.

$18B6. Advance past internal floating point representation, if present.
Skip over any spaces.
Fetch the new character.
HL=Address of the current character.
$3A. Is it ':'?
Jump if so.
Is it 'ENTER'?
Return if not.

Point to the next character.

$33B4. Move floating point number to the calculator stack.

$2DA2. Fetch the number line to BC. [BUG - This should test the carry flag to check
whether the number was too large to be transferred to BC. If so then the line number
should be set to 9999, as per the instructions at $396A (ROM 0). As a result, the call
the LINE_ADDR below can result in a crash. The bug can be resolved using a JR C,
$396A (ROM 0) instruction. Credit: Ian Collier (+3), Andrew Owen (128)]

217

SPECTRUM 128 ROM 0 DISASSEMBLY

LD H,B
LD L,C
RST 28H
DEFW LINE_ADDR
JR Z,L396F
LD A,(HL)
CP $80

JR NZ,L396F
LD HL,$270F
JR L3980

Transfer the number line to HL.
Find the address of the line number specified by HL.
$196E. HL=Address of the BASIC line, or the next one if it does not exist.
Jump if the line exists.
Has the end of the BASIC program been reached?
[BUG - This tests for the end of the variables area and not the end of the BASIC
program area. Therefore, the renumber routine will not terminate properly if variables
exist in memory when it is called. Executing CLEAR prior to renumbering will
overcome this bug. It can be fixed by replacing CP $80 with the instructions AND
$C0 / JR Z,$396F (ROM 0). Credit: Ian Collier (+3), Andrew Owen (128)]
Jump ahead if not.
Make the reference point to line 9999.
Jump ahead to update the reference to use the new line number.

The reference line exists

L396F:

LD (HD_0F+1),HL
CALL L3A0B
LD HL,(RNSTEP)
RST 28H
DEFW HL_MULT_DE

LD DE,(RNFIRST)
ADD HL,DE

HL=New line number being referenced

L3980:

LD DE,HD_0B+1
PUSH HL
CALL L3A3C
LD E,B
INC E
LD D,$00
PUSH DE
PUSH HL
LD L,E
LD H,$00
LD BC,(HD_00)
OR A
SBC HL,BC
LD (HD_00),HL

JR Z,L39CF
JR C,L39C5

$5B77. Store the address of the referenced line.
DE=Count of the number of BASIC lines up to the referenced line.
$5B96. Fetch the line number increment.

$30A9. HL=HL*DE in ROM 1. HL=Number of lines * Line increment = New
referenced line number. [An overflow could occur here and would not be detected.
The code at $3898 (ROM 0) should have trapped that such an overflow would occur
and hence there would have been no possibility of it occurring here.]
$5B94. Starting line number for Renumber.
HL=New referenced line number.

$5B73. Temporary buffer to generate ASCII representation of the new line number.
Save the new line number being referenced.
Create the ASCII representation of the line number in the buffer.

DE=Number of digits in the new line number.
DE=Number of digits in the new line number.
HL=Address of the first non-'0' character in the buffer.

HL=Number of digits in the new line number.
$5B71. Fetch the number of digits in the old line number reference.

Has the number of digits changed?
$5B71. Store the difference between the number of digits in the old and new line
numbers.
Jump if they are the same length.
Jump if the new line number contains less digits than the old.

The new line number contains more digits than the old line number

LD B,H
LD C,L
LD HL,(HD_11+1)

PUSH HL
PUSH DE
LD HL,($5C65)
ADD HL,BC
JR C,L39BE
EX DE,HL
LD HL,$0082
ADD HL,DE
JR C,L39BE
SBC HL,SP
CCF
JR C,L39BE

BC=Length of extra space required for the new line number.
$5B79. Fetch the start address of the old line number representation within the
BASIC line.
Save start address of the line number reference.
DE=Number of non-'0' characters in the line number string.
STKEND. Fetch the start of the spare memory.
Would a memory overflow occur if the space were created?
Jump if not to return without changing the line number reference.
DE=New STKEND address.
Would there be at least 130 bytes at the top of RAM?

Jump if not to return without changing the line number reference.
Is the new STKEND address below the stack?

Jump if not to return without changing the line number reference.

218

SPECTRUM 128 ROM 0 DISASSEMBLY

POP DE
POP HL
RST 28H
DEFW MAKE_ROOM
JR L39CF

DE=Number of non-'0' characters in the line number string.
HL=Start address of line number reference.

$1655. Create the space for the extra line number digits.
Jump ahead to update the number digits.

No room available to insert extra line number digits

L39BE:

POP DE
POP HL

Discard stacked items.

[At this point the stack contains 3 surplus items. These are not explicitly popped off the stack since the call to $1F45 (ROM 0) will restore the stack to the
state it was in at $3888 (ROM 0) when the call to $1F20 (ROM 0) saved it.] Exit if no BASIC program, renumbering would cause a line number overflow
or renumbering would cause an out of memory condition

L39C0:

CALL L1F45
AND A
RET

Use Workspace RAM configuration (physical RAM bank 7).
Reset the carry flag so that an error beep will be produced.

The new line number contains less digits than the old line number

L39C5:

DEC BC
DEC E
JR NZ,L39C5

LD HL,(HD_11+1)

RST 28H
DEFW RECLAIM_2

BC=Number of digits in the old line number reference.
Decrement number of digits in the new line number.
Repeat until BC has been decremented by the number of digits in the new line
number, thereby leaving BC holding the number of digits in the BASIC line to be
discarded.
$5B79. Fetch the start address of the old line number representation within the
BASIC line.

$19E8. Discard the redundant bytes.

The appropriate amount of space now exists in the BASIC line so update the line number value

L39CF:

LD DE,(HD_11+1)

POP HL
POP BC
LDIR
EX DE,HL
LD (HL),$0E
POP BC
INC HL
PUSH HL
RST 28H
DEFW STACK_BC

POP DE
LD BC,$0005
LDIR
EX DE,HL
PUSH HL
LD HL,(RNLINE)
PUSH HL
LD E,(HL)
INC HL
LD D,(HL)
LD HL,(HD_00)
ADD HL,DE
EX DE,HL

$5B79. Fetch the start address of the old line number representation within the
BASIC line.
HL=Address of the first non-'0' character in the buffer.
BC=Number of digits in the new line number.
Copy the new line number into place.
HL=Address after the line number text in the BASIC line.
Store the hidden number marker.
Retrieve the new line number being referenced.
HL=Address of the next position within the BASIC line.

$2D2B. Put the line number on the calculator stack, returning HL pointing to it. [BUG
- This stacks the new line number so that the floating point representation can be
copied. However, the number is not actually removed from the calculator stack.
Therefore the amount of free memory reduces by 5 bytes as each line with a line
number reference is renumbered. A call to FP_TO_BC (at $2DA2 within ROM 1)
after the floating point form has been copied would fix the bug. Note that all leaked
memory is finally reclaimed when control is returned to the Editor but the bug could
prevent large programs from being renumbered. Credit: Paul Farrow]
DE=Address of the next position within the BASIC line.

Copy the floating point form into the BASIC line.
HL=Address of character after the newly inserted floating point number bytes.

$5B92. HL=Address of the current line's length bytes.

DE=Existing length of the current line.
$5B71. HL=Change in length of the line.

DE=New length of the current line.

219

POP HL
LD (HL),E
INC HL
LD (HL),D
LD HL,(N_STR1+4)
LD DE,(HD_00)
ADD HL,DE
LD (N_STR1+4),HL
POP HL
RET

SPECTRUM 128 ROM 0 DISASSEMBLY

HL=Address of the current line's length bytes.

Store the new length.
$5B6B. HL=Address of the next BASIC line.
$5B71. DE=Change in length of the current line.

$5B6B. Store the new address of the next BASIC line.
HL=Address of character after the newly inserted floating point number bytes.

Count the Number of BASIC Lines
This routine counts the number of lines in the BASIC program, or if entered at $3A0B (ROM 0) counts the number of lines up in the BASIC program
to the address specified in HD_0F+1.
Exit: DE=Number of lines.

L3A05:

L3A0B:

L3A1D:

L3A2E:

LD HL,($5C4B)
LD (HD_0F+1),HL
LD HL,($5C53)
LD DE,(HD_0F+1)
OR A
SBC HL,DE
JR Z,L3A31
LD HL,($5C53)
LD BC,$0000
PUSH BC
RST 28H
DEFW NEXT_ONE
LD HL,(HD_0F+1)
AND A
SBC HL,DE
JR Z,L3A2E
EX DE,HL
POP BC
INC BC
JR L3A1D
POP DE
INC DE
RET

No BASIC program

L3A31:

LD DE,$0000
RET

Skip Spaces

L3A35:
L3A36:

INC HL
LD A,(HL)
CP ' '
JR Z,L3A35
RET

VARS. Fetch the address of the variables
$5B77. and store it.
PROG. Fetch the start of the BASIC program
$5B77. and compare against the address of
the end address to check whether there is
a BASIC program.
Jump if there is no BASIC program.
PROG. Fetch the start address of the BASIC program.
A count of the number of lines.
Save the line number count.
Find the address of the next BASIC line from the
$19B8. location pointed to by HL, returning it in DE.
$5B77. Fetch the start of the variables area,
i.e. end of the BASIC program.

Jump if end of BASIC program reached.
HL=Address of current line.
Retrieve the line number count.
Increment line number count.
Jump back to look for the next line.
Retrieve the number of BASIC lines and
increment since originally started on a line.

There are no BASIC lines.

Point to the next character.
Fetch the next character.
$20. Is it a space?
Jump if so to skip to next character.

Create ASCII Line Number Representation
Creates an ASCII representation of a line number, replacing leading zeros with spaces.
Entry:

HL=The line number to convert.
DE=Address of the buffer to build ASCII representation in.
B=Number of non-'0' characters minus 1 in the ASCII representation.
HL=Address of the first non-'0' character in the buffer.

Exit :

220

L3A3C:

PUSH DE
LD BC,$FC18
CALL L3A60
LD BC,$FF9C
CALL L3A60
LD C,$F6
CALL L3A60
LD A,L
ADD A,'0'
LD (DE),A
INC DE

Now skip over leading zeros

L3A56:

LD B,$03
POP HL
LD A,(HL)
CP '0'
RET NZ
LD (HL),' '
INC HL
DJNZ L3A56
RET

SPECTRUM 128 ROM 0 DISASSEMBLY

Store the buffer address.
BC=-1000.
Insert how many 1000s there are.
BC=-100.
Insert how many 100s there are.
BC=-10.
Insert how many 10s there are.
A=Remainder.
$30. Convert into an ASCII character ('0'..'9').
Store it in the buffer.
Point to the next buffer position.

Skip over 3 leading zeros at most.
Retrieve the buffer start address.
Fetch a character.
$30. Is it a leading zero?
Return as soon as a non-'0' character is found.
$20. Replace it with a space.
Point to the next buffer location.
Repeat until all leading zeros removed.

Insert Line Number Digit
This routine effectively works out the result of HL divided by BC. It does this by repeatedly adding a negative value until no overflow occurs.
Entry:

Exit :

L3A60:
L3A61:

HL=Number to test.
BC=Negative amount to add.
DE=Address of buffer to insert ASCII representation of the number of divisions.
HL=Remainder.
DE=Next address in the buffer.

XOR A
ADD HL,BC
INC A
JR C,L3A61
SBC HL,BC
DEC A
ADD A,'0'
LD (DE),A
INC DE
RET

Assume a count of 0 additions.
Add the negative value.
Increment the counter.
If no overflow then jump back to add again.
Undo the last step
and the last counter increment.
$30. Convert to an ASCII character ('0'..'9').
Store it in the buffer.
Point to the next buffer position.

EDITOR ROUTINES — PART 4

Initial Lower Screen Cursor Settings
Copied to $FD6C-$FD73.

L3A6D:

DEFB $08
DEFB $00
DEFB $00
DEFB $14
DEFB $00
DEFB $00
DEFB $00
DEFB $0F
DEFB $00

Number of bytes in table.
$FD6C. [Setting never used]
$FD6D = Rows above the editing area.
$FD6E. [Setting never used]
$FD6F. [Setting never used]
$FD70. [Setting never used]
$FD71. [Setting never used]
$FD72 = Cursor attribute colour (blue paper, white ink).
$FD73 = Stored cursor position screen attribute colour (None = black paper, black
ink).

221

SPECTRUM 128 ROM 0 DISASSEMBLY

Initial Main Screen Cursor Settings
Copied to $FD6C-$FD73.

L3A76:

DEFB $08
DEFB $00
DEFB $16
DEFB $01
DEFB $00
DEFB $00
DEFB $00
DEFB $0F
DEFB $00

Number of bytes in table.
$FD6C. [Setting never used]
$FD6D = Rows above the editing area.
$FD6E. [Setting never used]
$FD6F. [Setting never used]
$FD70. [Setting never used]
$FD71. [Setting never used]
$FD72 = Cursor attribute colour (blue paper, white ink).
$FD73 = Stored cursor position screen attribute colour (None = black paper, black
ink).

Set Main Screen Editing Cursor Details
Set initial cursor editing settings when using the main screen.
Copies 8 bytes from $3A6E-$3A75 (ROM 0) to $FD6C-$FD73.

L3A7F:

LD IX,$FD6C
LD HL,L3A6D
JR L3A8B

Point IX at cursor settings in workspace.
Initial values table for the lower screen cursor settings.
Jump ahead.

Set Lower Screen Editing Cursor Details
Set initial cursor editing settings when using the lower screen.
Copies 8 bytes from $3A77-$3A7E (ROM 0) to $FD6C-$FD73.

L3A88:
L3A8B:

LD HL,L3A76
LD DE,$FD6C
JP L3FBA

Initial values table for the main screen cursor settings.
DE=Cursor settings in workspace.
Jump to copy the settings.

UNUSED ROUTINES — PART 2

Print 'AD'
This routine prints to the current channel the contents of register A and then the contents of register D.
[Never called by ROM].

L3A91:

RST 10H
LD A,D
RST 10H
SCF
RET

Print character held in A.

Print character held in D.

EDITOR ROUTINES — PART 5

Store Cursor Colour

L3A96:

AND $3F
LD (IX+$06),A
SCF
RET

Mask off flash and bright bits.
Store it as the new cursor attribute value.

222

SPECTRUM 128 ROM 0 DISASSEMBLY

Set Cursor Position Attribute

L3A9D:

LD A,(IX+$01)

ADD A,B
LD B,A
CALL L3BA0
LD A,(HL)
LD (IX+$07),A
CPL
AND $C0
OR (IX+$06)
LD (HL),A
SCF
RET

A=Rows above the editing area ($16 when using the lower screen, $00 when using
the main screen).
B=Row number within editing area.
B=Screen row number.
Get address of attribute byte into HL.
Fetch current attribute byte.
Store the current attribute byte.
Invert colours.
Mask off flash and bright bits.
Get cursor colour.
Store new attribute value to screen.
[Redundant since calling routine preserves AF]

Restore Cursor Position Attribute

L3AB2:

LD A,(IX+$01)

ADD A,B
LD B,A
CALL L3BA0
LD A,(IX+$07)
LD (HL),A
RET

A=Rows above the editing area ($16 when using the lower screen, $00 when using
the main screen).
B=Row number within editing area.
B=Screen row number.
Get address of attribute byte into HL.
Get previous attribute value.
Set colour.

Shift Up Edit Rows in Display File
This routine shifts edit rows in the display file up, replacing the bottom row with the top entry from the Below-Screen Line Edit Buffer.
Entry:

HL=Address of first row in the Below-Screen Line Edit Buffer.
E =Number of editing rows on screen.
B =Row number to shift from.

L3ABF:

PUSH HL
LD H,$00
LD A,E
SUB B
JR L3ACD

Save the address of the Below-Screen Line Edit Buffer row.
Indicate to shift rows up.
A=Number of editing rows on screen.
A=Number of rows to shift, i.e. from current row to end of edit screen.
Jump ahead.

Shift Down Edit Rows in Display File
This routine shifts edit rows in the display file down, replacing the top row with the bottom entry from the Above-Screen Line Edit Buffer.
Entry:

HL=Address of next row to use within the Above-Screen Line Edit Buffer.
E =Number of editing rows on screen.
B =Row number to shift from.

L3AC6:

Shift Rows

L3ACD:

PUSH HL
LD A,E
LD E,B
LD B,A
SUB E
LD H,$FF

LD C,A
LD A,B

Save the address of the first row in Below-Screen Line Edit Buffer.
A=Number of editing rows on screen.
E=Row number to shift from.
B=Number of editing rows on screen.
A=Number of rows to shift, i.e. from current row to end of edit screen.
Indicate to shift rows down.

C=Number of rows to shift.
A=Row number to shift from.

223

SPECTRUM 128 ROM 0 DISASSEMBLY

CP E
JR Z,L3B1D

Is it the final row of the editing screen?
Jump if so to simply display the row.

Shift all display file and attributes rows up

L3AD6:

L3AE3:
L3AE4:

PUSH DE
CALL L3B98
PUSH BC
LD C,H
RST 28H
DEFW CL_ADDR
EX DE,HL
XOR A
OR C
JR Z,L3AE3
INC B
JR L3AE4
DEC B
PUSH DE
RST 28H
DEFW CL_ADDR
POP DE

Copy one row of the display file

L3AEE:

LD A,C
LD C,$20
LD B,$08
PUSH BC
PUSH HL
PUSH DE
LD B,$00
LDIR
POP DE
POP HL
POP BC
INC H
INC D
DJNZ L3AEE

Copy one row of display attributes

Save number of editing rows on screen, in E.
B=Inverted row number, i.e. 24-row number.
B=Inverted row number, C=Number of rows left to shift.
Store the direction flag.

$0E9B. HL=Destination display file address, for the row number specified by 24-B.
DE=Destination display file address.

Fetch the direction flag.
Jump if moving up to the previous row.
Move to the previous row (note that B is inverted, i.e. 24-row number).
Jump ahead.
Move to the next row (note that B is inverted, i.e. 24-row number).
DE=Destination display file address.

$0E9B. HL=Source display file address, for the row number held in B.
DE=Destination display file address.

Fetch the direction flag.
32 columns.
8 lines.

Copy one line in the display file.

Next source line in the display file.
Next destination line in the display file.
Repeat for all lines in the row.

PUSH AF
PUSH DE
RST 28H
DEFW CL_ATTR
EX DE,HL
EX (SP),HL

RST 28H
DEFW CL_ATTR
EX DE,HL
EX (SP),HL
POP DE
LD BC,$0020
LDIR

Save the duration flag.
DE=Address of next destination row in the display file.
HL=Address of next source row in the display file.
$0E88. DE=Address of corresponding attribute cell.
HL=Address of corresponding source attribute cell.
Store source attribute cell on the stack, and fetch the next destination row in the
display file in HL.
HL=Address of next destination row in the display file.
$0E88. DE=Address of corresponding destination attribute cell.
HL=Address of corresponding destination attribute cell.
Store destination attribute cell on the stack, and fetch the source attribute cell in HL.
DE=Destination attribute cell.

Copy one row of the attributes file.

Repeat to shift the next row

POP AF
POP BC
AND A
JR Z,L3B16
INC B

Retrieve the direction flag.
B=Inverted row number, C=Number of rows left to shift.
Shifting up or down?
Jump if shifting rows up.
Move to the previous row, i.e. the row to copy (note that B is inverted, i.e. 24-row
number).

224

L3B16:

L3B17:

L3B1D:

JR L3B17
DEC B

DEC C
LD H,A
JR NZ,L3AD6
POP DE
LD B,E
POP HL

SPECTRUM 128 ROM 0 DISASSEMBLY

Jump ahead.
Move to the next row, i.e. the row to copy (note that B is inverted, i.e. 24-row
number).
Decrement the row counter.
H=Direction flag.
Jump if back more rows to shift.
E=Number of editing rows on screen.
B=Number of editing rows on screen.
HL=Address of the Line Edit Buffer row to print (either in the Above-Screen Line Edit
Buffer or in the Below-Screen Line Edit Buffer).

Print a Row of the Edit Buffer to the Screen
This routine prints all 32 characters of a row in the edit buffer to the display file.
When shifting all rows up, this routine prints the top entry of the Below-Screen Line Edit Buffer to the first row of the display file.
When shifting all rows down, this routine prints the bottom entry of the Above-Screen Line Edit Buffer to the last editing row of the display file.
Entry:

B =Row number to print at.
HL=Address of edit buffer row to print.

L3B1E:

L3B31:

L3B3C:

L3B42:

L3B49:

L3B55:

CALL L3BB8
EX DE,HL
LD A,($5C3C)
PUSH AF
LD HL,$EC0D
BIT 6,(HL)
RES 0,A
JR Z,L3B31
SET 0,A
LD ($5C3C),A
LD C,$00
CALL L372B
EX DE,HL
LD B,$20
LD A,(HL)
AND A
JR NZ,L3B42
LD A,$20
CP $90
JR NC,L3B55
RST 28H
DEFW PRINT_A_1
INC HL
DJNZ L3B3C
POP AF
LD ($5C3C),A
CALL L3BB8
SCF
RET
CALL L1F20
RST 10H
CALL L1F45
JR L3B49

Clear Display Rows

L3B5E:

CALL L3BB8
LD A,D
SUB B
INC A
LD C,A
CALL L3B98

Clear display file row

Exchange colour items.
Transfer address of edit buffer row to DE.
TVFLAG.

Editor flags.
Test the editing area flag.
Allow leading space.
Jump if editing area is the main screen.
Suppress leading space.
TVFLAG.
The first column position of the edit row.
Print AT.
HL=Address of edit buffer row.
32 columns.
Character present in this position?

Jump if character found.
Display a space for a null character.
Is it a single character or UDG?
Jump if it is a UDG.
Print the character.
$0010.

Repeat for all column positions.
Restore original suppress leading space status.
TVFLAG.
Exchange colour items.
[Redundant since never subsequently checked]

Use Normal RAM Configuration (physical RAM bank 0).
Print it (need to page in RAM bank 0 to allow access to UDGs).
Use Workspace RAM configuration (physical RAM bank 7).
Jump back for next character.

Exchange 48 and 128 editing colour items.
Bottom row to clear.

A=Number of rows to clear.
C=Number of rows to clear.
B=Number of rows to end of screen.

225

L3B68:

L3B6E:

L3B72:

PUSH BC
RST 28H
DEFW CL_ADDR
LD C,$08
PUSH HL
LD B,$20
XOR A
LD (HL),A
INC HL
DJNZ L3B72
POP HL
INC H
DEC C
JR NZ,L3B6E
LD B,$20
PUSH BC
RST 28H
DEFW CL_ATTR
EX DE,HL
POP BC

Reset display file attributes

L3B86:

LD A,($5C8D)
LD (HL),A
INC HL
DJNZ L3B86

Repeat for next row

POP BC
DEC B
DEC C
JR NZ,L3B68
CALL L3BB8
SCF
RET

SPECTRUM 128 ROM 0 DISASSEMBLY

B=Row number. C=Row to clear.

$0E9B. Find display file address.
8 lines in the row.
Save start of row address.
32 columns.

Blank the row.

Get start of row address.
Next line.

Repeat for all rows.
32 columns.

$0E88. Find attribute address.

BC=32 columns.

ATTR_P.
Set display file position attribute.

Repeat for all attributes in the row.

B=Row number. C=Number of rows to clear.

Repeat for all rows.
Exchange 48 and 128 editing colour items.
[Redundant since never subsequently checked]

Find Rows and Columns to End of Screen
This routine calculates the number of rows to the end row of the screen and the number of columns to the end column of the screen. It takes into account
the number of rows above the editing area.
B=Row number.
Entry:
C=Column number.
B=Number of rows to end row of screen.
C=Number of columns to the end column of the screen.

Exit :

L3B94:

LD A,$21
SUB C
LD C,A

Reverse column number.

C=33-C. Columns to end of screen.

Find Rows to End of Screen
This routine calculates the number of rows to the end row of the screen. It takes into account the number of rows above the editing area.
Entry:
Exit :

B=Row number.
B=Number of rows to end of screen.
IX=Address of the cursor settings information.

L3B98:

LD A,$18
SUB B
SUB (IX+$01)
LD B,A

Row 24.
A=24-B.
Subtract the number of rows above the editing area.
B=Rows to end of screen.

226

SPECTRUM 128 ROM 0 DISASSEMBLY

RET

Get Attribute Address
Get the address of the attribute byte for the character position (B,C).
Entry:

B=Row number.
C=Column number.
HL=Address of attribute byte.

Exit :

L3BA0:

PUSH BC
XOR A
LD D,B
LD E,A
RR D
RR E
RR D
RR E
RR D
RR E
LD HL,$5800
LD B,A
ADD HL,BC
ADD HL,DE
POP BC
RET

Exchange Colour Items
Exchange 128 Editor and main colour items.

L3BB8:

PUSH AF
PUSH HL
PUSH DE
LD HL,($5C8D)
LD DE,($5C8F)
EXX
LD HL,($EC0F)
LD DE,($EC11)
LD ($5C8D),HL
LD ($5C8F),DE
EXX
LD ($EC0F),HL
LD ($EC11),DE

LD HL,$EC13
LD A,($5C91)
LD D,(HL)
LD (HL),A
LD A,D
LD ($5C91),A
POP DE
POP HL
POP AF
RET

Save BC.
A=0.

DE=B*256.

DE=B*32.
Start of attributes file.
B=0.
Add column offset.
Add row offset.
Restore BC.

Save registers.

ATTR_P, MASK_P. Fetch main colour items.
ATTR_T, MASK_T.
Store them.
Alternate Editor ATTR_P, MASK_P. Fetch alternate Editor colour items.
Alternate Editor ATTR_T, MASK_T.
ATTR_P, MASK_P. Store alternate Editor colour items as main colour items.
ATTR_T, MASK_T.
Retrieve main colour items ATTR_T and MASK_T.
Alternate Editor ATTR_P, MASK_P.
Alternate Editor ATTR_T, MASK_T. Store alternate Editor colour items as main
colour items.
Alternate P_FLAG. Temporary Editor store for P_FLAG.
P_FLAG.
Fetch alternate Editor version.
Store main version in alternate Editor store.
A=Alternate Editor version.
P_FLAG. Store it as main version.
Restore registers.

TAPE TESTER ROUTINE
The Tape Tester routine displays a bright blue bar completely across row 8, with 6 black markers evenly distributed above it on row 7 (columns 1, 7, 13,
19, 25 and 31). The tape port is read 2048 times and the number of highs/lows counted. A cyan marker is placed on the blue bar to indicate the ratio
of high and lows. The higher the tape player volume, the further to the right the cyan marker will appear. The Tape Tester can be exited by pressing
BREAK (though only SPACE checked), ENTER or EDIT (though only key 1 checked). Note that no attempt to read the keypad is made and so it cannot
be used to exit the Tape Tester.

227

SPECTRUM 128 ROM 0 DISASSEMBLY

Although the Sinclair manual suggests setting the tape player volume such that the cyan marker appears as far to the right of the screen as possible,
this does not guarantee the best possible loading volume. Instead, it appears better to aim for the cyan marker appearing somewhere near the mid
point of the blue bar.
There are bugs in the Tape Tester code that can cause the cyan level marker to spill over onto the first column of the row below. This is most likely to occur
when the Tape Tester is selected whilst a tape is already playing. The routine initially reads the state of the tape input and assumes this represents silence.
It then monitors the tape input for 2048 samples and counts how many high levels appear on the tape input. Should this initial reading of the tape port
not correspond to silence then when a true period of silence does occur it will be interpreted as continuous noise and hence a maximum sample count.
It is a maximum sample count that leads to the cyan marker spilling onto the next row.

L3BE9:

CALL L3C56
DI
IN A,($FE)
AND $40

Signal no key press.
Turn interrupts off since need accurate timing.
Read tape input port (bit 5).
Set the zero flag based on the state of the input line.

[BUG  -  Ideally  the  input  line  should  be  read  indefinitely  and  the  routine  only  continue  once  the  level  has  remained  the  same  for  a  large  number  of
consecutive samples. The chances of the bug occurring can be minimised by replacing the port read instructions above with the following code. Credit:
Paul Farrow.

BF23_START

BF23_LOOP

LD BC,$7FFE
IN A,(C)
AND $40

LD E,A
LD HL,$1000

IN A,(C)
BIT 0,A
JP Z,$3C56 (ROM 0)
AND $40
CP E
JR NZ,BF23_START
DEC HL
LD A,H
OR L
JR NZ,BF23_LOOP
LD A,E

Tape input port and keyboard row B to SPACE.
Read the tape input port.
Keep only the state of the input line.

Save the initial state of the tape input line.
Number of samples to monitor for changes in input line state.

Read the keyboard and tape input port.
Test for SPACE (i.e. BREAK).
Exit Tape Tester if SPACE/BREAK pressed.
Keep only the state of the input line.
Has the line input state changed?
Jump if so to restart the sampling procedure.
Decrement the number of samples left to test.

Jump if more samples to test.
Fetch the input line state.]

EX AF,AF'

Save initial state of the tape input.

Print 6 black attribute square across row 7, at 6 column intervals.

LD HL,$58E1
LD DE,$0006
LD B,E
LD A,D
LD (HL),A
ADD HL,DE
DJNZ L3BFA

L3BFA:

Screen attribute position (7,1).
DE=column spacing of the black squares.
Count 6 black squares.
A=Flash 0, Bright 0, Paper black, Ink black.
Set a black square.
Move to next column position.
Repeat for all 6 black squares.

Now enter the main loop checking for the tape input signal

L3BFE:

L3C04:

LD HL,$0000
LD DE,$0800

LD BC,$BFFE
IN A,(C)
BIT 0,A
JR Z,L3C56
LD B,$7F
IN A,(C)
BIT 0,A
JR Z,L3C56
LD B,$F7
IN A,(C)

Count of the number of high signals read from the tape port.
Read 2048 tape samples. [BUG - This should be $07C0 so that the maximum
sample count corresponds to column 31 and not column 32, and hence a spill over
onto the following row. Credit: Paul Farrow]
Read keyboard row H to ENTER.

Test for ENTER.
Jump to exit Tape Tester if ENTER pressed.
Read keyboard row B to SPACE.

Test for SPACE (i.e. BREAK).
Jump to exit Tape Tester if SPACE/BREAK pressed.
Read keyboard row 1 to 5.

228

L3C1D:

L3C2B:

BIT 0,A
JR Z,L3C56
DEC DE
LD A,D
OR E
JR Z,L3C2B
IN A,($FE)
AND $40
JR Z,L3C1D
INC HL
JR L3C1D
RL L
RL H
RL L
RL H
EX AF,AF'
JR Z,L3C3D

SPECTRUM 128 ROM 0 DISASSEMBLY

Test for 1 (i.e. EDIT).
Jump to exit Tape Tester if 1/EDIT pressed.
Decrement sample counter.

Zero flag set if all samples read.

Read the tape port.
If low then continue with next sample.
Tape port was high so increment high signal counter.
Continue with next sample.
HL could hold up to $0800.

HL=HL*4. HL could now hold $0000 to $2000.
Retrieve initial state of the tape port.
This dictates how to interpret the number of high signals counted.

If the initial tape port level was high then invert the count in H, i.e. determine number of low signals.
Note that if H holds $00 then the following code will result in a column position for the cyan marker of 32, and hence it will appear in the first column
of the row below.

EX AF,AF'
LD A,$20
SUB H
LD L,A
JR L3C3F

Re-store initial state of the tape port.
A=Column 32.
A=32-H. H could hold up to $20 so A could be $00.
L=32-H. L holds a value between $00 to $20.

If the initial tape port level was low then H holds the number of high signals found.

L3C3D:

EX AF,AF'
LD L,H

Retrieve initial state of the tape port.
L holds a value between $00 to $20.

L holds the column at which to show the cyan marker.

L3C3F:

L3C4B:

XOR A
LD H,A
LD DE,$591F
LD B,$20

LD A,$48
EI
HALT
DI
LD (DE),A
DEC DE
DJNZ L3C4B
INC DE
ADD HL,DE
LD A,$68
LD (HL),A
JR L3BFE

Set H to $00.
Attribute position (8,31).
Print a blue bar 32 columns wide underneath the 6 black squares. It is drawn here
so that it erases the previous cyan marker.
Flash 0, Bright 1, Paper blue, Ink black = Bright blue.

Wait for the screen to be redrawn.

Set each blue square in the attributes file.
Move to previous attribute position.
Repeat for all 32 columns.
Move back to first attribute column.
Determine column to show cyan marker at.
Flash 0, Bright 1, paper cyan, Ink 0 = Bright cyan.
Show the cyan marker.
Go back and count a new set of samples.

Half second delay then clear key press flag. This is called upon entry and exit of the Tape Tester.

L3C56:

L3C59:

EI
LD B,$19
HALT
DJNZ L3C59
LD HL,$5C3B
RES 5,(HL)
SCF
RET

Re-enable interrupts.
Count 25 interrupts.
Wait for half a second.

FLAGS.
Signal no key press
Setting the carry flag here serves no purpose.

229

SPECTRUM 128 ROM 0 DISASSEMBLY

EDITOR ROUTINES — PART 5

Tokenize BASIC Line
This routine serves two purposes. The first is to tokenize a typed BASIC line into a tokenized version. The second is when a syntax error is subsequently
detected within the tokenized line, and it is then used to search for the position within the typed line where the error marker should be shown.
This routine parses the BASIC line entered by the user and generates a tokenized version in the workspace area as pointed to by system variable E_LINE.
It suffers from a number of bugs related to the handling of '>' and '<' characters. The keywords '<>', '>=' and '<=' are the only keywords that do not
commence with letters and the routine traps these in a different manner to all other keywords. If a '<' or '>' is encountered then it is not immediately copied
to the BASIC line workspace since the subsequent character must be examined as it could be a '>' or '=' character and therefore might form the keywords
'<>', '>=' or '<='. A problem occurs if the subsequent character is a letter since the parser now expects the start of a possible keyword. It should at this
point insert the '<' or '>' into the BASIC line workspace but neglects to do this. It is only when the next non-letter character is encountered that the '<' or
'>' gets inserted, but this is now after the previously found string has been inserted. This results the following types of errors:
'PRINT varA>varB' is seen by the parser as 'PRINT varAvarB>' and hence a syntax error occurs.
'PRINT varA>varB1' is seen by the parser as 'PRINT varAvarB>1' and hence is accepted as a valid statement.
A work-around is to follow the '<' or '>' with a space since this forces the '<' or '>' to be inserted before the next potential keyword is examined.
A consequence of shifting a '<' or '>' is that a line such as 'PRINT a$>b$' is seen by the parser as 'PRINT a$b$>' and so it throws a syntax error.
The parser saved the '>' character for consideration when the next character was examined to see if it was part of the keywords '<>', '>=' or '<=', but fails
to discard it if the end of the statement is immediately encountered. Modifying the statement to a form that will be accepted will still cause a syntax error
since the parser mistakenly believes the '>' character applies to this statement.
The parser identifies string literals contained within quotes and will not tokenize any keywords that appear inside them, except for the keywords "<>", "<="
and ">=" which it neglects to check for. Keywords are also not tokenized following a REM statement, except again for "<>", "<=" and ">=", until the end
of the line is reached. This differs slightly to 48K BASIC mode. In 48K BASIC mode, typing a ':' following a REM statement will cause a change from 'L'
cursor mode to 'K' cursor mode and hence the next key press results in a keyword token being inserted. In 128K BASIC mode, typing a ':' will not change
to 'K' cursor mode and hence the next key press will just be the letter, number or symbol. This does not affect the running of the program since 48K
BASIC mode will ignore all characters after a REM command until the end of the line. However, creating such a REM statement in 128K BASIC mode
that appears similar to one created in 48K BASIC mode will result in more memory being used since the 'keyword' must be spelled out letter by letter.
When being used to locate the error marker position, the same process is performed as when tokenizing but no characters are actually inserted into
the workspace (they are still there from when the line was originally tokenized). Instead, a check is made after each character is processed to see if the
error marker address held in system variable X_PTR has been reached. If it does match then the routine returns with BC holding the character position
where the error marker should be displayed at.
Entry point - A syntax error was detected so the error marker must be located

L3C63:

LD A,$01
JR L3C69

Signal to locate the error marker.
Jump forward.

Entry point - Tokenize the BASIC line

L3C67:
L3C69:

LD A,$00
LD ($FD8A),A
LD HL,$0000
LD ($FD85),HL
LD ($FD87),HL

ADD HL,SP
LD ($FD8B),HL
CALL L34EA

LD A,$00
LD ($FD84),A

LD HL,$FD74
LD ($FD7D),HL
CALL L1F20

Signal to tokenize the BASIC line. [Could have saved 1 byte by using XOR A]
Store the 'locate error marker' flag.

Reset count of the number of characters in the typed BASIC line being inserted.
Reset count of the number of characters in the tokenized version of the BASIC line
being inserted.

Store the stack pointer.
Clear BASIC line construction pointers (address of next character in the Keyword
Construction Buffer and the address of the next character in the BASIC line within
the program area being de-tokenized).
[Could have saved 1 byte by using XOR A]
Signal last character was not a keyword and was not a space. [BUG - Should reset
the '<' and '>' store at $FD89 to $00 here. Attempting to insert a BASIC line such
as 'PRINT VAL a$>b' will fail since the parser does not like '>' immediately after
'a$', due to the bug at $3CB8 (ROM 0). The parser stores the '>' in $FD89 since
it will check the following character in case it should replace the two characters
with the token '<>', '>=' or '<='. After the parser throws the syntax error, it does not
clear $FD89 and so even if the line is modified such that it should be accepted, e.g.
'PRINT VAL a$=b', the parser believes the line is really '>PRINT VAL n$=b' and so
throws another syntax error. Since a letter follows the '>', the contents of $FD89 will
get cleared and hence a second attempt to insert the line will now succeed. Credit:
Paul Farrow]
HL=Start address of the Keyword Conversion Buffer.
Store as the next available location.
Use Normal RAM Configuration (physical RAM bank 0).

230

SPECTRUM 128 ROM 0 DISASSEMBLY

RST 28H
DEFW SET_MIN
CALL L1F45
LD A,$00
LD ($FD81),A

LD HL,($5C59)
LD ($FD82),HL
LD HL,$0000
LD ($FD7F),HL

$16B0. Clear the editing areas.
Use Workspace RAM configuration (physical RAM bank 7).
[Could have saved 1 byte by using XOR A, or 2 bytes by clearing this above]
Clear Keyword Conversion Buffer flags - not within REM, not with Quotes, no
characters in the buffer.
E_LINE.
Store the address of the workspace for the tokenized BASIC line.
[Could have saved 1 byte by using LD H,A followed by LD L,A]
Signal no space character between words in the Keyword Conversion Buffer.

Enter a loop to fetch each character from the BASIC line and insert it into the workspace, tokenizing along the way

L3CA1:

LD HL,($FD85)
INC HL
LD ($FD85),HL
CALL L3D9D
LD C,A

Increment count of the number of characters in the typed BASIC line.

Fetch the next character from BASIC line being inserted, return in B.
Save the character status value.

C=$01 if not a space, not a letter, not a '#' and not a '$'.
$02 if a '#' or '$'.
$03 if a space.
$06 if a letter.
B=Character fetched.

LD A,($FD81)
CP $00
JR NZ,L3CF4

Have any Keyword Conversion Buffer flags been set?
Has anything be put into the buffer yet?
Jump if so.

The first character to potentially put into the Keyword Conversion Buffer

L3CB3:

LD A,C
AND $04
JR Z,L3CED

Retrieve the character status value.
Is the character a letter?
Jump if not.

Insert the character

L3CB8:

[BUG - At this point a '>' or '<' that was previously stored should be inserted into the BASIC line workspace. However, the routine proceeds with the
new potential keyword and this is entered into the BASIC line workspace next. The '>' or '<' will only be inserted when the next non-letter character is
encountered. This causes an expression such as 'a>b1' to be translated into 'ab>1'. Credit: Ian Collier (+3), Paul Farrow (128)] [The bug can be fixed
by testing if whether a '<' or '>' character is stored. Credit: Paul Farrow.

LD A,($FD89)
AND A
JR Z,INSERT
PUSH BC
LD B,A
CALL $3E64 (ROM 0)
POP BC
XOR A
LD ($FD89),A

CALL L3DE9
JR NC,L3CC4
LD A,$01
LD ($FD81),A
JR L3CA1

INSERT

Was the last character a '>' or '<'?
Jump if not.
Save the new character.

Insert the '>' or '<' into the BASIC line workspace.
Retrieve the new character.

Clear the '>' or '<'.

Insert the character into the Keyword Conversion Buffer.
Jump if no more room within the buffer, hence string is too large to be a token.
Signal Keyword Conversion Buffer contains characters.

Jump back to fetch and process the next character.

No room to insert the character into the Keyword Conversion Buffer hence string is too large to be a valid token

231

SPECTRUM 128 ROM 0 DISASSEMBLY

L3CC4:

LD HL,($FD7F)

Fetch the address of the space character between words within the Keyword
Conversion Buffer.

LD A,L
OR H
JP NZ,L3D1E

Is there an address set?
Jump if so to copy the first word into the BASIC line workspace and the move the
second word to the start of the Keyword Conversion Buffer. Further characters can
then be appended and the contents re-evaluated in case a complete keyword is then
available.

Copy the Keyword Conversion Buffer into the BASIC line workspace

L3CCC:

PUSH BC
CALL L3DCD
POP BC
LD A,$00
LD ($FD81),A

Save the character to insert.
Copy Keyword Conversion Buffer contents into BASIC line workspace.
Retrieve the character to insert.

Signal the Keyword Conversion Buffer is empty.

C=$01 if not a space, not a letter, not a '#' and not a '$'.
$02 if a '#' or '$'.
$03 if a space.
$06 if a letter.
B=Character fetched.

L3CD6:

LD A,C
AND $01
JR NZ,L3CB3

Retrieve the character status value.
Is it a space, or not a letter and not a '#' and not a '$'?
Jump back if so to insert the character either into the Keyword Conversion Buffer or
the BASIC line workspace.

The string was too long to be a keyword and was followed by a space, a '#' or a '$'. Enter a loop to insert each character of the string into the BASIC
line workspace.

LD A,B
CALL L3E16
RET NC
LD HL,($FD85)
INC HL

LD ($FD85),HL
CALL L3D9D
LD C,A
JR L3CD6

Retrieve the character to insert.
Insert character into BASIC line workspace.
Return if tokenizing is complete.

Increment the count of the number of characters in the typed BASIC line being
inserted.

Fetch the next character from BASIC line being inserted.
Save the flags.
Jump back to insert the character of the non-keyword string into the BASIC line
workspace.

The character is not a letter so insert directly into the BASIC line workspace

L3CED:

LD A,B
CALL L3E16

RET NC
JR L3CA1

Retrieve the character to insert.
Insert character into BASIC line workspace, tokenizing '<>', '<=' and '>=' if
encountered.
Return if tokenizing is complete.
Jump back to fetch and process the next character.

Keyword Conversion buffer flags are set - either the buffer already contains characters, or within quotes or within a REM statement

L3CF4:

CP $01

JR NZ,L3CED

Is the Keyword Conversion Buffer empty or the contents marked as being within
quotes or within a REM?
Jump back if so to insert the character since this is either the first character of a new
word or is within quotes or within a REM.

C=$01 if not a space, not a letter, not a '#' and not a '$'.
$02 if a '#' or '$'.
$03 if a space.
$06 if a letter.

LD A,C

Retrieve the character status value.

232

SPECTRUM 128 ROM 0 DISASSEMBLY

AND $01
JR Z,L3CB8

Is it a letter or a '#' or a '$'?
Jump if so to simply insert the character.

The character is a space, or is not a letter and not a '#' and not a '$', i.e. the last character was the end of a potential keyword

L3CFE:

PUSH BC
CALL L3F7E
POP BC
JR C,L3D7D

Save the next character to insert and the character status value.
Attempt to identify the string in Keyword Conversion Buffer.
Retrieve the next character to insert and the character status value.
Jump if keyword identified.

The string in the Keyword Conversion Buffer was not identified as a keyword

LD HL,($FD7F)

LD A,H
OR L
JR NZ,L3D1E
LD A,C
AND $02
JR Z,L3CCC

Fetch the address of the space character between words within the Keyword
Conversion Buffer.

Is there an address set, i.e. a space between words?
Jump if there is a space character.
Retrieve the character status value.
Is it a space?
Jump if not to copy Keyword Conversion Buffer into the workspace since it is not a
keyword.

Character is a space. Allow this as the keyword could be DEF FN, GO TO, GO SUB, etc.

CALL L3DE9
JR NC,L3CC4
LD HL,($FD7D)
DEC HL
LD ($FD7F),HL

JR L3CA1

Insert the character into the Keyword Conversion Buffer.
Jump back if no room to insert the character, i.e. not a keyword since too large.
Fetch the next location address.
Point back to the last character.
Store as the address of the space character. This is used for double keywords such
as DEF FN.
Jump back to fetch and process the next character.

The string in the Keyword Conversion Buffer contains two words separated by a space that do not form a valid double keyword (such as DEF FN, GO
SUB, GO TO, etc).
For a BASIC line such as 'IF FLAG THEN' the Keyword Conversion Buffer holds the characters 'FLAG THEN'.
The 'FLAG' characters get moved to the workspace and the 'THEN' characters are shifted to the start of the Keyword Conversion Buffer before being
re-evaluated to see if they form a keyword.

L3D1E:

L3D2F:

PUSH BC
LD HL,$FD74
LD DE,($FD7F)

LD A,D
CP H
JR NZ,L3D2F
LD A,E
CP L
JR NZ,L3D2F
INC DE
DEC DE
JR L3D33

Save the character to insert and the character status value.
Point to the start address of the Keyword Conversion Buffer.
Fetch the address of the space character between words within the Keyword
Conversion Buffer.

Is the space possibly at the start of the buffer?
Jump if not.

Is the space at the start of the buffer?
Jump if not.
Point to the next location within the buffer, counter-acting the following decrement.
Point to the previous location within the buffer.
Jump ahead to copy all characters to the BASIC line workspace.

Copy all characters from the Keyword Conversion Buffer prior to the space into the BASIC line workspace

L3D32:
L3D33:

INC HL
LD A,(HL)
AND $7F
PUSH HL
PUSH DE
CALL L3E16
POP DE
POP HL
LD A,H
CP D
JR NZ,L3D32

Point to the next location within the Keyword Conversion Buffer.
Fetch a character from the Keyword Conversion Buffer.
Mask off the terminator bit.
HL=Location within Keyword Conversion Buffer.
DE=Location of last character within the Keyword conversion Buffer.
Insert character into BASIC line workspace, including a stored '<' or '>' character.

Possibly reached the character prior to the space?
Jump back if not to copy the next character.

233

SPECTRUM 128 ROM 0 DISASSEMBLY

LD A,L
CP E
JR NZ,L3D32

Reached the character prior to the space?
Jump back if not to copy the next character.

Now proceed to handle the next word

LD DE,($FD7F)
LD HL,$FD74
LD ($FD7F),HL
LD BC,($FD7D)
DEC BC
LD A,D
CP H
JR NZ,L3D70
LD A,E
CP L
JR NZ,L3D70

DE=Address of the space character between words.

Set the address of the space character to be the start of the buffer.
BC=Next location within the Keyword Conversion Buffer.
Point to the last used location.

Is the space possibly at the start of the buffer?
Jump if not.

Is the space at the start of the buffer?
Jump if not.

The space character is at the start of the Keyword Conversion Buffer

INC DE
PUSH HL
LD HL,$0000
LD ($FD7F),HL
POP HL
LD A,B
CP H
JR NZ,L3D70
LD A,C
CP L
JR NZ,L3D70
POP BC
JR L3D8F

DE=Address after the space character within the Keyword Conversion Buffer.
HL=Start address of the Keyword Conversion Buffer.

Signal no space character between words.
HL=Start address of the Keyword Conversion Buffer.

Is the space possibly the last character in the buffer?
Jump if not.

Is the space the last character in the buffer?
Jump if not.
Retrieve the character to insert and the character status value.
Jump ahead to continue.

The space is not at the start of the Keyword Conversion Buffer, i.e. the buffer contains another word after the space.
The first word has already been copied to the BASIC line workspace so now copy the second word to the start of the Keyword Conversion Buffer and
then see if it is a valid keyword. [It is not recommended to name a variable as per a keyword since statements such as 'PRINT then' will fail the syntax
check since the variable 'then' is interpreted as the keyword 'THEN' and so the statement is seen as 'PRINT THEN', which in this case is invalid.] HL
points to the start of the Keyword Conversion Buffer. DE points to the space between the two words.

L3D70:

LD A,(DE)
LD (HL),A
INC HL
INC DE
AND $80
JR Z,L3D70
LD ($FD7D),HL
JR L3CFE

Fetch a character from the second word.
Store it at the beginning of the buffer.

Reached the last character in the buffer, i.e. the terminator bit set?
Jump if not to copy the next character.
Store the new address of the next free location.
Jump back to attempt identification of the 'second' word as a keyword.

The string in the Keyword Conversion Buffer was identified as a keyword, so insert the token character code of the keyword into the BASIC line workspace.
A=Character code of identified token.

L3D7D:

PUSH BC
CALL L3E16
POP BC

Save the next character to insert and the character status value.
Insert character held in A into BASIC line workspace.
Retrieve the next character to insert and the character status value.

The token has been inserted into the BASIC line workspace so reset the Keyword Conversion Buffer

LD HL,$0000
LD ($FD7F),HL
LD A,($FD81)
CP $04
JR Z,L3D94
LD A,$00
LD ($FD81),A

L3D8F:

Indicate no space character between words in the Keyword Conversion Buffer.
Fetch the flag bits.
Within a REM statement?
Jump if so to retain the 'within a REM' flag bit.

Signal no characters within the Keyword Conversion Buffer.

234

SPECTRUM 128 ROM 0 DISASSEMBLY

L3D94:

LD HL,$FD74
LD ($FD7D),HL
JP L3CB3

Start address of the Keyword Conversion Buffer.
Store this as the next location within the buffer.
Jump back to insert the next character either into the Keyword Conversion Buffer or
the BASIC line workspace.

Fetch Next Character and Character Status from BASIC Line to Insert
Fetch the next character from the BASIC line being inserted and check whether a letter, a space, a '#' or a '$'.
Exit: B=Character.
A=$01 if not a space, not a letter, not a '#' and not a '$'.
$02 if a '#' or '$'.
$03 if a space.
$06 if a letter.

L3D9D:

L3DAC:

L3DAF:

L3DBD:

L3DC0:

L3DC3:

CALL L2D54
LD B,A
CP '?'
JR C,L3DAF
OR $20
CALL L3DC6
JR C,L3DC3
LD A,$01
RET
CP $20
JR Z,L3DC0
CP '#'
JR Z,L3DBD
JR C,L3DAC
CP '$'
JR NZ,L3DAC
LD A,$02
RET
LD A,$03
RET
LD A,$06
RET

Is Lowercase Letter?

L3DC6:

CP $7B
RET NC
CP $61
CCF
RET

Fetch the next character from the BASIC line being inserted.
Save the character.
$3F. Is it below '?' (the error marker)?
Jump if so.
Make lowercase.
Is it a letter?
Jump if so.
Indicate not space, not letter, not '#' and not '$'.

Is it a space?
Jump if so.
$23. Is it '#'?
Jump if so.
Jump if below '#'.
$24. Is it '$'?
Jump if not.
Indicate a '#' or '$'.

Indicate a space.

Indicate a letter.

Is the character above 'z'?
Return with carry flag reset if above 'z'.
Is the character below 'a'?
Return with carry flag reset if below 'a'.

Copy Keyword Conversion Buffer Contents into BASIC Line Workspace

L3DCD:

[To fix the error marker bug at $3EFB (ROM 0), the code below up until the instruction at $3DDA (ROM 0) should have been as follows]

LD HL,$FD74
CALL $3DDA (ROM 0)
LD HL,$FD74
LD ($FD7D),HL
SUB A
LD ($FD7F),A
LD ($FD80),A
RET

Start address of the Keyword Conversion Buffer.
Copy all characters into the BASIC line workspace.
Start address of the Keyword Conversion Buffer.
Store the next available location.
A=0.

Signal no space character between words in the Keyword Conversion Buffer.

235

L3DDA:

LD HL,$FD74
LD ($FD7D),HL
SUB A
LD ($FD7F),A
LD ($FD80),A
LD A,(HL)
AND $7F
PUSH HL
CALL L3E9C
POP HL
LD A,(HL)
AND $80
RET NZ
INC HL
JR L3DDA

SPECTRUM 128 ROM 0 DISASSEMBLY

Start address of the Keyword Conversion Buffer.
Store the next available location.
A=0.

Signal no space character between words in the Keyword Conversion Buffer.
Fetch a character from the buffer.
Mask off the terminator bit.
Save buffer location.
Insert the character into the BASIC line workspace, suppressing spaces as required.
Retrieve buffer location.
Re-fetch the character from the buffer.
Is it the terminator character?
Return if so.
Point to the next character in the buffer.
Jump back to handle next buffer character.

Insert Character into Keyword Conversion Buffer
Entry; B=Character to insert.
Exit : Carry flag reset if no room to insert the character within the buffer.

L3DE9:

LD HL,($FD7D)
LD DE,$FD7D
LD A,D
CP H
JR NZ,L3DF8
LD A,E
CP L
JP Z,L3E13

End of buffer not reached

L3DF8:

LD DE,$FD74
LD A,D
CP H
JR NZ,L3E03
LD A,E
CP L
JR Z,L3E09

Fetch address within Keyword Conversion Buffer.
Address after Keyword Conversion Buffer.

Has end of buffer possibly been reached?
Jump if not.

Has end of buffer been reached?
Jump if so. [Could have saved a byte by using JR instead of JP]

Start address of Keyword Conversion Buffer.

Possibly at the start of the buffer?
Jump if not.

At the start of the buffer?
Jump if so to simply store the character.

Not at the start of the buffer so need to remove terminator bit from the previous character

L3E03:

L3E09:

DEC HL
LD A,(HL)
AND $7F
LD (HL),A
INC HL
LD A,B
OR $80
LD (HL),A
INC HL
LD ($FD7D),HL
SCF
RET

End of buffer reached

L3E13:

SCF
CCF
RET

Point to the last character.

Clear the terminator bit from the last character.

Point back at the current location.
Retrieve the new character.
Set the terminator bit.
Store the character in the buffer.
Point to the next location.
Store the address of the next location.
Signal character inserted.

Clear the carry flag to indicate no room to insert the character within the buffer.

236

SPECTRUM 128 ROM 0 DISASSEMBLY

Insert Character into BASIC Line Workspace, Handling '>' and '<'
This routine inserts a character into the BASIC line workspace, tokenizing '>=', '<=' and '<>'.
Entry:
Exit :

A=Character to insert.
If tokenizing a BASIC line then returns with carry flag reset if tokenizing is complete.
If searching for the error marker location then returns with the carry flag set if the error marker has not been found,
otherwise a return is made to the main calling routine with BC holding the number of characters in the typed BASIC line,
i.e. the error marker location is at the end of the line.

L3E16:

PUSH AF

Save the character to insert.

[BUG - The string characters "<>", "<=" and ">=" get tokenized to a single character '<>', '<=' and '>=' respectively even within quotes or a REM statement.
Credit: Paul Collins (+3), Paul Farrow (128)] [BUG - 128 BASIC mode handles a colon character found following a REM statement differently to 48K
mode. In 48K mode, typing a colon returns the cursor into 'K' mode and hence the next key press inserts a keyword token. In 128K mode, typing a colon
does not cause the characters following it to be interpreted as a possible keyword. There is no noticeable difference when executing the REM statement
since subsequent statements are ignored following a REM command. However, for consistency the 128K mode editor ought to generate identical BASIC
lines to those that would be created from 48K mode. Credit: Paul Farrow] [The following instructions would be required fix the two bugs described above.
Credit: Paul Farrow.

LD A,($FD81)
BIT 1,A
JR NZ,WITHIN
BIT 2,A
JR Z,NOT_WITHIN
POP AF
PUSH AF
CP ':'
JR NZ,WITHIN
LD A,($FD81)
AND $FB
LD ($FD81),A

POP AF
JP $3E64 (ROM 0)

LD A,($FD89)
OR A
JR NZ,L3E2F
POP AF
CP '>'
JR Z,L3E2A
CP '<'
JR Z,L3E2A
CALL L3E64
RET

WITHIN

NOT_WITHIN

L3E26:

The character was '<' or '>'

L3E2A:

LD ($FD89),A
SCF
RET

The previous character was '<' or '>'

L3E2F:

CP '<'
LD A,$00
LD ($FD89),A
JR NZ,L3E52

Previous character was '<'

Within quotes?
Jump forward if within quotes.
Within a REM statement?
Jump forward if not within a REM statement.

Jump if not a colon.

Signal not within a REM statement.

Retrieve the character to insert.
Simply insert the character into the BASIC line workspace.

Was the previous character '<' or '>'?

Jump if so.
Retrieve the character to insert.
$3E. Is it '>'?
Jump if so to store for special treatment later.
$3C. Is it '<'?
Jump if so to store for special treatment later.
Insert the character into the BASIC line workspace.
[Could have saved 1 byte by using JP $3E64 (ROM 0)]

Store '<' or '>'.
Signal tokenizing not complete or error marker not found.

$3C. Was the previous character '<'?
Reset the indicator that the previous
character was '<' or '>'.
Jump ahead if not '<'.

POP AF

Retrieve the character to insert.

237

L3E41:

CP '>'
JR NZ,L3E41
LD A,$C9
JR L3E26
CP '='
JR NZ,L3E49
LD A,$C7
JR L3E26

Previous character was '<' and new character is '<'

L3E49:

PUSH AF
LD A,'<'
CALL L3E64
POP AF
JR L3E26

Previous character was '>'

L3E52:

POP AF
CP '='
JR NZ,L3E5B
LD A,$C8
JR L3E26

SPECTRUM 128 ROM 0 DISASSEMBLY

$3E. Is it '>'?
Jump ahead if not.
Tokenize to the single character '<>'.
Jump back to insert the character and return.
$3D. Is it '='?
Jump ahead if not.
Tokenize to '<='.
Jump back to insert the character and return.

Save the current character to insert.
$3C.
Put the preceding '<' character into the line.
Retrieve the character to insert.
Jump back to insert the character and return.

Retrieve the character to insert.
$3D. Is it '='?
Jump ahead if not.
Tokenize to '>='.
Jump back to insert the character and return.

Previous character was '>' and new character is '>'

L3E5B:

PUSH AF
LD A,'>'
CALL L3E64
POP AF
JR L3E26

Save the current character to insert.
$3E.
Put the preceding '>' character into the line.
Retrieve the character to insert.
Jump back to insert the character and return.

Insert Character into BASIC Line Workspace, Handling 'REM' and Quotes
This routine inserts a character into the BASIC line workspace, with special handling of a 'REM' command and strings contained within quotes.
Entry:
Exit :

A=Character to insert.
If tokenizing a BASIC line then returns with carry flag reset if tokenizing is complete.
If searching for the error marker location then returns with the carry flag set if the error marker has not been found,
otherwise a return is made directly to the main calling routine with BC holding the number of characters in the typed BASIC line,
i.e. the error marker location is at the end of the line.

L3E64:

CP $0D
JR Z,L3E88
CP $EA
LD B,A
JR NZ,L3E74

It is a 'REM' character

LD A,$04
LD ($FD81),A
JR L3E82
CP $22
JR NZ,L3E82

L3E74:

It is a quote character

LD A,($FD81)
AND $FE
XOR $02

LD ($FD81),A

Is it 'ENTER'?
Jump ahead if so.
Is it 'REM'?
Save the character.
Jump ahead if not REM.

Indicate that within a REM statement.

Jump ahead to insert the character into the BASIC line workspace.
Is it a quote?
Jump ahead if not.

Signal last character was not a keyword.
Toggle the 'within quotes' flag. Will be 1 for an opening quote, then 0 for a closing
quote.

238

SPECTRUM 128 ROM 0 DISASSEMBLY

L3E82:

LD A,B
CALL L3E9C
SCF
RET

Retrieve the character.
Insert the character into the BASIC line workspace, suppressing spaces as required.
Indicate BASIC line tokenization not complete.

It is an 'ENTER' character
[BUG - At this point a check should be made to see whether the last character was a space. If it was then it will not have been inserted but instead the
flag in $FD84 (ROM 0) will have been set. The purpose of the flag is to filter out double spaces caused by the leading/trailing spaces of tokens. Only if
the following character is not a space will the previous character, the space, be inserted. When the end of the line is found, there is no attempt to insert
this space. The bug can be fixed by the two modifications shown below. Credit: Paul Farrow]

L3E88:

LD A,($FD8A)
CP $00

JR Z,L3E99

Fetch the 'locate error marker' flag.
Searching for the error marker following a syntax error? [Could have saved 1 byte by
using AND A]
Jump if tokenizing the BASIC line.

The end of the line was reached and no error marker was found so assume the error marker exists at the end of the typed line

LD BC,($FD85)
LD HL,($FD8B)

[The first part of the fix for the
trailing space bug is as follows:
LD A,($FD84)
AND $02
JR Z,GOT_COUNT
INC BC

GOT_COUNT

BC=Count of number of the characters in the typed BASIC line being inserted.

Fetch the BASIC line insertion flags.
Was the last character a space?
Jump if not.
Increment to account for the final space.

LD SP,HL
SCF
RET

Restore the stack pointer.
Indicate the error marker was not found within the tokenized BASIC line.
Return back to the top level calling routine, to $2D04 (ROM 0).

Tokenizing the BASIC line

L3E99:

[The second part of the fix for the
trailing space bug is as follows:
LD A,($FD84)
AND $02
LD A,$20
CALL NZ,$3EFB (ROM 0)

SCF
CCF
RET

Fetch the BASIC line insertion flags.
Was the last character a space?
Insert a space into the line.
If so then insert the character into the BASIC line workspace.]

Carry flag reset to indicate tokenizing complete.

Insert Character into BASIC Line Workspace With Space Suppression
This routine is called to insert a character into the BASIC line workspace, suppressing both leading and trailing spaces around tokens, e.g. 'PRINT 10'
does not require a space stored between 'PRINT' and '10' within the BASIC line.
The routine maintains two flags which indicate whether the last character was a space or was a token. Whenever a space is encountered, it is noted
but not inserted straight away. It is only after the subsequent character is examined that the routine can determine whether the space should or should
not be inserted.
Entry:
Exit :

A=Character to insert.
A=Updated BASIC line insertion flags.

L3E9C:

LD E,A
LD A,($FD84)
LD D,A
LD A,E
CP $20

Save the character to insert in E.

D=BASIC line insertion flags.
Restore character to insert back to A.
Is it a space?

239

SPECTRUM 128 ROM 0 DISASSEMBLY

JR NZ,L3EC6

Jump ahead if not.

Character to insert is a space

LD A,D
AND $01
JR NZ,L3EBF
LD A,D
AND $02
JR NZ,L3EB7

A=BASIC line insertion flags.
Was the last character a token?
Jump ahead if so.
A=BASIC line insertion flags.
Was the last character a space?
Jump ahead if so.

Character to insert is a space and the last character was not a space/token. This could be the start of a new keyword so note the space but do not
insert it now.

LD A,D
OR $02
LD ($FD84),A
RET

A=BASIC line insertion flags.
Signal the last character was a space.
Store the updated BASIC line insertion flags.

Character to insert is a space and the last character was a space. The new space could be the start of a new keyword so keep the 'last character was
a space' flag set but insert a space for the previous space that was noted.

L3EB7:

LD A,E
CALL L3EFB
LD A,($FD84)
RET

Retrieve the character to insert.
Insert the character into the BASIC line workspace.
A=BASIC line insertion flags.

Character to insert is a space and the last character was a token. Do not insert trailing spaces for tokens.

L3EBF:

LD A,D
AND $FE
LD ($FD84),A
RET

Character to insert is not a space

A=BASIC line insertion flags.
Signal last character was not a token.
Store the updated BASIC line insertion flags.
[Could have saved 2 bytes by using JR $3EB3 (ROM 0)]

L3EC6:

CP $A3
JR NC,L3EEE

Compare against the token 'SPECTRUM' (the first 128K keyword).
Jump ahead if a token.

Character to insert is not a space and not a token

LD A,D
AND $02
JR NZ,L3EDA

A=BASIC line insertion flags.
Was the last character a space?
Jump ahead if it was.

Character to insert is not a space and not a token and the last character inserted was not a space, so just insert the character

LD A,D
AND $FE
LD ($FD84),A
LD A,E
CALL L3EFB
RET

A=BASIC line insertion flags.
Signal last character was not a keyword.
Store the new flags.
Retrieve the character to insert.
Insert the character into the BASIC line workspace.
[Could have saved one byte by using JP $3EFB (ROM 0)]

Character to insert is not a space and not a token and the last character was a space. Since the new character is not a token, the previous space was
not the start of a new keyword so insert a space and then the new character.

L3EDA:

PUSH DE
LD A,$20
CALL L3EFB
POP DE
LD A,D
AND $FE
AND $FD

Save the BASIC line insertion flags.
Insert a space into the line.
Insert the character into the BASIC line workspace.
Retrieve the flags.
A=BASIC line insertion flags.
Signal last character was not a keyword.
Signal last character was not a space.

240

SPECTRUM 128 ROM 0 DISASSEMBLY

LD ($FD84),A

LD A,E
CALL L3EFB
RET

Store the updated BASIC line insertion flags. [Could have saved 6 bytes by using JR
$3ED2 (ROM 0)]
Retrieve the character to insert.
Insert the character into the BASIC line workspace.

Character to insert is a token. Clear any previously noted space since leading spaces are not required for tokens.

L3EEE:

LD A,D
AND $FD
OR $01
LD ($FD84),A

LD A,E
CALL L3EFB
RET

A=BASIC line insertion flags.
Signal last character was not a space.
Signal last character was a keyword.
Store the updated BASIC line insertion flags. [Could have saved 6 bytes by using JR
$3ED2 (ROM 0)]
Retrieve the character to insert.
Insert the character into the BASIC line workspace.

Insert a Character into BASIC Line Workspace
This routine is called for two purposes. The first use is for inserting a character or token into the BASIC line workspace (situated at E_LINE).
The second use is after a syntax error has been identified within the tokenized BASIC line in the workspace and the location of the error marker needs
to be established. For the second case, the system variable X_PTR holds the address of where the error occurred within the tokenized BASIC line in
the workspace.
The Editor needs to identify how many characters there are before the equivalent error position is reached within the typed BASIC line. To locate it, the
typed BASIC line is re-parsed but this time without inserting any characters into the BASIC line workspace, since this still contains the tokenized line
from before. This tokenized line will now also include embedded floating point numbers for any numeric literals contained within the BASIC line. As the
typed line is re-parsed, a count of the characters examined so far is kept and instead of inserting tokenized characters within the BASIC line workspace,
a check is made to see whether the insertion location has reached the address of the error marker. If it has then the parsing of the BASIC line terminates
and the count of the typed line characters indicates the equivalent position within it of the error. However, should the last character have been a token
then the typed line count will also include the number of characters that form the keyword, and so this must be subtracted from the count.
Entry:

A=Character to insert.
DE=Address of insertion position within the BASIC line workspace.
If searching for the error marker position and it is found then a return is made directly to the top level calling routine with BC holding the
number of characters in
the typed BASIC line prior to the equivalent error marker position.

Exit :

L3EFB:

LD HL,($FD87)
INC HL
LD ($FD87),HL
LD HL,($FD82)
LD B,A
LD A,($FD8A)
CP $00

LD A,B
JR Z,L3F33

Increment the count of the number of characters in the tokenized BASIC line.

HL=Address of next insertion position in the BASIC line workspace.
Save the character to insert.
Fetch the 'locate error marker' flag.
Searching for the error marker following a syntax error? [Could have saved 1 byte by
using AND A]
A=Character to insert.
Jump if tokenizing the BASIC line.

Locating the error marker

LD DE,($5C5F)
LD A,H
CP D
JR NZ,L3F30
LD A,L
CP E
JR NZ,L3F30

X_PTR. Fetch the address of the character after the error marker.

Has the error marker position possibly been reached?
Jump ahead if not.

Has the error marker position been reached?
Jump ahead if not.

The error marker has been reached
[BUG - The desired character count until the error marker is held at address $FD85 and needs the length of the last character to be removed from it,
which for a token would be several bytes. However, the routine simply returns the lower of the tokenized and typed counts, and this yields very unhelpful
error marker positions shown within the typed BASIC line. Credit: Ian Collier (+3), Andrew Owen (128)] [The code below up until the instruction at $3F2A
(ROM 0) should have been as follows. Changes to the code at $3DCD (ROM 0) are also required. Credit: Paul Farrow.

LD HL,($FD7D)

Fetch the next address within the Keyword Conversion Buffer.

241

LD DE,$FD74
AND A
SBC HL,DE
EX DE,HL
LD HL,($FD85)

SBC HL,DE
LD B,H
LD C,L

LD BC,($FD85)

LD HL,($FD87)

AND A
SBC HL,BC
JR NC,L3F2A
LD BC,($FD87)

LD HL,($FD8B)
LD SP,HL
SCF
RET

L3F2A:

SPECTRUM 128 ROM 0 DISASSEMBLY

Fetch the start address of the Keyword Conversion Buffer.

HL=Length of the keyword (excluding leading or trailing spaces).
DE=Length of the keyword (excluding leading or trailing spaces).
BC=Count of the number of characters in the typed BASIC line until the error marker
location was found.
Subtract the number of characters in the keyword text.

Transfer the result to BC, and then return via the instructions at $3F2A (ROM 0)
onwards.]

Count of the number of characters in the typed BASIC line until the error marker
location was found.
Count of the number of characters in the tokenized BASIC line until the error marker
location.

Jump if the tokenized version is longer than the typed version.
Count of the number of characters in the tokenized version of the BASIC line until
the error marker location.
Fetch the saved stack pointer.
Restore the stack pointer.
Set the carry flag to indicate the error marker has been located.
Return back to the top level calling routine, to $2D04 (ROM 0).

The error marker has not yet been reached

L3F30:

SCF
JR L3F35

Tokenizing the BASIC line

L3F33:

L3F35:

SCF
CCF
CALL L1F20
JR NC,L3F47

Set the carry flag to indicate error marker locating mode.
Jump ahead to continue.

Reset carry flag to signal BASIC line tokenizing mode.
Use Normal RAM Configuration (physical RAM bank 0).
Jump if tokenizing the BASIC line.

Searching for the error marker so need to consider embedded floating point numbers
[BUG - This should fetch the next character from the tokenized BASIC line and not the current character. This routine is called to process every visible
character in the BASIC line, but is not called for embedded floating point numbers. It must therefore test whether the current character is followed by an
embedded floating point number and if so to skip over it. The routine does make an attempt to detect embedded floating point numbers but incorrectly
performs the test on the visible character and not the character that follows it. The bug can be fixed as replacing the LD A,(HL) instruction with the
following instructions. Credit: Paul Farrow.

INC HL
LD A,(HL)
DEC HL

LD A,(HL)
EX DE,HL
CP $0E
JR NZ,L3F5D
INC DE
INC DE

INC DE

INC DE

INC DE

JR L3F5D

Advance to the next character in the tokenized BASIC line.
Fetch the next character in the tokenized BASIC line.
Point back to the current character in the tokenized BASIC line.]

Fetch the current character in the tokenized BASIC line.
DE=Insert position within the tokenized BASIC line.
Is it the 'number' marker?
Jump ahead if not.
Skip over the 5 byte hidden number representation.
[BUG - There should be another INC DE instruction here to take into account the
character that the tokenizer would
have inserted. As a result, the attempt to locate the error marker location will drift off
by one byte for every numeric
literal within the BASIC statement, and if there are many numeric literals in the
statement then the error marker location
may never be found before the end of the statement is parsed. Credit: Ian Collier
(+3), Andrew Owen (128)]
Jump ahead to continue.

Come here if tokenizing the BASIC line

242

L3F47:

L3F5D:

PUSH AF
LD BC,$0001
PUSH HL
PUSH DE
CALL L3F66
POP DE
POP HL
RST 28H
DEFW POINTERS

LD HL,($5C65)
EX DE,HL
LDDR
POP AF

LD (DE),A
INC DE
CALL L1F45
LD ($FD82),DE
RET

SPECTRUM 128 ROM 0 DISASSEMBLY

Save the character to insert and the carry flag reset.
Request to insert 1 byte.

Check that there is memory available for 1 byte,
automatically producing error '4' if not.

BC=Number of bytes. HL=Address location before the position.
$1664. Update all system variables due to the insertion. Exit with DE pointing to old
STKEND position, BC with number of bytes 'shifted'.
STKEND. Fetch the start of the spare memory.
DE=Address of spare memory. HL=Address of character in the BASIC line.
Shift up all affected bytes to make the room for the new character.
Retrieve the character to insert and the flags. The carry flag will be reset and hence
will indicate that tokenizing the BASIC line is not complete.
Store the character in the BASIC line workspace.
Advance to the next character in the BASIC line.
Use Workspace RAM configuration (physical RAM bank 7).
Store the address of the next insertion position within the BASIC line workspace.

Room for BC Bytes?
Test whether there is room for the specified number of bytes in the spare memory, producing error "4 Out of memory" if not.
Entry:
Exit :

BC=Number of bytes required.
Returns if the room requested room is available else an error '4' is produced.

L3F66:

L3F76:

LD HL,($5C65)
ADD HL,BC
JR C,L3F76
EX DE,HL
LD HL,$0082
ADD HL,DE
JR C,L3F76
SBC HL,SP
RET C
LD A,$03
LD ($5C3A),A
JP L0321

STKEND.
Would adding the specified number of bytes overflow the RAM area?
Jump to produce an error if so.
DE=New end address.
Would there be at least 130 bytes at the top of RAM?

Jump to produce an error if not.
If the stack is lower in memory, would there still be enough room?
Return if there would.

ERR_NR. Signal error "4 Out of Memory".
Jump to error handler routine.

Identify Keyword
This routine identifies the string within the Keyword Conversion Buffer and returns the token character code. The last character of the string has bit 7 set.
The routine attempts to identify 48K mode keywords, 128K mode keywords and a number of mis-spelled keywords (those that require a space within them).
Exit: Carry flag set if a keyword was identified.
A=Token character code.

L3F7E:

CALL $FD2E
RET C

Attempt to identify 48K mode keyword.
Return if keyword identified.

Attempt to identify 128K mode keywords and mis-spelled keywords.

LD B,$F9
LD DE,$FD74
LD HL,L3594
CALL $FD3B
RET NC

Base character code (results in codes $F9-$FF).
DE=Address of Keyword Conversion Buffer.
HL=Keywords string table.
Attempt to identify 128K mode/mis-spelled keyword.
Return if no keyword identified.

Attempt to convert mis-spelled keywords

CP $FF
JR NZ,L3F96
LD A,$D4

Was it "CLOSE#"?

Use character code for 'CLOSE #'.

243

L3F96:

L3F9E:

L3FA6:

L3FAE:

L3FB6:
L3FB8:

JR L3FB8
CP $FE
JR NZ,L3F9E
LD A,$D3
JR L3FB8
CP $FD
JR NZ,L3FA6
LD A,$CE
JR L3FB8
CP $FC
JR NZ,L3FAE
LD A,$ED
JR L3FB8
CP $FB
JR NZ,L3FB6
LD A,$EC
JR L3FB8
SUB $56
SCF
RET

SPECTRUM 128 ROM 0 DISASSEMBLY

Jump ahead to continue.
Was it "OPEN#"?
Jump if not.
Use character code for 'OPEN #'.
Jump ahead to continue.
Was it "DEFFN"?
Jump if not.
Use character code for 'DEF FN'.
Jump ahead to continue.
Was it "GOSUB"?
Jump if not.
Use character code for 'GO SUB'.
Jump ahead to continue.
Was it "GOTO"?
Jump if not.
Use character code for 'GO TO'.
Jump ahead to continue.
Reduce to $A3 for 'SPECTRUM' and $A4 for 'PLAY'.
Signal keyword identified.

Copy Data Block
This routine is used on 8 occasions to copy a block of default data.
Entry:

DE=Destination address.
HL=Address of source data table, which starts with the number of bytes to copy
followed by the bytes themselves.

L3FBA:

L3FBC:

LD B,(HL)
INC HL
LD A,(HL)
LD (DE),A
INC DE
INC HL
DJNZ L3FBC
RET

Get number of bytes to copy.
Point to the first byte to copy.
Fetch the byte from the source
and copy it to the destination.
Increment destination address.
Increment source address.
Repeat for all bytes.

Get Numeric Value for ASCII Character
Exit: Carry flag set if character was numeric and A holding value.
[Never called by this ROM]

L3FC3:

CP '0'
CCF
RET NC
CP ':'
RET NC
SUB '0'
SCF
RET

$30. Test against '0'.

Return with carry flag reset if not numeric character.
$3A. Test against ':'.
Return with carry flag reset if not numeric character.
$30. Get numeric value.
Return with carry flag set to indicate a numeric character.

Call Action Handler Routine
If the code in A matches an entry in the table pointed to by HL then execute the action specified by the entry's routine address.
Entry:

Exit :

A=Code.
HL=Address of action table.
Zero flag reset if no match found.
Carry flag reset if an error beep is required, or to signal no suitable action handler found.
HL=Address of next table entry if a match was found.

L3FCE:

PUSH BC
PUSH DE

Save registers.

244

L3FD2:

No match found

Found a match

L3FE1:

L3FEB:

L3FEE:

LD B,(HL)
INC HL
CP (HL)
INC HL
LD E,(HL)
INC HL
LD D,(HL)
JR Z,L3FE1
INC HL
DJNZ L3FD2

SCF
CCF
POP DE
POP BC
RET

EX DE,HL
POP DE
POP BC
CALL L3FEE
JR C,L3FEB
CP A
RET
CP A
SCF
RET
JP (HL)

SPECTRUM 128 ROM 0 DISASSEMBLY

Fetch number of table entries.
Point to first entry.
Possible match for A?

DE=Address to call if a match.
Jump if a match.
Next table entry.
Repeat for next table entry.

Return with carry flag reset to signal an error beep is required
and with the zero flag reset to signal a match was not found.
Restore registers.

HL=Action routine to call.

Indirectly call the action handler routine.
Jump if no error beep is required.
Set zero flag to indicate a match was found.
Exit with carry flag reset to indicate error beep required.
Set zero flag to indicate a match was found.
Signal no error beep required.

Jump to the action handler routine.

PROGRAMMERS' INITIALS
[Provided by Andrew Owen]

L3FEF:

DEFB $00
DEFM "MB"
DEFB $00
DEFM "SB"
DEFB $00
DEFM "AC"
DEFB $00
DEFM "RG"
DEFB $00
DEFM "KM"
DEFB $00

Martin Brennan.

Steve Berry.

Andrew Cummins.

Rupert Goodwins.

Kevin Males.

END OF ROM MARKER

L3FFF:

DEFB $01
END

245

SPECTRUM 128 ROM 0 DISASSEMBLY

REFERENCE INFORMATION — PART 2

Routines Copied/Constructed in RAM

Construct Keyword Representation
This routine copies a keyword string from ROM 1 into the BASIC Line Construction Buffer, terminating it with an 'end of BASIC line' marker (code ' '+$80).
Only standard Spectrum keywords are handled by this routine (SPECTRUM and PLAY are processed elsewhere).
The routine is run from RAM bank 7 at $FCAE so that access to both ROMs is available.
Depending on the value of A (which should be the ASCII code less $A5, e.g. 'RND', the first (48K) keyword, has A=0), a different index into the token
table is taken. This is to allow speedier lookup since there are never more than 15 keywords to advance through.
Entry:

A=Keyword character code-$A5 (range $00-$5A).
DE=Insertion address within BASIC Line Construction Buffer.

Copied to physical RAM bank 7 at $FCAE-$FCFC by routine at $335F (ROM 0).

$FCAE

DI
LD BC,$7FFD
LD D,$17
OUT (C),D
CP $50
JR NC,$FCEB
CP $40
JR NC,$FCE4
CP $30
JR NC,$FCDD
CP $20
JR NC,$FCD6
CP $10
JR NC,$FCCF

Disable interrupts whilst paging.

Page in ROM 1, SCREEN 0, no locking, RAM bank 7.

Was the token $F5 or above?

Was the token $E5 or above?

Was the token $D5 or above?

Was the token $C5 or above?

Was the token $B5 or above?

Used for token range $A5-$B4 ($00 <= A <= $0F)

LD HL,$0096
JR $FCF0

Token table entry 'RND' in ROM 1.

Used for token range $B5-$C4 ($10 <= A <= $1F)

$FCCF

SUB $10
LD HL,$00CF
JR $FCF0

Used for token range $C5-$D4 ($20 <= A <= $2F)

Token table entry 'ASN' in ROM 1.

$FCD6

SUB $20
LD HL,$0100
JR $FCF0

Token table entry 'OR' in ROM 1.

Used for token range $D5-$E4 ($30 <= A <= $3F)

$FCDD

SUB $30
LD HL,$013E
JR $FCF0

Used for token range $E5-$F4 ($40 <= A <= $4F)

$FCE4

SUB $40
LD HL,$018B
JR $FCF0

Used for token range $F5-$FF (A >= $50)

Token table entry 'MERGE' in ROM 1.

Token table entry 'RESTORE' in ROM 1.

246

$FCEB

$FCF0

$FCF2
$FCF4

SUB $50
LD HL,$01D4
LD B,A
OR A
JR Z,$FCFD
LD A,(HL)
INC HL
AND $80
JR Z,$FCF4
DEC B

SPECTRUM 128 ROM 0 DISASSEMBLY

Token table entry 'PRINT' in ROM 1.
Take a copy of the index value.
If A=0 then already have the entry address.
If indexed item found then jump ahead to copy the characters of the token.
Fetch a character.
Point to next character.
Has end of token marker been found?
Loop back for next character if not.
Count down the index of the required token.

Copy Keyword Characters
This routine copies a keyword string from ROM 1 into the BASIC Line Construction Buffer, terminating it with an 'end of BASIC line' marker (code ' '+$80).
The routine is run from RAM bank 7 so that access to both ROMs is available.
Entry:

HL=Address of keyword string in ROM 1.
DE=Insertion address within BASIC Line Construction Buffer.

Copied to physical RAM bank 7 at $FCFD-$FD2D by subroutine at $335F (ROM 0).

$FCFD

$FD13

LD DE,$FCA3
LD ($FCA1),DE
LD A,($FC9E)
OR A
LD A,$00
LD ($FC9E),A
JR NZ,$FD13
LD A,$20
LD (DE),A
INC DE
LD A,(HL)
LD B,A
INC HL
LD (DE),A
INC DE
AND $80
JR Z,$FD13
LD A,B
AND $7F
DEC DE
LD (DE),A
INC DE
LD A,' '+$80
LD (DE),A
LD A,$07
LD BC,$7FFD
OUT (C),A
EI

DE=Keyword Construction Buffer.
Store the start address of the constructed keyword.
Print a leading space?

Signal leading space not required.
Jump if leading space not required.
Print a leading space.
Insert a leading space.
Advance to next buffer position.
Fetch a character of the keyword.
Store it.
Advance to next keyword character.
Store the keyword character in the BASIC line buffer.
Advance to the next buffer position.
Test if the end of the keyword string.
Jump back if not to repeat for all characters of the keyword.
Get keyword character back.
Mask of bit 7 which indicates the end of string marker.
Point back at the last character of the keyword copied into the buffer
and store it.
Advance to the position in the buffer after the last character of the keyword.
$A0. ' ' + end marker
Store an 'end of BASIC line so far' marker.

Page in ROM 0, SCREEN 0, no locking, RAM bank 7.
Re-enable interrupts.

Identify Token
This routine identifies the string within the Keyword Conversion Buffer and returns the character code. The last character of the string to identify has
bit 7 set.
Exit: Carry flag set if token identified.
B=Character code.
Copied to physical RAM bank 7 at $FD2E-$FD69 by subroutine at $335F (ROM 0).

$FD2E

DI
LD BC,$7FFD
LD D,$17
OUT (C),D
LD HL,$0096
LD B,$A5

Disable interrupts whilst paging.

Select ROM 1, SCREEN 0, RAM bank 7.

Address of token table in ROM 1.
Character code of the first token - 'RND'.

Entry point here used to match 128K mode tokens and mis-spelled tokens

247

$FD3B
$FD3E

$FD48

LD DE,$FD74
LD A,(DE)
AND $7F
CP $61
LD A,(DE)
JR C,$FD48
AND $DF
CP (HL)
JR NZ,$FD54
INC HL
INC DE
AND $80
JR Z,$FD3E

A match was found

$FD54

SCF
JR $FD60
INC B
JR Z,$FD5F

SPECTRUM 128 ROM 0 DISASSEMBLY

Keyword Conversion Buffer holds the text to match against.
Fetch a character from the buffer.
Mask off terminator bit.
Is it lowercase?
Fetch the character again from the buffer.
Jump if uppercase.
Make the character uppercase.
Does the character match the current item in the token table?
Jump if it does not.
Point to the next character in the buffer.
Point to the next character in the token table.
Has the terminator been reached?
Jump back if not to test the next character in the token.

Signal a match was found.
Jump ahead to continue.
The next character code to test against.
Jump if all character codes tested.

The token does not match so skip to the next entry in the token table

$FD57

LD A,(HL)
AND $80
INC HL
JR Z,$FD57
JR $FD3B

Fetch the character from the token table.
Has the end terminator been found?
Point to the next character.
Jump back if no terminator found.
Jump back to test against the next token.

All character codes tested and no match found

$FD5F

OR A

Clear the carry flag to indicate no match found.

The common exit point

$FD60

LD A,B
LD D,$07
LD BC,$7FFD
OUT (C),D
EI

Fetch the character code of the matching token ($00 for no match).
Select ROM 0, SCREEN 0, RAM bank 7.

Re-enable interrupts.

Insert Character into Display File
Copy a character into the display file.
Entry:

HL=Character data.
DE=Display file address.
utine is constructed from three segments and stitched together in physical RAM bank 7 to form a single routine.

This ro

Created in physical RAM Bank 7 at $FF28-$FF60 by routine at $246F (ROM 0). [Construction routine never actually called by the ROM]

$FF28

PUSH BC
DI
LD BC,$7FFD
LD A,(BANK_M)
XOR $10
OUT (C),A
EI
EX AF,AF'
LD C,D
LD A,(HL)
LD (DE),A
INC HL
INC D
LD A,(HL)

Save BC
Disable interrupts whilst paging.

$5B5C. Fetch current paging configuration.
Toggle ROMs.
Perform paging.
Re-enable interrupts.
Save the new configuration in A'.
Save D.

Copy byte 1.

248

LD (DE),A
INC HL
INC D
LD A,(HL)
LD (DE),A
INC HL
INC D
LD A,(HL)
LD (DE),A
INC HL
INC D
LD A,(HL)
LD (DE),A
INC HL
INC D
LD A,(HL)
LD (DE),A
INC HL
INC D
LD A,(HL)
LD (DE),A
INC HL
INC D
LD A,(HL)
LD (DE),A
LD D,C
EX AF,AF'
DI
LD C,$FD
XOR $10
OUT (C),A
EI
POP BC

SPECTRUM 128 ROM 0 DISASSEMBLY

Copy byte 2.

Copy byte 3.

Copy byte 4.

Copy byte 5.

Copy byte 6.

Copy byte 7.

Copy byte 8.
Restore D.
Retrieve current paging configuration.
Disable interrupts whilst paging.
Restore Paging I/O port number.
Toggle ROMs.
Perform paging.
Re-enable interrupts.
Restore BC.

Standard Error Report Codes
0 — OK
1 — NEXT without FOR

2 — Variable not found

3 — Subscript wrong
4 — Out of memory
5 — Out of screen

6 — Number too big
7 — RETURN without GO SUB
8 — End of file
9 — STOP statement
A — Invalid argument
B — Integer out of range

C — Nonsense in BASIC
D — BREAK - CONT repeats
E — Out of DATA
F — Invalid file name
G — No room for line
H — STOP in INPUT
I — FOR without NEXT

J — Invalid I/O device
K — Invalid colour
L — BREAK into program

Successful completion, or jump to a line number bigger than any existing.
The control variable does not exist (it has not been set up by a FOR statement), but there is an ordinary
variable with the same name.
For a simple variable, this will happen if the variable is used before it has been assigned to by a LET,
READ or INPUT statement, loaded from disk (or tape), or set up in a FOR statement. For a subscripted
variable, it will happen if the variable is used before it has been dimensioned in a DIM statement, or loaded
from disk (or tape).
A subscript is beyond the dimension of the array or there are the wrong number of subscripts.
There is not enough room in the computer for what you are trying to do.
An INPUT statement has tried to generate more than 23 lines in the lower half of the screen. Also occurs
with 'PRINT AT 22,xx'.
Calculations have yielded a number greater than approximately 10^38.
There has been one more RETURN than there were GO SUBs.
Input returned unacceptable character code.
After this, CONTINUE will not repeat the STOP but carries on with the statement after.
The argument for a function is unsuitable.
When an integer is required, the floating point argument is rounded to the nearest integer. If this is outside
a suitable range, then this error results.
The text of the (string) argument does not form a valid expression.
BREAK was pressed during some peripheral operation.
You have tried to READ past the end of the DATA list.
SAVE with filename empty or longer than 10 characters.
There is not enough room left in memory to accommodate the new program line.
Some INPUT data started with STOP.
A FOR loop was to be executed no times (e.g. FOR n=1 TO 0) and corresponding NEXT statement could
not be found.
Attempting to input characters from or output characters to a device that doesn't support it.
The number specified is not an appropriate value.
BREAK pressed. This is detected between two statements.

249

SPECTRUM 128 ROM 0 DISASSEMBLY

M — RAMTOP no good
N — Statement lost
O — Invalid Stream

P — FN without DEF
Q — Parameter error
R — Tape loading error

The number specified for RAMTOP is either too big or too small.
Jump to a statement that no longer exists.
Trying to input from or output to a stream that isn't open or that is out of range (0...15), or trying to open a
stream that is out of range.
User-defined function used without a corresponding DEF in the program.
Wrong number of arguments, or one of them is the wrong type.
A file on tape was found but for some reason could not be read in, or would not verify.

Standard System Variables
These occupy addresses $5C00-$5CB5.
8
KSTATE
1
LASTK
1
REPDEL

$5C00
$5C08
$5C09

REPPER

DEFADD

K_DATA
TVDATA
STRMS
CHARS
RASP
PIP
ERR_NR
FLAGS

$5C0A

$5C0B

$5C0D
$5C0E
$5C10
$5C36
$5C38
$5C39
$5C3A
$5C3B

1

2

1
2
38
2
1
1
1
1

IY-$3A
IY-$32
IY-$31

IY-$30

IY-$2F

IY-$2D
IY-$2C
IY-$2A
IY-$04
IY-$02
IY-$01
IY+$00
IY+$01

TVFLAG

$5C3C

1

IY+$02

ERR_SP
LISTSP
MODE

NEWPPC
NSPPC
PPC
SUBPPC
BORDCR

E_PPC
VARS
DEST
CHANS

$5C3D
$5C3F
$5C41

$5C42
$5C44
$5C45
$5C47
$5C48

$5C49
$5C4B
$5C4D
$5C4F

2
2
1

2
1
2
1
1

2
2
2
2

IY+$03
IY+$05
IY+$07

IY+$08
IY+$0A
IY+$0B
IY+$0D
IY+$0E

IY+$0F
IY+$11
IY+$13
IY+$15

Used in reading the keyboard.
Stores newly pressed key.
Time (in 50ths of a second) that a key must be held down before it repeats. This
starts off at 35.
Delay (in 50ths of a second) between successive repeats of a key held down -
initially 5.
Address of arguments of user defined function (if one is being evaluated), otherwise
0.
Stores second byte of colour controls entered from keyboard.
Stores bytes of colour, AT and TAB controls going to TV.
Addresses of channels attached to streams.
256 less than address of character set, which starts with ' ' and carries on to '©'.
Length of warning buzz.
Length of keyboard click.
1 less than the report code. Starts off at 255 (for -1) so 'PEEK 23610' gives 255.
Various flags to control the BASIC system:
Bit 0: 1=Suppress leading space.
Bit 1: 1=Using printer, 0=Using screen.
Bit 2: 1=Print in L-Mode, 0=Print in K-Mode.
Bit 3: 1=L-Mode, 0=K-Mode.
Bit 4: 1=128K Mode, 0=48K Mode. [Always 0 on 48K Spectrum]
Bit 5: 1=New key press code available in LAST_K.
Bit 6: 1=Numeric variable, 0=String variable.
Bit 7: 1=Line execution, 0=Syntax checking.
Flags associated with the TV:
Bit 0 : 1=Using lower editing area, 0=Using main screen.
Bit 1-2: Not used (always 0).
Bit 3 : 1=Mode might have changed.
Bit 4 : 1=Automatic listing in main screen, 0=Ordinary listing in main screen.
Bit 5 : 1=Lower screen requires clearing after a key press.
Bit 6 : 1=Tape Loader option selected (set but never tested). [Always 0 on 48K
Spectrum]
Bit 7 : Not used (always 0).
Address of item on machine stack to be used as error return.
Address of return address from automatic listing.
Specifies cursor type:
$00='L' or 'C'.
$01='E'.
$02='G'.
$04='K'.
Line to be jumped to.
Statement number in line to be jumped to.
Line number of statement currently being executed.
Number within line of statement currently being executed.
Border colour multiplied by 8; also contains the attributes normally used for the
lower half
of the screen.
Number of current line (with program cursor).
Address of variables.
Address of variable in assignment.
Address of channel data.

250

CURCHL
PROG
NXTLIN
DATADD
E_LINE
K_CUR
CH_ADD

X_PTR
WORKSP
STKBOT
STKEND
BREG
MEM
FLAGS2

DF_SZ
S_TOP
OLDPPC
OSPPC
FLAGX

STRLEN
T_ADDR
SEED
FRAMES
UDG

COORDS

P_POSN
PR_CC

ECHO_E
DF_CC
DF_CCL
S_POSN

SPOSNL
SCR_CT

ATTR_P
MASK_P

ATTR_T
MASK_T
P_FLAG

$5C51
$5C53
$5C55
$5C57
$5C59
$5C5B
$5C5D

$5C5F
$5C61
$5C63
$5C65
$5C67
$5C68
$5C6A

$5C6B
$5C6C
$5C6E
$5C70
$5C71

$5C72
$5C74
$5C76
$5C78
$5C7B

$5C7D
$5C7E
$5C7F
$5C80

$5C82
$5C84
$5C86
$5C88
$5C89
$5C8A
$5C8C

$5C8D
$5C8E

$5C8F
$5C90
$5C91

2
2
2
2
2
2
2

2
2
2
2
1
2
1

1
2
2
1
1

2
2
2
3
2

1
1
1
2

2
2
2
1
1
2
1

1
1

1
1
1

SPECTRUM 128 ROM 0 DISASSEMBLY

IY+$17
IY+$19
IY+$1B
IY+$1D
IY+$1F
IY+$21
IY+$23

IY+$25
IY+$27
IY+$29
IY+$2B
IY+$2D
IY+$2E
IY+$30

IY+$31
IY+$32
IY+$34
IY+$36
IY+$37

IY+$38
IY+$3A
IY+$3C
IY+$3E
IY+$41

IY+$43
IY+$44
IY+$45
IY+$46

IY+$48
IY+$4A
IY+$4C
IY+$4E
IY+$4F
IY+$50
IY+$52

IY+$53
IY+$54

IY+$55
IY+$56
IY+$57

Address of information currently being used for input and output.
Address of BASIC program.
Address of next line in program.
Address of terminator of last DATA item.
Address of command being typed in.
Address of cursor.
Address of the next character to be interpreted - the character after the argument of
PEEK,
or the NEWLINE at the end of a POKE statement.
Address of the character after the '?' marker.
Address of temporary work space.
Address of bottom of calculator stack.
Address of start of spare space.
Calculator's B register.
Address of area used for calculator's memory (usually MEMBOT, but not always).
Flags:
Bit 0 : 1=Screen requires clearing.
Bit 1 : 1=Printer buffer contains data.
Bit 2 : 1=In quotes.
Bit 3 : 1=CAPS LOCK on.
Bit 4 : 1=Using channel 'K'.
Bit 5-7: Not used (always 0).
The number of lines (including one blank line) in the lower part of the screen.
The number of the top program line in automatic listings.
Line number to which CONTINUE jumps.
Number within line of statement to which CONTINUE jumps.
Flags:
Bit 0 : 1=Simple string complete so delete old copy.
Bit 1 : 1=Indicates new variable, 0=Variable exists.
Bit 2-4: Not used (always 0).
Bit 5 : 1=INPUT mode.
Bit 6 : 1=Numeric variable, 0=String variable. Holds nature of existing variable.
Bit 7 : 1=Using INPUT LINE.
Length of string type destination in assignment.
Address of next item in syntax table.
The seed for RND. Set by RANDOMIZE.
3 byte (least significant byte first), frame counter incremented every 20ms.
Address of first user-defined graphic. Can be changed to save space by having
fewer
user-defined characters.
X-coordinate of last point plotted.
Y-coordinate of last point plotted.
33-column number of printer position.
Full address of next position for LPRINT to print at (in ZX Printer buffer).
Legal values $5B00 - $5B1F. [Not used in 128K mode]
33-column number and 24-line number (in lower half) of end of input buffer.
Address in display file of PRINT position.
Like DF CC for lower part of screen.
33-column number for PRINT position.
24-line number for PRINT position.
Like S_POSN for lower part.
Counts scrolls - it is always 1 more than the number of scrolls that will be done
before
stopping with 'scroll?'.
Permanent current colours, etc, as set up by colour statements.
Used for transparent colours, etc. Any bit that is 1 shows that the corresponding
attribute
bit is taken not from ATTR_P, but from what is already on the screen.
Temporary current colours (as set up by colour items).
Like MASK_P, but temporary.
Flags:

251

SPECTRUM 128 ROM 0 DISASSEMBLY

Bit 0: 1=OVER 1, 0=OVER 0.
Bit 1: Not used (always 0).
Bit 2: 1=INVERSE 1, 0=INVERSE 0.
Bit 3: Not used (always 0).
Bit 4: 1=Using INK 9.
Bit 5: Not used (always 0).
Bit 6: 1=Using PAPER 9.
Bit 7: Not used (always 0).
Calculator's memory area - used to store numbers that cannot conveniently be put
on the
calculator stack.
Not used on standard Spectrum. [Used by ZX Interface 1 Edition 2 for printer
WIDTH]
Address of last byte of BASIC system area.
Address of last byte of physical RAM.

MEMBOT

$5C92

30

IY+$58

RAMTOP
P_RAMT

$5CB0

$5CB2
$5CB4

2

2
2

IY+$76

IY+$78
IY+$7A

Memory Map
The conventional memory is used as follows:

BASIC
ROM

Display
File

Attributes
File

New System
Variables

System
Variables

$0000

$4000

$5800

$5B00

$5C00

$5CB6 = CHANS

Channel
Info

$80

BASIC
Program

Variables
Area

$80

Edit Line
or Command

NL

$80

CHANS

PROG

VARS

E_LINE

WORKSP

INPUT
data

NL

Temporary
Work Space

Calculator
Stack

Spare

Machine
Stack

GOSUB
Stack

?

$3E

UDGs

WORKSP

STKBOT

STKEND

SP

RAMTOP UDG

P_RAMT

I Register
The I register is used along with the R register by the Z80 for automatic memory refreshing. Setting the I register to a value between $40 and $7F causes
memory refreshes to occur to the lower 16K RAM. This RAM is contended with the ULA which uses it for the generation of the video display.
The memory refreshes get interpreted by the ULA as the CPU requesting to access the lower 16K RAM bank very rapidly and very often. The ULA is
not able to handle reads at such a high frequency, with the consequence that it fails to fetch and output the next screen byte. Instead it uses re-uses
the byte previously read. This causes a visible corruption to the video display output, often referred to a 'snow', although no actual corruption occurs to
the video display RAM. This also happens when the I register is set to a value between $C0 and $FF when a contended RAM bank is paged in and,
unlike the Spectrum 16K/48K, can lead to a machine crash.

Screen File Formats
The two screens available on the Spectrum 128, the normal screen in RAM bank 5 ($4000-$5AFF) and the shadow screen in RAM bank 7 ($C000-
$FFFF), both use the same file format.

Display File
The display file consists of 3 areas, each consisting of 8 characters rows, with each row consisting of 8 pixel lines.
Each pixel line consists of 32 cell columns, with each cell consisting of a byte that represents 8 pixels.
The address of a particular cell is formed as follows:
a

a

0

1

c

c

c

c

s

c

r

r

r

l

l

l

Bit:

15

14

13

12

11

10

9

8

7

6

5

4

3

2

1

0

252

SPECTRUM 128 ROM 0 DISASSEMBLY

where:

s = Screen (0-1: 0=Normal screen, 1=Shadow Screen)
aa = Area (0-2)
rrr = Row (0-7)
lll = Line (0-7)
ccccc = Column (0-31)

An area value of 3 denotes the attributes file, which consists of a different format.

Attributes File
The attributes file consists of 24 characters rows, with each row consisting of 32 cell columns.
Each cell consisting of a byte that holds the colour information.
The address of a particular cell is formed as follows:
1

1

0

1

0

c

c

s

c

c

r

r

r

r

r

c

15

14

Bit:
where:

13

11

12

10

9
s = Screen (0-1: 0=Normal screen, 1=Shadow Screen)
rrrrr = Row (0-23)
ccccc = Column (0-31)

8

7

6

5

4

3

2

1

0

Each cell holds a byte of colour information:
i

p

p

p

b

f

i

i

7

Bit:
where:

6

5

3

4

2

0

1
f = Flash (0-1: 0=Off, 1=On)
b = Bright (0-1: 0=Off, 1=On)
ppp = Paper (0-7: 0=Black, 1=Blue, 2=Red, 3=Magenta, 4=Green, 5=Cyan, 6=Yellow, 7=White)
iii = Ink (0-7: 0=Black, 1=Blue, 2=Red, 3=Magenta, 4=Green, 5=Cyan, 6=Yellow, 7=White)

Address Conversion Between Display File and Attributes File
The address of the attribute cell corresponding to an address in the display file can be constructed by moving bits 11 to 12 (the area value) to bit positions
8 to 9, setting bit 10 to 0 and setting bits 11 to 12 to 1.
The address of the display file character cell corresponding to an address in the attributes file can be constructed by moving bits 8 to 9 (the row value)
to bit positions 11 to 12, and then setting bits 8 to 9 to 0.

Standard I/O Ports

Port $FE
This controls the cassette interface, the speaker, the border colour and is used to read the keyboard.
Since it is the ULA that controls these facilities, it will introduce a delay when accessing the port if it is busy at the time, and hence I/O port $FE is
subject to contention.
OUTPUT:
Bit 0-2: Border colour (0=Black, 1=Blue, 2=Red, 3=Magenta, 4=Green, 5=Cyan, 6=Yellow, 7=White).
Bit 3 : MIC output (1=Off, 0=On).
Bit 4 : Speaker output (1=On, 0=Off).
Bit 5-7: Not used.
INPUT:
Upper byte selects keyboard row to read.

Bit1
2
W
S
Z

Bit4
Bit2
Bit0
6
3
$F7FE
1
Y
E
$FBFE Q
H
D
$FDFE A
$FEFE
B
X
Bit 0-4 : Key states (corresponding bit is 0 if the key is pressed).
Bit 5 : Not used (always 1).
Bit 6 : EAR input.
Bit 7 : Not used (always 1).

Bit3
4
R
F
C

Bit4
5
T
G
V

SHIFT

Bit3
7
U
J
N

Bit2
8
I
K
M

Bit1
9
O
L
SYM

Bit0
$EFFE
0
P
$DFFE
ENTER $BFFE
SPACE $7FFE

Cassette Header Format
A file consists of a header block followed by a data block. Each block begins with a flag that indicates whether it is a header block or a data block. Next
are the header or data bytes, and finally a checksum of the flag and header/data bytes.
Flag - A value of $00 for a header and $FF for a data block.

253

SPECTRUM 128 ROM 0 DISASSEMBLY

Bytes - The bytes forming the header information or the file data.
Checksum - An XOR checksum of the Flag and Bytes fields.
The header information consists of 17 bytes and these describe the size and type of data that the data block contains.
The header bytes have the following meaning:
Byte $00 : File type - $00=Program, $01=Numeric array, $02=Character array, $03=Code/Screen$.
Bytes $01-$0A: File name, padding with trailing spaces.
Bytes $0B-$0C: Length of program/code block/screen$/array ($1B00 for screen$).
Bytes $0D-$0E: For a program, it holds the auto-run line number ($80 in byte $0E if no auto-run).
For code block/screen$ it holds the start address ($4000 for screen$).
For an array, it holds the variable name in byte $0E.
Bytes $0F-$10: Offset to the variables (i.e. length of program) if a program.

AY-3-8912 Programmable Sound Generator Registers
This is controlled through output I/O port $FFFD. It is driven from a 1.77345 MHz clock.
The datasheet for the AY-3-8912 lists to the registers in octal, but below they are listed in decimal.

Registers 0 and 1 (Channel A Tone Generator)
Forms a 12 bit pitch control for sound channel A. The basic unit of tone is the clock frequency divided by 16, i.e. 110.841 kHz. With a 12 bit counter range,
4095 different frequencies from 27.067 Hz to 110.841 kHz (in increments of 27.067 Hz) can be generated.
Bits 0-7 : Contents of register 0.
Bits 8-11 : Contents of lower nibble of register 1.
Bits 12-15: Not used.

Registers 2 and 3 (Channel B Tone Generator)
Forms a 12 bit pitch control for sound channel B.
Bits 0-7 : Contents of register 2.
Bits 8-11 : Contents of lower nibble of register 3.
Bits 12-15: Not used.

Registers 4 and 5 (Channel C Tone Generator)
Forms a 12 bit pitch control for sound channel C.
Bits 0-7 : Contents of register 4.
Bits 8-11 : Contents of lower nibble of register 5.
Bits 12-15: Not used.

Register 6 (Noise Generator)
The frequency of the noise is obtained in the PSG by first counting down the input clock by 16 (i.e. 110.841 kHz), then by further counting down the
result by the programmed 5 bit noise period value held in bits 0-4 of register 6. With a 5 bit counter range, 31 different frequencies from 3.576 kHz to
110.841 kHz (in increments of 3.576 kHz) can be generated.

Register 7 (Mixer — I/O Enable)
This controls the enable status of the noise and tone mixers for the three channels, and also controls the I/O port used to drive the RS232 and Keypad
sockets.
Bit 0: Channel A Tone Enable (0=enabled).
Bit 1: Channel B Tone Enable (0=enabled).
Bit 2: Channel C Tone Enable (0=enabled).
Bit 3: Channel A Noise Enable (0=enabled).
Bit 4: Channel B Noise Enable (0=enabled).
Bit 5: Channel C Noise Enable (0=enabled).
Bit 6: I/O Port Enable (0=input, 1=output).
Bit 7: Not used.

Register 8 (Channel A Volume)
This controls the volume of channel A.
Bits 0-4: Channel A volume level.
Bit 5 : 1=Use envelope defined by register 13 and ignore the volume setting.
Bits 6-7: Not used.

254

SPECTRUM 128 ROM 0 DISASSEMBLY

Register 9 (Channel B Volume)
This controls the volume of channel B.
Bits 0-4: Channel B volume level.
Bit 5 : 1=Use envelope defined by register 13 and ignore the volume setting.
Bits 6-7: Not used.

Register 10 (Channel C Volume)
This controls the volume of channel C.
Bits 0-4: Channel C volume level.
Bit 5 : 1=Use envelope defined by register 13 and ignore the volume setting.
Bits 6-7: Not used.

Register 11 and 12 (Envelope Period)
These registers allow the frequency of the envelope to be selected.
The frequency of the envelope is obtained in the PSG by first counting down the input clock by 256 (6.927 kHz), then further counting down the result
by the programmed 16 bit envelope period value. With a 16 bit counter range, 65535 different frequencies from 1.691 Hz to 110.841 kHz (in increments
of 1.691 Hz) can be generated.
Bits 0-7 : Contents of register 11.
Bits 8-15: Contents of register 12.

Register 13 (Envelope Shape)
This register allows the shape of the envelope to be selected.
The envelope generator further counts down the envelope frequency by 16, producing a 16-state per cycle envelope pattern. The particular shape and
cycle pattern of any desired envelope is accomplished by controlling the count pattern of the 4 bit counter and by defining a single cycle or repeat cycle
pattern.
Bit 0 : Hold.
Bit 1 : Alternate.
Bit 2 : Attack.
Bit 3 : Continue.
Bits 4-7: Not used.
These control bits can produce the following envelope waveforms:

255

Bit: 3 2 1 0

0 0 X X

0 1 X X

1 0 0 0

1 0 0 1

1 0 1 0

1 0 1 1

1 1 0 0

1 1 0 1

1 1 1 0

1 1 1 1

SPECTRUM 128 ROM 0 DISASSEMBLY

Single decay then off.
Used by W0 PLAY command.

Single attack then off.
Used by W1 PLAY command.

Repeated decay.
Used by W4 PLAY command.

Single decay then off.
Not used by PLAY command (use W0 instead).

Repeated decay-attack.
Used by W7 PLAY command.

Single decay then hold.
Used by W2 PLAY command.

Repeated attack.
Used by W5 PLAY command.

Single attack then hold.
Used by W3 PLAY command.

Repeated attack-delay.
Used by W6 PLAY command.

Single attack then off.
Not used by PLAY command (use W1 instead).

Envelope period

Register 14 (I/O Port)
This controls the RS232 and Keypad sockets.
Once the register has been selected, it can be read via port $FFFD and written via port $BFFD.
Bit 0: KEYPAD CTS (out) - 0=Spectrum ready to receive, 1=Busy
Bit 1: KEYPAD RXD (out) - 0=Transmit high bit, 1=Transmit low bit
Bit 2: RS232 CTS (out) - 0=Spectrum ready to receive, 1=Busy
Bit 3: RS232 RXD (out) - 0=Transmit high bit, 1=Transmit low bit
Bit 4: KEYPAD DTR (in) - 0=Keypad ready for data, 1=Busy
Bit 5: KEYPAD TXD (in) - 0=Receive high bit, 1=Receive low bit
Bit 6: RS232 DTR (in) - 0=Device ready for data, 1=Busy
Bit 7: RS232 TXD (in) - 0=Receive high bit, 1=Receive low bit
The RS232 port also doubles up as a MIDI port, with communications to MIDI devices occurring at 31250 baud.
Commands and data can be sent to MIDI devices. Command bytes have the most significant bit set, whereas data bytes have it reset.

Socket Pin Outs

RS232/MIDI Socket
The RS232/MIDI socket is controlled by register 14 of the AY-3-8912 sound generator.

6 5

4

3 2 1

Front view

Pin

1

Signal

0V

256

SPECTRUM 128 ROM 0 DISASSEMBLY

2
3
4
5
6

TXD - In (Bit 7)
RXD - Out (Bit 3)
DTR - In (Bit 6)
CTS - Out (Bit 2)
12V

Keypad Socket
The keypad socket is controlled by register 14 of the AY-3-8912 sound generator.
Only bits 0 and 5 are used for communications with the keypad (pins 2 and 5).
Writing a 1 to bit 0 (pin 2) will eventually force the keypad to reset.
Summary information about the keypad and its communications protocol can be found in the Spectrum 128 Service Manual and a detailed description
can be found at www.fruitcake.plus.com.

6 5

4

3 2 1

Front view

Pin

Signal

0V
OUT - Out (Bit 0)
n/u - In (Bit 4)
n/u - Out (Bit 1)
IN - In (Bit 5)
12V

1
2
3
4
5
6
n/u = Not used for keypad communications.
The keypad socket was later used by Amstrad to support a lightgun. There are no routines within the ROMs to handle communication with the lightgun
so each game has to implement its own control software. Only bits 4 and 5 are used for communication with the lightgun (pins 3 and 5).
The connections to the lightgun are as follows:
Pin

Signal

1
2
3
4
5
6
n/u = Not used for lightgun communication.

0V
n/u - Out (Bit 0)
SENSOR - In (Bit 4)
n/u - Out (Bit 1)
TRIGGER - In (Bit 5)
12V

Monitor Socket

7

3

5

6

1

8

2

4

Pin

Signal

Level

1
2
3
4
5
6
7
8
A detailed description of the monitor socket and circuitry, and how to construct a suitable RGB SCART cable can be found at www.fruitcake.plus.com.

1.2V pk-pk (75 Ohms)
0V
TTL
TTL
TTL
TTL
TTL
TTL

Composite PAL
0 Volts
Bright Output
Composite Sync
Vertical Sync
Green
Red
Blue

257

SPECTRUM 128 ROM 0 DISASSEMBLY

Edge Connector
Pin
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
Side A=Component Side, Side B=Underside.
n/u = Not used.

Side A
A15
A13
D7
n/u
Slot
D0
D1
D2
D6
D5
D3
D4
/INT
/NMI
/HALT
/MREQ
/IORQ
/RD
/WR
-5V
/WAIT
+12V
-12V
/M1
/RFSH
A8
A10
n/u

Side B
A14
A12
+5V
+9V
Slot
0V
0V
/CLK
A0
A1
A2
A3
/IORQULA
0V
n/u (On 48K Spectrum = VIDEO)
n/u (On 48K Spectrum = /Y)
n/u (On 48K Spectrum = V)
n/u (On 48K Spectrum = U)
/BUSREQ
/RESET
A7
A6
A5
A4
/ROMCS
/BUSACK
A9
A11

258

